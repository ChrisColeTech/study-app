{
  "version": 3,
  "sources": ["../../src/handlers/question-handler.ts", "../../src/types/index.ts", "../../src/shared/response-builder.ts", "../../src/shared/logger.ts", "../../src/shared/base-handler.ts", "../../src/services/s3-service.ts", "../../src/services/cache-service.ts", "../../node_modules/uuid/dist/esm-node/stringify.js", "../../node_modules/uuid/dist/esm-node/rng.js", "../../node_modules/uuid/dist/esm-node/native.js", "../../node_modules/uuid/dist/esm-node/v4.js", "../../src/services/question-service.ts"],
  "sourcesContent": ["import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';\nimport { BaseHandler } from '../shared/base-handler';\nimport { GetQuestionsRequest, QuestionFilter, PaginationOptions } from '../types';\nimport { QuestionService } from '../services/question-service';\n\n/**\n * Question Handler V2 - Study question management with S3 backend\n * Supports filtering, search, and pagination\n */\nclass QuestionHandler extends BaseHandler {\n  private questionService: QuestionService;\n\n  constructor() {\n    super('QuestionHandler');\n    this.questionService = new QuestionService();\n  }\n\n  /**\n   * Get questions with filtering, search, and pagination\n   */\n  public async getQuestions(event: APIGatewayProxyEvent, userId: string): Promise<APIGatewayProxyResult> {\n    this.logger.info('Fetching questions for user', { userId });\n\n    try {\n      // Extract query parameters\n      const provider = this.getQueryParam(event, 'provider') || 'aws';\n      const exam = this.getQueryParam(event, 'exam') || 'saa-c03';\n      const limit = parseInt(this.getQueryParam(event, 'limit', '50') || '50', 10);\n      const offset = parseInt(this.getQueryParam(event, 'offset', '0') || '0', 10);\n      \n      // Build filters\n      const filter: QuestionFilter = {};\n      \n      if (this.getQueryParam(event, 'difficulty')) {\n        filter.difficulty = this.getQueryParam(event, 'difficulty') as any;\n      }\n      \n      if (this.getQueryParam(event, 'topics')) {\n        filter.topics = this.getQueryParam(event, 'topics')?.split(',') || [];\n      }\n      \n      if (this.getQueryParam(event, 'serviceCategory')) {\n        filter.serviceCategory = this.getQueryParam(event, 'serviceCategory');\n      }\n      \n      if (this.getQueryParam(event, 'awsServices')) {\n        filter.awsServices = this.getQueryParam(event, 'awsServices')?.split(',') || [];\n      }\n      \n      if (this.getQueryParam(event, 'search')) {\n        filter.search = this.getQueryParam(event, 'search');\n      }\n      \n      if (this.getQueryParam(event, 'hasExplanation')) {\n        filter.hasExplanation = this.getQueryParam(event, 'hasExplanation') === 'true';\n      }\n      \n      if (this.getQueryParam(event, 'questionType')) {\n        filter.questionType = this.getQueryParam(event, 'questionType') as any;\n      }\n\n      // Build pagination\n      const pagination: PaginationOptions = { limit, offset };\n\n      // Get questions\n      const result = await this.questionService.getQuestions(provider, exam, filter, pagination);\n\n      this.logger.info('Questions fetched successfully', {\n        userId,\n        provider,\n        exam,\n        totalCount: result.totalCount,\n        returnedCount: result.questions.length\n      });\n\n      return this.success(result, 'Questions retrieved successfully');\n\n    } catch (error) {\n      this.logger.error('Failed to fetch questions', { userId, error });\n      return this.internalError('Failed to retrieve questions');\n    }\n  }\n\n  /**\n   * Get a specific question\n   */\n  public async getQuestion(event: APIGatewayProxyEvent, userId: string): Promise<APIGatewayProxyResult> {\n    const questionId = this.getPathParam(event, 'questionId');\n    \n    if (!questionId) {\n      return this.badRequest('Question ID is required');\n    }\n\n    try {\n      const provider = this.getQueryParam(event, 'provider') || 'aws';\n      const exam = this.getQueryParam(event, 'exam') || 'saa-c03';\n\n      const question = await this.questionService.getQuestion(provider, exam, questionId);\n\n      if (!question) {\n        return this.notFound(`Question '${questionId}' not found`);\n      }\n\n      return this.success(question, 'Question retrieved successfully');\n\n    } catch (error) {\n      this.logger.error('Failed to fetch specific question', { userId, questionId, error });\n      return this.internalError('Failed to retrieve question');\n    }\n  }\n\n  /**\n   * Get random questions for practice\n   */\n  public async getRandomQuestions(event: APIGatewayProxyEvent, userId: string): Promise<APIGatewayProxyResult> {\n    try {\n      const provider = this.getQueryParam(event, 'provider') || 'aws';\n      const exam = this.getQueryParam(event, 'exam') || 'saa-c03';\n      const count = parseInt(this.getQueryParam(event, 'count', '20') || '20', 10);\n\n      // Build filters for random selection\n      const filter: QuestionFilter = {};\n      \n      if (this.getQueryParam(event, 'difficulty')) {\n        filter.difficulty = this.getQueryParam(event, 'difficulty') as any;\n      }\n      \n      if (this.getQueryParam(event, 'topics')) {\n        filter.topics = this.getQueryParam(event, 'topics')?.split(',') || [];\n      }\n      \n      if (this.getQueryParam(event, 'hasExplanation')) {\n        filter.hasExplanation = this.getQueryParam(event, 'hasExplanation') === 'true';\n      }\n\n      const questions = await this.questionService.getRandomQuestions(provider, exam, count, filter);\n\n      return this.success({\n        questions,\n        count: questions.length,\n        requested: count\n      }, 'Random questions retrieved successfully');\n\n    } catch (error) {\n      this.logger.error('Failed to fetch random questions', { userId, error });\n      return this.internalError('Failed to retrieve random questions');\n    }\n  }\n\n  /**\n   * Get question statistics\n   */\n  public async getQuestionStats(event: APIGatewayProxyEvent, userId: string): Promise<APIGatewayProxyResult> {\n    try {\n      const provider = this.getQueryParam(event, 'provider') || 'aws';\n      const exam = this.getQueryParam(event, 'exam') || 'saa-c03';\n\n      const stats = await this.questionService.getQuestionStats(provider, exam);\n\n      return this.success(stats, 'Question statistics retrieved successfully');\n\n    } catch (error) {\n      this.logger.error('Failed to fetch question stats', { userId, error });\n      return this.internalError('Failed to retrieve question statistics');\n    }\n  }\n\n  /**\n   * Route handler - determines which method to call\n   */\n  public async handleRequest(event: APIGatewayProxyEvent, userId: string): Promise<APIGatewayProxyResult> {\n    const { httpMethod } = event;\n    const questionId = this.getPathParam(event, 'questionId');\n    const resource = event.resource;\n\n    switch (httpMethod) {\n      case 'GET':\n        if (resource.includes('/random')) {\n          return this.getRandomQuestions(event, userId);\n        } else if (resource.includes('/stats')) {\n          return this.getQuestionStats(event, userId);\n        } else if (questionId) {\n          return this.getQuestion(event, userId);\n        } else {\n          return this.getQuestions(event, userId);\n        }\n      \n      default:\n        return this.methodNotAllowed(`${httpMethod} method not supported`);\n    }\n  }\n\n  private methodNotAllowed(message: string): APIGatewayProxyResult {\n    return {\n      statusCode: 405,\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ error: message })\n    };\n  }\n}\n\nconst questionHandler = new QuestionHandler();\nexport const handler = questionHandler.withAuth(\n  (event: APIGatewayProxyEvent, userId: string) => questionHandler.handleRequest(event, userId)\n);", "import { APIGatewayProxyEvent, APIGatewayProxyResult, APIGatewayTokenAuthorizerEvent, APIGatewayAuthorizerResult } from 'aws-lambda';\n\n// Base Handler Types\nexport type PublicHandler = (event: APIGatewayProxyEvent) => Promise<APIGatewayProxyResult>;\nexport type AuthenticatedHandler = (event: APIGatewayProxyEvent, userId: string) => Promise<APIGatewayProxyResult>;\nexport type AuthorizerHandler = (event: APIGatewayTokenAuthorizerEvent) => Promise<APIGatewayAuthorizerResult>;\n\n// Common API Response Structure\nexport interface ApiResponse<T = any> {\n  success: boolean;\n  data?: T;\n  message?: string;\n  error?: string;\n  timestamp: string;\n  version: string;\n}\n\n// Error Types\nexport enum ErrorCode {\n  UNAUTHORIZED = 'UNAUTHORIZED',\n  FORBIDDEN = 'FORBIDDEN',\n  NOT_FOUND = 'NOT_FOUND',\n  VALIDATION_ERROR = 'VALIDATION_ERROR',\n  INTERNAL_ERROR = 'INTERNAL_ERROR',\n  RATE_LIMITED = 'RATE_LIMITED'\n}\n\nexport class ApiError extends Error {\n  constructor(\n    public code: ErrorCode,\n    message: string,\n    public details?: any\n  ) {\n    super(message);\n    this.name = 'ApiError';\n  }\n}\n\n// User Context\nexport interface UserContext {\n  userId: string;\n  email: string;\n  role?: string;\n  permissions?: string[];\n}\n\n// JWT Token Payload\nexport interface JwtPayload {\n  userId: string;\n  email: string;\n  role?: string;\n  iat: number;\n  exp: number;\n}\n\n// Database Entities\nexport interface User {\n  userId: string;\n  email: string;\n  name?: string;\n  role: string;\n  createdAt: string;\n  updatedAt: string;\n  lastLoginAt?: string;\n  isActive: boolean;\n}\n\n// Auth-related types\nexport interface UserRegistrationRequest {\n  email: string;\n  password: string;\n  name?: string;\n}\n\nexport interface UserLoginRequest {\n  email: string;\n  password: string;\n}\n\nexport interface AuthResponse {\n  user: User;\n  token: string;\n  refreshToken: string;\n  expiresIn: number;\n}\n\nexport interface RefreshTokenRequest {\n  refreshToken: string;\n}\n\n// Enhanced Session Types for comprehensive session management\nexport interface StudySession {\n  sessionId: string;\n  userId: string;\n  provider: string;\n  exam: string;\n  status: 'active' | 'completed' | 'paused' | 'expired';\n  startTime: string;\n  endTime?: string;\n  \n  // Question Management\n  totalQuestions: number;\n  questionsAnswered: number;\n  correctAnswers: number;\n  currentQuestionIndex: number;\n  selectedQuestionIds: string[]; // Pre-selected questions for the session\n  \n  // Session Configuration\n  sessionConfig: SessionConfiguration;\n  \n  // Progress Tracking\n  progress: SessionProgress;\n  \n  // Performance Analytics\n  analytics: SessionAnalytics;\n  \n  // Timestamps and TTL\n  createdAt: string;\n  updatedAt: string;\n  lastActivityAt: string;\n  expiresAt: number; // DynamoDB TTL (Unix timestamp)\n}\n\n// Session configuration options\nexport interface SessionConfiguration {\n  questionCount: number;\n  timeLimit?: number; // in minutes, optional\n  difficulty?: 'easy' | 'medium' | 'hard';\n  topics?: string[];\n  serviceCategories?: string[];\n  awsServices?: string[];\n  questionTypes?: ('single_choice' | 'multiple_choice')[];\n  shuffleQuestions: boolean;\n  immediateResultsFeedback: boolean;\n  allowReview: boolean;\n}\n\n// Detailed progress tracking\nexport interface SessionProgress {\n  percentage: number; // 0-100\n  questionsCorrect: number;\n  questionsIncorrect: number;\n  questionsSkipped: number;\n  averageTimePerQuestion: number; // in seconds\n  timeSpent: number; // total time spent in seconds\n  streakCurrent: number;\n  streakBest: number;\n}\n\n// Session performance analytics\nexport interface SessionAnalytics {\n  difficultyBreakdown: {\n    easy: { correct: number; total: number };\n    medium: { correct: number; total: number };\n    hard: { correct: number; total: number };\n  };\n  topicPerformance: { [topic: string]: { correct: number; total: number } };\n  servicePerformance: { [service: string]: { correct: number; total: number } };\n  questionTypePerformance: {\n    single_choice: { correct: number; total: number };\n    multiple_choice: { correct: number; total: number };\n  };\n  timeAnalytics: {\n    fastestAnswer: number; // in seconds\n    slowestAnswer: number; // in seconds\n    averageAnswerTime: number; // in seconds\n  };\n}\n\n// Answer submission for a question in a session\nexport interface SessionAnswer {\n  questionId: string;\n  questionIndex: number;\n  userAnswer: string | string[];\n  isCorrect: boolean;\n  timeSpent: number; // in seconds\n  submittedAt: string;\n  explanation?: string;\n}\n\n// Session state for current question delivery\nexport interface SessionState {\n  sessionId: string;\n  currentQuestion: Question;\n  questionIndex: number;\n  progress: SessionProgress;\n  timeRemaining?: number; // if timed session\n  canGoBack: boolean;\n  canSkip: boolean;\n}\n\n// Session results when completed\nexport interface SessionResults {\n  sessionId: string;\n  finalScore: number; // percentage\n  questionsCorrect: number;\n  questionsTotal: number;\n  timeSpent: number; // in seconds\n  performance: SessionAnalytics;\n  grade: 'A' | 'B' | 'C' | 'D' | 'F';\n  passed: boolean;\n  recommendations: string[];\n  completedAt: string;\n}\n\nexport interface StudyGoal {\n  goalId: string;\n  userId: string;\n  title: string;\n  description?: string;\n  targetDate: string;\n  status: 'active' | 'completed' | 'paused';\n  progress: number; // 0-100\n  metrics: {\n    questionsTarget: number;\n    questionsCompleted: number;\n    accuracyTarget: number;\n    currentAccuracy: number;\n  };\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport interface AnalyticsEvent {\n  userId: string;\n  eventType: string;\n  eventData: any;\n  timestamp: string;\n  sessionId?: string;\n  provider?: string;\n  exam?: string;\n  expiresAt: number; // TTL\n}\n\nexport interface Provider {\n  id: string;\n  name: string;\n  description: string;\n  exams: Exam[];\n}\n\nexport interface Exam {\n  id: string;\n  name: string;\n  description: string;\n  questionCount: number;\n  duration?: number;\n  passingScore?: number;\n}\n\nexport interface Question {\n  questionId: string;\n  questionNumber: number;\n  provider: string;\n  exam: string;\n  text: string;\n  options: string[][];\n  questionType: 'single_choice' | 'multiple_choice';\n  expectedAnswers: number;\n  correctAnswer: string | string[];\n  explanation?: string;\n  difficulty: 'easy' | 'medium' | 'hard';\n  topics: string[];\n  serviceCategory?: string;\n  awsServices?: string[];\n  keywords?: string[];\n  createdAt: string;\n  parsingConfidence?: number;\n  hasExplanation?: boolean;\n}\n\n// Raw question data from S3 (matches study_data_final.json structure)\nexport interface RawQuestionData {\n  question_number: number;\n  question: {\n    text: string;\n    options: string[][];\n    question_type: 'single_choice' | 'multiple_choice';\n    expected_answers: number;\n    topic: string;\n    service_category?: string;\n    aws_services?: string[];\n  };\n  answer?: {\n    correct_answer: string;\n    explanation?: string;\n    keywords?: string[];\n    parsing_confidence?: number;\n    source?: string;\n  };\n  study_metadata?: {\n    difficulty: 'easy' | 'medium' | 'hard';\n    completeness: string;\n    question_preview: string;\n    has_explanation: boolean;\n    confidence_level: string;\n  };\n}\n\n// Session Request/Response Types\nexport interface CreateSessionRequest {\n  provider: string;\n  exam: string;\n  config?: Partial<SessionConfiguration>;\n}\n\nexport interface UpdateSessionRequest {\n  config?: Partial<SessionConfiguration>;\n  status?: 'paused' | 'active';\n}\n\nexport interface SubmitAnswerRequest {\n  questionId: string;\n  answer: string | string[];\n  timeSpent?: number; // in seconds\n}\n\nexport interface SubmitAnswerResponse {\n  isCorrect: boolean;\n  correctAnswer: string | string[];\n  explanation?: string;\n  nextQuestion?: Question;\n  sessionProgress: SessionProgress;\n  sessionCompleted: boolean;\n}\n\nexport interface GetSessionResponse {\n  session: StudySession;\n  currentState?: SessionState;\n}\n\nexport interface ListSessionsRequest {\n  status?: 'active' | 'completed' | 'paused';\n  provider?: string;\n  exam?: string;\n  limit?: number;\n  lastEvaluatedKey?: string;\n}\n\nexport interface CompleteSessionResponse {\n  results: SessionResults;\n  achievements?: Achievement[];\n}\n\n// Achievement system for gamification\nexport interface Achievement {\n  id: string;\n  name: string;\n  description: string;\n  type: 'accuracy' | 'speed' | 'streak' | 'completion' | 'improvement';\n  criteria: any;\n  earnedAt: string;\n}\n\nexport interface CreateGoalRequest {\n  title: string;\n  description?: string;\n  targetDate: string;\n  questionsTarget: number;\n  accuracyTarget: number;\n}\n\n// ============================================================================\n// AI-POWERED STUDY FEATURES TYPES - Phase 5\n// ============================================================================\n\n// Enhanced Goal Types with AI Features\nexport interface EnhancedStudyGoal extends StudyGoal {\n  aiOptimized: boolean;\n  adaptiveSettings: {\n    difficultyLevel: 'adaptive' | 'fixed';\n    spacedRepetition: boolean;\n    personalizedSchedule: boolean;\n  };\n  milestones: GoalMilestone[];\n  studyPlan: StudyPlanReference;\n  aiRecommendations: AIRecommendation[];\n  learningPath: LearningPathNode[];\n  achievements: GoalAchievement[];\n  analyticsSnapshot: GoalAnalyticsSnapshot;\n}\n\nexport interface GoalMilestone {\n  milestoneId: string;\n  title: string;\n  description?: string;\n  targetDate: string;\n  completed: boolean;\n  completedAt?: string;\n  requirements: MilestoneRequirement[];\n  rewards: string[];\n  aiGenerated: boolean;\n}\n\nexport interface MilestoneRequirement {\n  type: 'accuracy' | 'questions' | 'time' | 'topics' | 'sessions';\n  target: number;\n  current: number;\n  description: string;\n}\n\nexport interface StudyPlanReference {\n  planId: string;\n  generatedAt: string;\n  duration: number; // days\n  adaptiveAdjustments: number;\n  lastOptimized: string;\n}\n\nexport interface AIRecommendation {\n  id: string;\n  type: 'study_schedule' | 'difficulty_adjustment' | 'topic_focus' | 'break_suggestion';\n  priority: 'high' | 'medium' | 'low';\n  title: string;\n  description: string;\n  reasoning: string;\n  actionItems: string[];\n  validUntil: string;\n  applied: boolean;\n  appliedAt?: string;\n  effectiveness?: number; // 0-100, measured after application\n}\n\nexport interface LearningPathNode {\n  nodeId: string;\n  topic: string;\n  estimatedTime: number; // minutes\n  prerequisites: string[];\n  completed: boolean;\n  completedAt?: string;\n  difficultyLevel: number; // 1-5\n  adaptiveWeight: number; // Higher weight = more important\n  nextReviewDate?: string; // For spaced repetition\n}\n\nexport interface GoalAchievement {\n  achievementId: string;\n  name: string;\n  description: string;\n  earnedAt: string;\n  category: 'progress' | 'consistency' | 'improvement' | 'mastery';\n  points: number;\n}\n\nexport interface GoalAnalyticsSnapshot {\n  lastUpdated: string;\n  currentAccuracy: number;\n  weeklyProgress: number;\n  studyVelocity: number; // questions per day\n  difficultyTrend: 'increasing' | 'decreasing' | 'stable';\n  topicMastery: { [topic: string]: number }; // 0-100 mastery score\n  predictedCompletionDate: string;\n  confidenceScore: number; // 0-100\n}\n\n// Spaced Repetition and Adaptive Learning Types\nexport interface SpacedRepetitionItem {\n  itemId: string;\n  userId: string;\n  conceptId: string; // Could be questionId, topicId, or skill\n  conceptType: 'question' | 'topic' | 'skill';\n  \n  // SM-2 Algorithm fields\n  easinessFactor: number; // 1.3 - 2.5, default 2.5\n  interval: number; // Days until next review\n  repetition: number; // Number of successful reviews\n  nextReviewDate: string;\n  \n  // Performance tracking\n  totalAttempts: number;\n  correctAttempts: number;\n  lastAttemptDate: string;\n  averageResponseTime: number; // milliseconds\n  masteryLevel: 'learning' | 'reviewing' | 'mastered';\n  \n  // Difficulty adaptation\n  currentDifficulty: number; // 0-100\n  optimalDifficulty: number; // Target difficulty for user\n  difficultyAdjustments: DifficultyAdjustment[];\n  \n  // Context and metadata\n  provider?: string;\n  exam?: string;\n  topic?: string;\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport interface DifficultyAdjustment {\n  adjustmentDate: string;\n  previousDifficulty: number;\n  newDifficulty: number;\n  reason: string;\n  performanceMetrics: {\n    accuracy: number;\n    responseTime: number;\n    confidence: number;\n  };\n}\n\nexport interface LearningSessionPlan {\n  planId: string;\n  userId: string;\n  sessionType: 'review' | 'learning' | 'mixed' | 'assessment';\n  \n  // Content selection\n  selectedItems: SpacedRepetitionItem[];\n  questionPool: Question[];\n  targetDifficulty: number;\n  adaptiveDifficultyEnabled: boolean;\n  \n  // Session parameters\n  estimatedDuration: number; // minutes\n  targetQuestions: number;\n  difficultyDistribution: {\n    easy: number;\n    medium: number;\n    hard: number;\n  };\n  \n  // Spaced repetition settings\n  reviewPriority: 'overdue' | 'due_today' | 'upcoming' | 'mixed';\n  newContentRatio: number; // 0-1, percentage of new vs review content\n  \n  // AI optimization\n  personalizedOrder: string[]; // Question IDs in optimized order\n  difficultyProgression: number[]; // Difficulty progression through session\n  breakSuggestions: number[]; // Suggested break points (question indices)\n  \n  createdAt: string;\n  validUntil: string;\n}\n\n// AI Recommendation System Types\nexport interface AIStudyRecommendation extends RecommendationItem {\n  confidence: number; // 0-100, confidence in recommendation\n  personalizedData: {\n    userPerformanceFactors: UserPerformanceFactors;\n    adaptiveLearningInsights: AdaptiveLearningInsights;\n    behavioralPatterns: BehavioralPatterns;\n  };\n  dynamicAdjustments: DynamicAdjustment[];\n  successMetrics: SuccessMetric[];\n  followUpActions: FollowUpAction[];\n}\n\nexport interface UserPerformanceFactors {\n  overallAccuracy: number;\n  accuracyTrend: 'improving' | 'stable' | 'declining';\n  strongTopics: string[];\n  weakTopics: string[];\n  averageStudyTime: number; // minutes per day\n  studyConsistency: number; // 0-100\n  difficultyPreference: 'easy' | 'medium' | 'hard' | 'adaptive';\n  learningVelocity: number; // questions mastered per week\n}\n\nexport interface AdaptiveLearningInsights {\n  spacedRepetitionEffectiveness: number; // 0-100\n  optimalReviewInterval: number; // hours\n  difficultyAdaptationSuccess: number; // 0-100\n  masteredConcepts: number;\n  strugglingConcepts: number;\n  overdueReviews: number;\n  predictedPerformanceGain: number; // Expected improvement with recommendation\n}\n\nexport interface BehavioralPatterns {\n  preferredStudyTimes: string[]; // e.g., ['morning', 'evening']\n  averageSessionLength: number; // minutes\n  studyFrequency: number; // sessions per week\n  breakPreferences: BreakPreference;\n  motivationFactors: MotivationFactor[];\n  procrastinationRisk: 'low' | 'medium' | 'high';\n  studyConsistency: number; // 0-100, consistency score\n}\n\nexport interface BreakPreference {\n  frequency: number; // minutes between breaks\n  duration: number; // break duration in minutes\n  type: 'short' | 'medium' | 'long';\n}\n\nexport interface MotivationFactor {\n  factor: 'achievements' | 'progress' | 'competition' | 'learning' | 'goals';\n  weight: number; // 0-1, importance to user\n  effectiveness: number; // 0-100, how well it works for user\n}\n\nexport interface DynamicAdjustment {\n  parameter: string;\n  originalValue: any;\n  adjustedValue: any;\n  reason: string;\n  expectedImpact: number; // 0-100\n}\n\nexport interface SuccessMetric {\n  metric: string;\n  currentValue: number;\n  targetValue: number;\n  timeframe: string; // e.g., '1 week', '1 month'\n  probability: number; // 0-100, probability of achieving target\n}\n\nexport interface FollowUpAction {\n  action: string;\n  timing: string; // when to perform action\n  condition: string; // condition that triggers action\n  priority: 'high' | 'medium' | 'low';\n}\n\n// Enhanced Study Plan Types\nexport interface AIStudyPlan extends StudyPlan {\n  aiOptimizations: {\n    personalizedScheduling: boolean;\n    adaptiveDifficulty: boolean;\n    spacedRepetitionIntegration: boolean;\n    behaviorBasedAdjustments: boolean;\n  };\n  performancePredictions: {\n    expectedAccuracyImprovement: number;\n    estimatedCompletionDate: string;\n    confidenceLevel: number;\n  };\n  contingencyPlans: ContingencyPlan[];\n  motivationalElements: MotivationalElement[];\n}\n\nexport interface ContingencyPlan {\n  trigger: string; // What triggers this plan\n  adjustments: string[]; // What adjustments to make\n  timeline: string; // How long to try adjustments\n}\n\nexport interface MotivationalElement {\n  type: 'achievement' | 'progress_visualization' | 'competition' | 'reward';\n  description: string;\n  triggerConditions: string[];\n  impact: 'high' | 'medium' | 'low';\n}\n\n// Performance Prediction and Analytics\nexport interface PerformancePrediction {\n  userId: string;\n  conceptId: string;\n  \n  // Predictions\n  predictedAccuracy: number; // 0-100\n  predictedResponseTime: number; // milliseconds\n  confidenceScore: number; // 0-100, confidence in predictions\n  \n  // Model factors\n  factors: {\n    historicalPerformance: number; // Weight: 40%\n    timeSinceLastPractice: number; // Weight: 20%\n    conceptDifficulty: number; // Weight: 15%\n    userSkillLevel: number; // Weight: 15%\n    contextualFactors: number; // Weight: 10%\n  };\n  \n  // Recommendations\n  recommendedAction: 'practice' | 'review' | 'skip' | 'intensive_study';\n  optimalTimingHours: number; // Optimal time until next practice\n  \n  calculatedAt: string;\n}\n\n// Recommendation Feedback System\nexport interface RecommendationFeedback {\n  recommendationId: string;\n  userId: string;\n  feedbackType: 'helpful' | 'not_helpful' | 'partially_helpful' | 'irrelevant';\n  effectiveness: number; // 0-100, how effective was the recommendation\n  appliedSuggestions: string[];\n  ignoredSuggestions: string[];\n  userComments?: string;\n  performanceChange: {\n    beforeAccuracy: number;\n    afterAccuracy: number;\n    beforeStudyTime: number;\n    afterStudyTime: number;\n    timeframe: string;\n  };\n  submittedAt: string;\n}\n\n// Achievement System for Gamification\nexport interface AchievementDefinition {\n  id: string;\n  name: string;\n  description: string;\n  type: 'accuracy' | 'speed' | 'streak' | 'completion' | 'improvement' | 'consistency';\n  criteria: AchievementCriteria;\n  points: number;\n  badge?: string;\n  rarity: 'common' | 'uncommon' | 'rare' | 'epic' | 'legendary';\n}\n\nexport interface AchievementCriteria {\n  metric: string;\n  threshold: number;\n  timeframe?: string;\n  conditions?: { [key: string]: any };\n}\n\nexport interface UserAchievementProgress {\n  userId: string;\n  achievementId: string;\n  currentProgress: number;\n  targetProgress: number;\n  progressPercentage: number;\n  isCompleted: boolean;\n  completedAt?: string;\n  lastUpdated: string;\n}\n\n// Study Session Enhancement Types\nexport interface EnhancedStudySession extends StudySession {\n  aiEnhancements: {\n    adaptiveDifficultyEnabled: boolean;\n    spacedRepetitionIntegrated: boolean;\n    personalizedOrdering: boolean;\n    realTimeAdjustments: boolean;\n  };\n  learningMetrics: {\n    conceptsMastered: string[];\n    conceptsReviewed: string[];\n    difficultyAdjustments: DifficultyAdjustment[];\n    optimalBreakPoints: number[];\n    retentionPrediction: number; // 0-100\n  };\n  aiRecommendations: {\n    nextSessionType: 'review' | 'learning' | 'mixed' | 'assessment';\n    optimalTimingHours: number;\n    suggestedTopics: string[];\n    difficultyRecommendation: 'increase' | 'decrease' | 'maintain';\n  };\n}\n\n// API Request/Response Types for AI Features\nexport interface GenerateRecommendationsRequest {\n  includeStudyPlan?: boolean;\n  planDuration?: number; // days\n  focusAreas?: string[];\n  urgency?: 'low' | 'medium' | 'high';\n  timeAvailable?: number; // minutes per day\n}\n\nexport interface GenerateRecommendationsResponse {\n  recommendations: AIStudyRecommendation[];\n  studyPlan?: AIStudyPlan;\n  lastUpdated: string;\n  metadata: {\n    totalRecommendations: number;\n    highPriorityCount: number;\n    averageConfidence: number;\n    planIncluded: boolean;\n  };\n}\n\nexport interface SessionRecommendationsRequest {\n  availableTime: number; // minutes\n  preferredDifficulty?: 'easy' | 'medium' | 'hard' | 'adaptive';\n  focusTopics?: string[];\n  sessionType?: 'review' | 'learning' | 'mixed' | 'assessment';\n}\n\nexport interface SessionRecommendationsResponse {\n  sessionPlan: LearningSessionPlan;\n  recommendations: AIStudyRecommendation[];\n  sessionInfo: {\n    estimatedDuration: number;\n    targetQuestions: number;\n    sessionType: string;\n    difficultyDistribution: { easy: number; medium: number; hard: number };\n    breakSuggestions: number[];\n    personalizedOrder: boolean;\n  };\n}\n\n// Learning Analytics Enhancement\nexport interface LearningAnalytics extends UserProgressAnalytics {\n  aiInsights: {\n    learningEfficiency: number; // 0-100\n    retentionRate: number; // 0-100\n    optimalStudyPattern: string;\n    predictedPerformance: PerformancePrediction[];\n    recommendedAdjustments: string[];\n  };\n  adaptiveLearningStats: {\n    spacedRepetitionItems: number;\n    masteryProgression: { [concept: string]: number };\n    difficultyAdaptationSuccess: number;\n    overallLearningVelocity: number;\n  };\n}\n\nexport interface GetQuestionsRequest {\n  provider: string;\n  exam: string;\n  limit?: number;\n  offset?: number;\n  difficulty?: 'easy' | 'medium' | 'hard';\n  topics?: string[];\n  serviceCategory?: string;\n  awsServices?: string[];\n  search?: string;\n  hasExplanation?: boolean;\n  questionType?: 'single_choice' | 'multiple_choice';\n}\n\nexport interface QuestionFilter {\n  difficulty?: 'easy' | 'medium' | 'hard';\n  topics?: string[];\n  serviceCategory?: string;\n  awsServices?: string[];\n  search?: string;\n  hasExplanation?: boolean;\n  questionType?: 'single_choice' | 'multiple_choice';\n}\n\nexport interface PaginationOptions {\n  limit: number;\n  offset: number;\n}\n\nexport interface QuestionSearchResult {\n  questions: Question[];\n  totalCount: number;\n  hasMore: boolean;\n  filters: {\n    availableTopics: string[];\n    availableServiceCategories: string[];\n    availableAwsServices: string[];\n    difficultyDistribution: { [key: string]: number };\n  };\n}\n\n// ============================================================================\n// ANALYTICS TYPES - Phase 4: Analytics & Progress Tracking\n// ============================================================================\n\n// User Progress Analytics\nexport interface UserProgressAnalytics {\n  userId: string;\n  overallStats: OverallProgressStats;\n  providerStats: ProviderProgressStats[];\n  examStats: ExamProgressStats[];\n  recentActivity: RecentActivityStats;\n  achievements: Achievement[];\n  calculatedAt: string;\n}\n\nexport interface OverallProgressStats {\n  totalSessions: number;\n  completedSessions: number;\n  totalQuestions: number;\n  correctAnswers: number;\n  overallAccuracy: number;\n  totalStudyTime: number; // in seconds\n  averageSessionScore: number;\n  bestSessionScore: number;\n  currentStreak: number;\n  longestStreak: number;\n  lastActivityDate: string;\n  studyDaysCount: number;\n}\n\nexport interface ProviderProgressStats {\n  provider: string;\n  totalSessions: number;\n  completedSessions: number;\n  totalQuestions: number;\n  correctAnswers: number;\n  accuracy: number;\n  studyTime: number;\n  averageScore: number;\n  bestScore: number;\n  lastSessionDate?: string;\n  exams: ExamProgressStats[];\n}\n\nexport interface ExamProgressStats {\n  provider: string;\n  exam: string;\n  totalSessions: number;\n  completedSessions: number;\n  totalQuestions: number;\n  correctAnswers: number;\n  accuracy: number;\n  studyTime: number;\n  averageScore: number;\n  bestScore: number;\n  lastSessionDate?: string;\n  readinessScore: number; // 0-100, calculated readiness for this exam\n  topicMastery: TopicMasteryStats[];\n}\n\nexport interface TopicMasteryStats {\n  topic: string;\n  questionsAnswered: number;\n  correctAnswers: number;\n  accuracy: number;\n  masteryLevel: 'beginner' | 'intermediate' | 'advanced' | 'expert';\n  confidenceScore: number; // 0-100\n  lastPracticed?: string;\n  improvementTrend: 'improving' | 'stable' | 'declining';\n}\n\nexport interface RecentActivityStats {\n  last7Days: DailyActivityStats[];\n  last30Days: DailyActivityStats[];\n  currentWeekStats: WeeklyActivityStats;\n  currentMonthStats: MonthlyActivityStats;\n}\n\nexport interface DailyActivityStats {\n  date: string; // YYYY-MM-DD\n  sessionsCount: number;\n  questionsAnswered: number;\n  correctAnswers: number;\n  studyTimeMinutes: number;\n  accuracy: number;\n}\n\nexport interface WeeklyActivityStats {\n  weekStartDate: string;\n  totalSessions: number;\n  totalQuestions: number;\n  totalCorrect: number;\n  totalStudyTime: number;\n  averageAccuracy: number;\n  studyDays: number;\n}\n\nexport interface MonthlyActivityStats {\n  month: string; // YYYY-MM\n  totalSessions: number;\n  totalQuestions: number;\n  totalCorrect: number;\n  totalStudyTime: number;\n  averageAccuracy: number;\n  studyDays: number;\n}\n\n// Performance Metrics and Trends\nexport interface PerformanceMetrics {\n  userId: string;\n  timeRange: 'week' | 'month' | 'quarter' | 'year' | 'all';\n  trends: PerformanceTrends;\n  comparisons: PerformanceComparisons;\n  insights: PerformanceInsights;\n  calculatedAt: string;\n}\n\nexport interface PerformanceTrends {\n  accuracyTrend: TrendData[];\n  speedTrend: TrendData[];\n  studyTimeTrend: TrendData[];\n  sessionCompletionTrend: TrendData[];\n  difficultyProgressionTrend: DifficultyTrendData[];\n}\n\nexport interface TrendData {\n  date: string;\n  value: number;\n  change?: number; // percentage change from previous period\n}\n\nexport interface DifficultyTrendData {\n  date: string;\n  easy: { accuracy: number; count: number };\n  medium: { accuracy: number; count: number };\n  hard: { accuracy: number; count: number };\n}\n\nexport interface PerformanceComparisons {\n  vsLastPeriod: ComparisonData;\n  vsPersonalBest: ComparisonData;\n  vsAverageUser: ComparisonData; // if available\n}\n\nexport interface ComparisonData {\n  accuracy: { current: number; comparison: number; change: number };\n  speed: { current: number; comparison: number; change: number };\n  studyTime: { current: number; comparison: number; change: number };\n  completion: { current: number; comparison: number; change: number };\n}\n\nexport interface PerformanceInsights {\n  strengths: string[];\n  weaknesses: string[];\n  recommendations: string[];\n  milestoneProgress: MilestoneProgress[];\n}\n\nexport interface MilestoneProgress {\n  milestone: string;\n  description: string;\n  progress: number; // 0-100\n  target: number;\n  current: number;\n  estimatedCompletion?: string;\n}\n\n// Session Analytics and History\nexport interface SessionAnalyticsData {\n  userId: string;\n  sessions: SessionSummary[];\n  aggregatedStats: SessionAggregatedStats;\n  patterns: SessionPatterns;\n  calculatedAt: string;\n}\n\nexport interface SessionSummary {\n  sessionId: string;\n  provider: string;\n  exam: string;\n  startTime: string;\n  endTime?: string;\n  duration: number; // in seconds\n  status: 'active' | 'completed' | 'paused' | 'expired';\n  score: number;\n  questionsTotal: number;\n  questionsCorrect: number;\n  accuracy: number;\n  averageTimePerQuestion: number;\n  difficultyBreakdown: {\n    easy: { correct: number; total: number };\n    medium: { correct: number; total: number };\n    hard: { correct: number; total: number };\n  };\n}\n\nexport interface SessionAggregatedStats {\n  totalSessions: number;\n  completedSessions: number;\n  averageScore: number;\n  averageDuration: number;\n  averageAccuracy: number;\n  bestPerformance: SessionSummary;\n  recentPerformance: SessionSummary[];\n}\n\nexport interface SessionPatterns {\n  preferredStudyTimes: TimeOfDayPattern[];\n  sessionLengthDistribution: SessionLengthPattern;\n  accuracyByTimeOfDay: TimeOfDayAccuracy[];\n  studyStreak: StreakData;\n}\n\nexport interface TimeOfDayPattern {\n  hour: number;\n  sessionCount: number;\n  averageAccuracy: number;\n}\n\nexport interface SessionLengthPattern {\n  short: number; // < 15 minutes\n  medium: number; // 15-60 minutes\n  long: number; // > 60 minutes\n}\n\nexport interface TimeOfDayAccuracy {\n  timeRange: string; // e.g., \"09:00-12:00\"\n  averageAccuracy: number;\n  sessionCount: number;\n}\n\nexport interface StreakData {\n  currentStreak: number;\n  longestStreak: number;\n  streakDates: string[];\n}\n\n// Cross-Provider Comparison Analytics\nexport interface CrossProviderAnalytics {\n  userId: string;\n  providerComparisons: ProviderComparison[];\n  skillTransferability: SkillTransferAnalysis[];\n  recommendations: CrossProviderRecommendations;\n  calculatedAt: string;\n}\n\nexport interface ProviderComparison {\n  provider: string;\n  totalQuestions: number;\n  accuracy: number;\n  averageScore: number;\n  studyTime: number;\n  completionRate: number;\n  strengthAreas: string[];\n  weaknessAreas: string[];\n  relativePerformance: number; // compared to user's average across all providers\n}\n\nexport interface SkillTransferAnalysis {\n  sharedTopic: string;\n  providers: string[];\n  consistencyScore: number; // 0-100, how consistent performance is across providers\n  averageAccuracy: number;\n  recommendations: string[];\n}\n\nexport interface CrossProviderRecommendations {\n  suggestedFocusProvider: string;\n  reasonForSuggestion: string;\n  skillGapAreas: string[];\n  strengthLeverageOpportunities: string[];\n}\n\n// Predictive Analytics for Exam Readiness\nexport interface ExamReadinessAssessment {\n  userId: string;\n  provider: string;\n  exam: string;\n  readinessScore: number; // 0-100\n  confidence: 'low' | 'medium' | 'high';\n  prediction: ReadinessPrediction;\n  factors: ReadinessFactors;\n  timeline: ReadinessTimeline;\n  calculatedAt: string;\n}\n\nexport interface ReadinessPrediction {\n  passLikelihood: number; // 0-100\n  recommendedWaitTime: number; // days before attempting real exam\n  minimumStudyHours: number;\n  targetAccuracy: number;\n}\n\nexport interface ReadinessFactors {\n  currentAccuracy: { value: number; weight: number; impact: 'positive' | 'negative' | 'neutral' };\n  topicCoverage: { value: number; weight: number; impact: 'positive' | 'negative' | 'neutral' };\n  consistencyScore: { value: number; weight: number; impact: 'positive' | 'negative' | 'neutral' };\n  recentPerformance: { value: number; weight: number; impact: 'positive' | 'negative' | 'neutral' };\n  studyVolume: { value: number; weight: number; impact: 'positive' | 'negative' | 'neutral' };\n  timeSpent: { value: number; weight: number; impact: 'positive' | 'negative' | 'neutral' };\n}\n\nexport interface ReadinessTimeline {\n  currentLevel: ReadinessLevel;\n  milestones: ReadinessMilestone[];\n  projectedReadyDate: string;\n}\n\nexport interface ReadinessLevel {\n  level: 'beginner' | 'intermediate' | 'advanced' | 'ready';\n  description: string;\n  requirements: string[];\n}\n\nexport interface ReadinessMilestone {\n  milestone: string;\n  description: string;\n  targetDate: string;\n  completed: boolean;\n  requirements: string[];\n}\n\n// Study Recommendations System\nexport interface StudyRecommendations {\n  userId: string;\n  recommendations: RecommendationItem[];\n  priorityActions: PriorityAction[];\n  studyPlan: StudyPlan;\n  calculatedAt: string;\n}\n\nexport interface RecommendationItem {\n  id: string;\n  type: 'topic_focus' | 'difficulty_adjustment' | 'study_pattern' | 'exam_preparation' | 'skill_development';\n  priority: 'high' | 'medium' | 'low';\n  title: string;\n  description: string;\n  reasoning: string;\n  actionItems: string[];\n  estimatedImpact: number; // 0-100\n  estimatedTimeInvestment: number; // in hours\n  applicableProviders: string[];\n  applicableExams: string[];\n}\n\nexport interface PriorityAction {\n  action: string;\n  description: string;\n  timeframe: string;\n  expectedOutcome: string;\n}\n\nexport interface StudyPlan {\n  planId: string;\n  duration: number; // in days\n  dailyTargets: DailyStudyTarget[];\n  weeklyGoals: WeeklyStudyGoal[];\n  milestones: StudyMilestone[];\n}\n\nexport interface DailyStudyTarget {\n  date: string;\n  targetQuestions: number;\n  targetAccuracy: number;\n  recommendedTopics: string[];\n  estimatedTime: number; // in minutes\n}\n\nexport interface WeeklyStudyGoal {\n  weekStartDate: string;\n  focusAreas: string[];\n  targetSessions: number;\n  targetQuestions: number;\n  targetAccuracy: number;\n}\n\nexport interface StudyMilestone {\n  milestone: string;\n  targetDate: string;\n  criteria: MilestoneCriteria;\n  rewards: string[];\n}\n\nexport interface MilestoneCriteria {\n  minimumSessions: number;\n  minimumAccuracy: number;\n  requiredTopics: string[];\n  requiredQuestions: number;\n}\n\n// Analytics API Request/Response Types\nexport interface GetProgressAnalyticsRequest {\n  timeRange?: 'week' | 'month' | 'quarter' | 'year' | 'all';\n  includeProviders?: string[];\n  includeExams?: string[];\n}\n\nexport interface GetPerformanceMetricsRequest {\n  timeRange: 'week' | 'month' | 'quarter' | 'year' | 'all';\n  includeComparisons?: boolean;\n  includeTrends?: boolean;\n}\n\nexport interface GetSessionAnalyticsRequest {\n  timeRange?: 'week' | 'month' | 'quarter' | 'year' | 'all';\n  provider?: string;\n  exam?: string;\n  status?: 'active' | 'completed' | 'paused';\n  limit?: number;\n  lastEvaluatedKey?: string;\n}\n\nexport interface GetTopicAnalyticsRequest {\n  provider?: string;\n  exam?: string;\n  topics?: string[];\n  timeRange?: 'week' | 'month' | 'quarter' | 'year' | 'all';\n}\n\nexport interface GetReadinessAssessmentRequest {\n  provider: string;\n  exam: string;\n  includeTimeline?: boolean;\n  includeDetailedFactors?: boolean;\n}\n\nexport interface GetRecommendationsRequest {\n  includeStudyPlan?: boolean;\n  planDuration?: number; // in days\n  focusAreas?: string[];\n}\n\nexport interface GetComparisonAnalyticsRequest {\n  providers?: string[];\n  includeSkillTransfer?: boolean;\n  includeRecommendations?: boolean;\n}\n\n// Analytics Storage Types for DynamoDB\nexport interface AnalyticsRecord {\n  PK: string; // Partition Key: userId\n  SK: string; // Sort Key: analyticsType#provider#exam#date\n  userId: string;\n  analyticsType: 'progress' | 'performance' | 'session' | 'topic' | 'readiness' | 'recommendation';\n  provider?: string;\n  exam?: string;\n  data: any;\n  calculatedAt: string;\n  expiresAt: number; // TTL\n}\n\nexport interface AnalyticsAggregation {\n  PK: string; // Partition Key: userId#provider#exam\n  SK: string; // Sort Key: aggregationType#date\n  aggregationType: 'daily' | 'weekly' | 'monthly' | 'quarterly' | 'yearly';\n  date: string;\n  data: {\n    sessions: number;\n    questions: number;\n    correct: number;\n    studyTime: number;\n    averageAccuracy: number;\n  };\n  expiresAt: number; // TTL\n}\n\n// ============================================================================\n// HEALTH & MONITORING TYPES - Phase 6: System Health & Monitoring\n// ============================================================================\n\n// System Health Types\nexport interface SystemHealthCheck {\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  timestamp: string;\n  environment: EnvironmentInfo;\n  dependencies: DependencyHealth;\n  performance: HealthPerformanceMetrics;\n  dataQuality: DataQualityStatus;\n  alerts: HealthAlert[];\n  recommendations: string[];\n}\n\nexport interface EnvironmentInfo {\n  stage: string;\n  version: string;\n  region: string;\n  functionName: string;\n  memorySize: string;\n  logLevel: string;\n  uptime: number; // in seconds\n  coldStart: boolean;\n}\n\nexport interface DependencyHealth {\n  dynamodb: DatabaseHealthStatus;\n  s3: S3HealthStatus;\n  external: ExternalServiceHealthStatus[];\n  overall: 'healthy' | 'degraded' | 'unhealthy';\n}\n\nexport interface DatabaseHealthStatus {\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  tables: TableHealthStatus[];\n  connectivity: {\n    canConnect: boolean;\n    responseTime: number; // in milliseconds\n    lastChecked: string;\n  };\n  performance: {\n    readLatency: number;\n    writeLatency: number;\n    throughputUtilization: number; // percentage\n    errorRate: number; // percentage\n  };\n  capacity: {\n    consumedReadCapacity: number;\n    consumedWriteCapacity: number;\n    provisionedReadCapacity: number;\n    provisionedWriteCapacity: number;\n    utilizationPercentage: number;\n  };\n}\n\nexport interface TableHealthStatus {\n  tableName: string;\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  itemCount?: number;\n  sizeBytes?: number;\n  readCapacityUtilization: number;\n  writeCapacityUtilization: number;\n  gsiStatus?: GSIHealthStatus[];\n  errors: string[];\n}\n\nexport interface GSIHealthStatus {\n  indexName: string;\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  readCapacityUtilization: number;\n  writeCapacityUtilization: number;\n}\n\nexport interface S3HealthStatus {\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  buckets: S3BucketHealthStatus[];\n  connectivity: {\n    canConnect: boolean;\n    responseTime: number;\n    lastChecked: string;\n  };\n  performance: {\n    uploadLatency: number;\n    downloadLatency: number;\n    errorRate: number;\n  };\n}\n\nexport interface S3BucketHealthStatus {\n  bucketName: string;\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  accessible: boolean;\n  objectCount?: number;\n  sizeBytes?: number;\n  errors: string[];\n}\n\nexport interface ExternalServiceHealthStatus {\n  serviceName: string;\n  url: string;\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  responseTime: number;\n  statusCode?: number;\n  lastChecked: string;\n  uptime: number; // percentage over last 24 hours\n  errors: string[];\n}\n\n// Performance Monitoring Types for Health System\nexport interface HealthPerformanceMetrics {\n  memory: MemoryMetrics;\n  execution: ExecutionMetrics;\n  throughput: ThroughputMetrics;\n  errors: ErrorMetrics;\n  trends: HealthPerformanceTrends;\n}\n\nexport interface MemoryMetrics {\n  current: number; // MB\n  peak: number; // MB\n  limit: number; // MB\n  utilizationPercentage: number;\n  gcFrequency: number; // garbage collections per minute\n}\n\nexport interface ExecutionMetrics {\n  coldStartFrequency: number; // percentage of executions\n  averageExecutionTime: number; // milliseconds\n  p95ExecutionTime: number; // milliseconds\n  p99ExecutionTime: number; // milliseconds\n  timeouts: number; // count over last hour\n}\n\nexport interface ThroughputMetrics {\n  requestsPerSecond: number;\n  requestsPerMinute: number;\n  requestsPerHour: number;\n  peakThroughput: number;\n  averageResponseTime: number; // milliseconds\n}\n\nexport interface ErrorMetrics {\n  errorRate: number; // percentage over last hour\n  errorCount: number; // count over last hour\n  errorsByType: { [errorType: string]: number };\n  criticalErrors: number;\n  warnings: number;\n}\n\nexport interface HealthPerformanceTrends {\n  responseTimeTrend: 'improving' | 'stable' | 'degrading';\n  errorRateTrend: 'improving' | 'stable' | 'degrading';\n  throughputTrend: 'increasing' | 'stable' | 'decreasing';\n  memoryUsageTrend: 'improving' | 'stable' | 'degrading';\n}\n\n// Data Quality Types\nexport interface DataQualityStatus {\n  overall: 'excellent' | 'good' | 'fair' | 'poor';\n  checks: DataQualityCheck[];\n  lastAssessment: string;\n  trends: DataQualityTrends;\n}\n\nexport interface DataQualityCheck {\n  checkName: string;\n  table: string;\n  status: 'passed' | 'warning' | 'failed';\n  result: {\n    expected: number | string;\n    actual: number | string;\n    threshold?: number;\n  };\n  lastChecked: string;\n  impact: 'low' | 'medium' | 'high' | 'critical';\n  description: string;\n}\n\nexport interface DataQualityTrends {\n  dataConsistency: 'improving' | 'stable' | 'degrading';\n  dataCompleteness: 'improving' | 'stable' | 'degrading';\n  dataAccuracy: 'improving' | 'stable' | 'degrading';\n  dataDuplication: 'improving' | 'stable' | 'degrading';\n}\n\n// Health Alert Types\nexport interface HealthAlert {\n  alertId: string;\n  severity: 'info' | 'warning' | 'error' | 'critical';\n  category: 'performance' | 'availability' | 'data_quality' | 'security' | 'capacity';\n  title: string;\n  description: string;\n  source: string; // service or component that generated the alert\n  threshold?: {\n    metric: string;\n    value: number;\n    comparison: 'greater_than' | 'less_than' | 'equals';\n  };\n  currentValue: number | string;\n  impact: string;\n  recommendations: string[];\n  createdAt: string;\n  resolvedAt?: string;\n  acknowledged: boolean;\n  acknowledgedBy?: string;\n  tags: string[];\n}\n\nexport interface AlertThreshold {\n  metric: string;\n  warningThreshold: number;\n  errorThreshold: number;\n  criticalThreshold: number;\n  comparison: 'greater_than' | 'less_than';\n  enabled: boolean;\n}\n\n// Health History and Reporting Types\nexport interface HealthHistoryEntry {\n  timestamp: string;\n  overallStatus: 'healthy' | 'degraded' | 'unhealthy';\n  componentStatuses: { [component: string]: 'healthy' | 'degraded' | 'unhealthy' };\n  metrics: {\n    responseTime: number;\n    errorRate: number;\n    throughput: number;\n    memoryUsage: number;\n  };\n  alerts: number; // count of active alerts\n  incidents: number; // count of active incidents\n}\n\nexport interface HealthReport {\n  reportId: string;\n  generatedAt: string;\n  timeRange: {\n    start: string;\n    end: string;\n    duration: string; // e.g., '24h', '7d', '30d'\n  };\n  summary: {\n    overallHealth: 'excellent' | 'good' | 'fair' | 'poor';\n    uptimePercentage: number;\n    totalIncidents: number;\n    resolvedIncidents: number;\n    averageResponseTime: number;\n    errorRate: number;\n  };\n  trends: {\n    availabilityTrend: 'improving' | 'stable' | 'degrading';\n    performanceTrend: 'improving' | 'stable' | 'degrading';\n    errorTrend: 'improving' | 'stable' | 'degrading';\n    dataQualityTrend: 'improving' | 'stable' | 'degrading';\n  };\n  topIssues: HealthAlert[];\n  recommendations: SystemRecommendation[];\n  history: HealthHistoryEntry[];\n}\n\nexport interface SystemRecommendation {\n  id: string;\n  priority: 'high' | 'medium' | 'low';\n  category: 'performance' | 'reliability' | 'cost' | 'security';\n  title: string;\n  description: string;\n  reasoning: string;\n  actionItems: string[];\n  estimatedImpact: {\n    performance: number; // percentage improvement\n    cost: number; // dollar savings or cost\n    reliability: number; // uptime improvement percentage\n  };\n  effort: 'low' | 'medium' | 'high';\n  timeline: string;\n}\n\n// Health Check Configuration Types\nexport interface HealthCheckConfig {\n  enabled: boolean;\n  interval: number; // seconds between checks\n  timeout: number; // seconds before timeout\n  retries: number;\n  dependencies: {\n    dynamodb: {\n      enabled: boolean;\n      tables: string[];\n      performanceChecks: boolean;\n    };\n    s3: {\n      enabled: boolean;\n      buckets: string[];\n      performanceChecks: boolean;\n    };\n    external: {\n      enabled: boolean;\n      services: ExternalServiceConfig[];\n    };\n  };\n  dataQuality: {\n    enabled: boolean;\n    checks: DataQualityCheckConfig[];\n  };\n  alerts: {\n    enabled: boolean;\n    thresholds: AlertThreshold[];\n  };\n}\n\nexport interface ExternalServiceConfig {\n  name: string;\n  url: string;\n  method: 'GET' | 'POST' | 'HEAD';\n  headers?: { [key: string]: string };\n  timeout: number;\n  expectedStatusCode: number;\n}\n\nexport interface DataQualityCheckConfig {\n  name: string;\n  table: string;\n  checkType: 'count' | 'consistency' | 'completeness' | 'accuracy' | 'duplication';\n  query: string; // DynamoDB query or expression\n  expectedValue?: number | string;\n  threshold?: number;\n  critical: boolean;\n}\n\n// Health API Request/Response Types\nexport interface GetHealthRequest {\n  includeDetails?: boolean;\n  includeHistory?: boolean;\n  components?: string[];\n}\n\nexport interface GetHealthResponse {\n  health: SystemHealthCheck;\n  history?: HealthHistoryEntry[];\n  uptime: {\n    current: number; // percentage\n    last24h: number;\n    last7d: number;\n    last30d: number;\n  };\n}\n\nexport interface GetHealthPerformanceMetricsRequest {\n  timeRange?: 'hour' | 'day' | 'week' | 'month';\n  metrics?: string[];\n  includeHistorical?: boolean;\n}\n\nexport interface GetHealthPerformanceMetricsResponse {\n  current: HealthPerformanceMetrics;\n  historical?: { [timestamp: string]: HealthPerformanceMetrics };\n  trends: HealthPerformanceTrends;\n}\n\nexport interface GetAlertsRequest {\n  severity?: 'info' | 'warning' | 'error' | 'critical';\n  category?: 'performance' | 'availability' | 'data_quality' | 'security' | 'capacity';\n  status?: 'active' | 'resolved' | 'acknowledged';\n  limit?: number;\n}\n\nexport interface GetAlertsResponse {\n  alerts: HealthAlert[];\n  summary: {\n    total: number;\n    active: number;\n    resolved: number;\n    acknowledged: number;\n    bySeverity: { [severity: string]: number };\n    byCategory: { [category: string]: number };\n  };\n}\n\nexport interface GetHealthHistoryRequest {\n  timeRange: 'hour' | 'day' | 'week' | 'month';\n  resolution?: 'minute' | 'hour' | 'day';\n  components?: string[];\n}\n\nexport interface GetHealthHistoryResponse {\n  entries: HealthHistoryEntry[];\n  summary: {\n    totalDataPoints: number;\n    averageHealth: number; // 0-100 score\n    incidents: number;\n    majorOutages: number;\n  };\n}\n\nexport interface GenerateHealthReportRequest {\n  timeRange: {\n    start: string;\n    end: string;\n  };\n  includeRecommendations?: boolean;\n  format?: 'json' | 'summary';\n}\n\nexport interface GenerateHealthReportResponse {\n  report: HealthReport;\n  downloadUrl?: string; // if format is not json\n}", "import { APIGatewayProxyResult } from 'aws-lambda';\nimport { ApiResponse, ErrorCode } from '../types';\n\n/**\n * Enhanced Response Builder - V2\n * Provides consistent API responses with proper CORS headers\n */\nexport class ResponseBuilder {\n  private static readonly VERSION = '2.0.0';\n\n  private static readonly CORS_HEADERS = {\n    'Content-Type': 'application/json',\n    'Access-Control-Allow-Origin': '*', // Configure specific origins in production\n    'Access-Control-Allow-Headers': 'Content-Type,Authorization,X-Amz-Date,X-Api-Key,X-Amz-Security-Token,X-Amz-User-Agent,X-Auth-Token',\n    'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS,HEAD',\n    'Access-Control-Allow-Credentials': 'true',\n    'Cache-Control': 'no-cache, no-store, must-revalidate',\n    'Pragma': 'no-cache',\n    'Expires': '0'\n  };\n\n  /**\n   * Create successful response\n   */\n  public static success<T>(\n    data: T, \n    statusCode: number = 200,\n    message?: string\n  ): APIGatewayProxyResult {\n    const response: ApiResponse<T> = {\n      success: true,\n      data,\n      message,\n      timestamp: new Date().toISOString(),\n      version: this.VERSION\n    };\n\n    return {\n      statusCode,\n      headers: this.CORS_HEADERS,\n      body: JSON.stringify(response)\n    };\n  }\n\n  /**\n   * Create error response\n   */\n  public static error(\n    message: string,\n    code: ErrorCode = ErrorCode.INTERNAL_ERROR,\n    details?: any,\n    statusCode: number = 500\n  ): APIGatewayProxyResult {\n    const response: ApiResponse = {\n      success: false,\n      error: message,\n      message: `[${code}] ${message}`,\n      timestamp: new Date().toISOString(),\n      version: this.VERSION,\n      ...(details && { data: details })\n    };\n\n    return {\n      statusCode,\n      headers: this.CORS_HEADERS,\n      body: JSON.stringify(response)\n    };\n  }\n\n  /**\n   * Bad Request (400)\n   */\n  public static badRequest(message: string, details?: any): APIGatewayProxyResult {\n    return this.error(message, ErrorCode.VALIDATION_ERROR, details, 400);\n  }\n\n  /**\n   * Unauthorized (401)\n   */\n  public static unauthorized(message: string = 'Unauthorized'): APIGatewayProxyResult {\n    return this.error(message, ErrorCode.UNAUTHORIZED, undefined, 401);\n  }\n\n  /**\n   * Forbidden (403)\n   */\n  public static forbidden(message: string = 'Forbidden'): APIGatewayProxyResult {\n    return this.error(message, ErrorCode.FORBIDDEN, undefined, 403);\n  }\n\n  /**\n   * Not Found (404)\n   */\n  public static notFound(message: string = 'Resource not found'): APIGatewayProxyResult {\n    return this.error(message, ErrorCode.NOT_FOUND, undefined, 404);\n  }\n\n  /**\n   * Rate Limited (429)\n   */\n  public static rateLimited(message: string = 'Rate limit exceeded'): APIGatewayProxyResult {\n    return this.error(message, ErrorCode.RATE_LIMITED, undefined, 429);\n  }\n\n  /**\n   * Internal Server Error (500)\n   */\n  public static internalError(message: string = 'Internal server error'): APIGatewayProxyResult {\n    return this.error(message, ErrorCode.INTERNAL_ERROR, undefined, 500);\n  }\n\n  /**\n   * CORS preflight response\n   */\n  public static cors(): APIGatewayProxyResult {\n    return {\n      statusCode: 200,\n      headers: {\n        ...this.CORS_HEADERS,\n        'Access-Control-Max-Age': '86400' // Cache preflight for 24 hours\n      },\n      body: ''\n    };\n  }\n\n  /**\n   * Health check response\n   */\n  public static health(data: any): APIGatewayProxyResult {\n    return this.success({\n      status: 'healthy',\n      timestamp: new Date().toISOString(),\n      version: this.VERSION,\n      environment: process.env.STAGE || 'unknown',\n      ...data\n    });\n  }\n\n  /**\n   * Paginated response\n   */\n  public static paginated<T>(\n    items: T[],\n    totalCount: number,\n    page: number,\n    pageSize: number,\n    message?: string\n  ): APIGatewayProxyResult {\n    const totalPages = Math.ceil(totalCount / pageSize);\n    const hasNextPage = page < totalPages;\n    const hasPrevPage = page > 1;\n\n    return this.success({\n      items,\n      pagination: {\n        totalCount,\n        totalPages,\n        currentPage: page,\n        pageSize,\n        hasNextPage,\n        hasPrevPage\n      }\n    }, 200, message);\n  }\n}", "/**\n * Structured Logger - V2\n * Provides consistent logging across all Lambda functions\n */\nexport class Logger {\n  private readonly context: string;\n  private readonly logLevel: string;\n\n  constructor(context: string) {\n    this.context = context;\n    this.logLevel = process.env.LOG_LEVEL || 'INFO';\n  }\n\n  /**\n   * Info level logging\n   */\n  public info(message: string, data?: any): void {\n    if (this.shouldLog('INFO')) {\n      this.log('INFO', message, data);\n    }\n  }\n\n  /**\n   * Debug level logging\n   */\n  public debug(message: string, data?: any): void {\n    if (this.shouldLog('DEBUG')) {\n      this.log('DEBUG', message, data);\n    }\n  }\n\n  /**\n   * Warning level logging\n   */\n  public warn(message: string, data?: any): void {\n    if (this.shouldLog('WARN')) {\n      this.log('WARN', message, data);\n    }\n  }\n\n  /**\n   * Error level logging\n   */\n  public error(message: string, error?: any): void {\n    const errorData = error instanceof Error ? {\n      name: error.name,\n      message: error.message,\n      stack: error.stack\n    } : error;\n\n    this.log('ERROR', message, errorData);\n  }\n\n  /**\n   * Performance logging\n   */\n  public perf(operation: string, duration: number, data?: any): void {\n    this.info(`Performance: ${operation}`, {\n      duration: `${duration}ms`,\n      operation,\n      ...data\n    });\n  }\n\n  /**\n   * Core logging method\n   */\n  private log(level: string, message: string, data?: any): void {\n    const logEntry = {\n      timestamp: new Date().toISOString(),\n      level,\n      context: this.context,\n      message,\n      stage: process.env.STAGE || 'unknown',\n      version: '2.0.0',\n      ...(data && { data })\n    };\n\n    // Use console methods for CloudWatch integration\n    switch (level) {\n      case 'ERROR':\n        console.error(JSON.stringify(logEntry));\n        break;\n      case 'WARN':\n        console.warn(JSON.stringify(logEntry));\n        break;\n      default:\n        console.log(JSON.stringify(logEntry));\n    }\n  }\n\n  /**\n   * Check if message should be logged based on log level\n   */\n  private shouldLog(level: string): boolean {\n    const levels = ['ERROR', 'WARN', 'INFO', 'DEBUG'];\n    const currentLevelIndex = levels.indexOf(this.logLevel);\n    const messageLevelIndex = levels.indexOf(level);\n    \n    return messageLevelIndex <= currentLevelIndex;\n  }\n}", "import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';\nimport { PublicHandler, AuthenticatedHandler, ApiResponse, ErrorCode, ApiError } from '../types';\nimport { ResponseBuilder } from './response-builder';\nimport { Logger } from './logger';\n\n/**\n * Base Handler Class - Eliminates ALL boilerplate code across Lambda functions\n * \n * This addresses the V1 issue where auth code was duplicated across 7+ handlers.\n * Now ALL common functionality is centralized in this base class.\n */\nexport abstract class BaseHandler {\n  protected logger: Logger;\n  protected version: string = '2.0.0';\n\n  constructor(protected handlerName: string) {\n    this.logger = new Logger(handlerName);\n  }\n\n  /**\n   * Main entry point for authenticated handlers\n   * Handles ALL common concerns: auth, CORS, logging, error handling\n   */\n  public withAuth(handler: AuthenticatedHandler): PublicHandler {\n    return async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {\n      const requestId = event.requestContext.requestId;\n      const route = `${event.httpMethod} ${event.resource}`;\n      \n      try {\n        this.logger.info(`[${requestId}] ${route} - Request started`, {\n          httpMethod: event.httpMethod,\n          resource: event.resource,\n          userAgent: event.headers['User-Agent'],\n          sourceIp: event.requestContext.identity.sourceIp\n        });\n\n        // Handle CORS preflight\n        if (event.httpMethod === 'OPTIONS') {\n          return ResponseBuilder.cors();\n        }\n\n        // Extract and validate user context\n        const userId = this.extractUserId(event);\n        \n        if (!userId) {\n          this.logger.warn(`[${requestId}] ${route} - No userId in authorizer context`, {\n            authorizerContext: event.requestContext.authorizer\n          });\n          return ResponseBuilder.unauthorized('User not authenticated');\n        }\n\n        this.logger.info(`[${requestId}] ${route} - Authenticated user: ${userId}`);\n\n        // Validate request if needed\n        const validationError = await this.validateRequest(event);\n        if (validationError) {\n          this.logger.warn(`[${requestId}] ${route} - Validation failed`, validationError);\n          return ResponseBuilder.badRequest(validationError.message, validationError);\n        }\n\n        // Execute the actual handler\n        const startTime = Date.now();\n        const result = await handler(event, userId);\n        const duration = Date.now() - startTime;\n\n        this.logger.info(`[${requestId}] ${route} - Request completed`, {\n          statusCode: result.statusCode,\n          duration: `${duration}ms`\n        });\n\n        return result;\n\n      } catch (error) {\n        this.logger.error(`[${requestId}] ${route} - Request failed`, error);\n        return this.handleError(error);\n      }\n    };\n  }\n\n  /**\n   * Entry point for public handlers (no auth required)\n   * Still handles common concerns: CORS, logging, error handling\n   */\n  public withoutAuth(handler: PublicHandler): PublicHandler {\n    return async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {\n      const requestId = event.requestContext.requestId;\n      const route = `${event.httpMethod} ${event.resource}`;\n      \n      try {\n        this.logger.info(`[${requestId}] ${route} - Public request started`);\n\n        // Handle CORS preflight\n        if (event.httpMethod === 'OPTIONS') {\n          return ResponseBuilder.cors();\n        }\n\n        // Execute the handler\n        const startTime = Date.now();\n        const result = await handler(event);\n        const duration = Date.now() - startTime;\n\n        this.logger.info(`[${requestId}] ${route} - Public request completed`, {\n          statusCode: result.statusCode,\n          duration: `${duration}ms`\n        });\n\n        return result;\n\n      } catch (error) {\n        this.logger.error(`[${requestId}] ${route} - Public request failed`, error);\n        return this.handleError(error);\n      }\n    };\n  }\n\n  /**\n   * Extract userId from API Gateway authorizer context\n   * Handles both TOKEN and REQUEST authorizer formats\n   */\n  private extractUserId(event: APIGatewayProxyEvent): string | null {\n    const authorizer = event.requestContext.authorizer;\n    \n    if (!authorizer) {\n      return null;\n    }\n\n    // Try different possible locations for userId\n    return (\n      authorizer.userId ||\n      authorizer.principalId ||\n      authorizer.claims?.userId ||\n      authorizer.claims?.sub ||\n      null\n    );\n  }\n\n  /**\n   * Validate request - override in specific handlers\n   */\n  protected async validateRequest(event: APIGatewayProxyEvent): Promise<ApiError | null> {\n    return null; // No validation by default\n  }\n\n  /**\n   * Centralized error handling\n   */\n  private handleError(error: any): APIGatewayProxyResult {\n    if (error instanceof ApiError) {\n      return ResponseBuilder.error(error.message, error.code, error.details);\n    }\n\n    if (error.name === 'ValidationError') {\n      return ResponseBuilder.badRequest(error.message);\n    }\n\n    if (error.name === 'UnauthorizedError') {\n      return ResponseBuilder.unauthorized(error.message);\n    }\n\n    if (error.name === 'ForbiddenError') {\n      return ResponseBuilder.forbidden(error.message);\n    }\n\n    if (error.name === 'NotFoundError') {\n      return ResponseBuilder.notFound(error.message);\n    }\n\n    // Default to internal server error\n    return ResponseBuilder.internalError('An unexpected error occurred');\n  }\n\n  /**\n   * Helper: Parse JSON body safely\n   */\n  protected parseJsonBody<T>(event: APIGatewayProxyEvent): T | null {\n    if (!event.body) {\n      return null;\n    }\n\n    try {\n      // Handle base64 encoded body\n      let bodyString = event.body;\n      if (event.isBase64Encoded) {\n        bodyString = Buffer.from(event.body, 'base64').toString('utf-8');\n      }\n      \n      this.logger.debug('Parsing request body', { \n        isBase64Encoded: event.isBase64Encoded, \n        bodyLength: bodyString.length,\n        rawBody: bodyString.substring(0, 200) // Log first 200 chars for debugging\n      });\n      \n      return JSON.parse(bodyString) as T;\n    } catch (error: any) {\n      this.logger.error('JSON parsing failed', { \n        body: event.body, \n        bodyString: bodyString.substring(0, 200),\n        isBase64Encoded: event.isBase64Encoded, \n        error: error.message,\n        contentType: event.headers['Content-Type'] || event.headers['content-type']\n      });\n      throw new ApiError(ErrorCode.VALIDATION_ERROR, 'Invalid JSON in request body');\n    }\n  }\n\n  /**\n   * Helper: Get query parameter with default\n   */\n  protected getQueryParam(event: APIGatewayProxyEvent, key: string, defaultValue?: string): string | undefined {\n    return event.queryStringParameters?.[key] || defaultValue;\n  }\n\n  /**\n   * Helper: Get path parameter\n   */\n  protected getPathParam(event: APIGatewayProxyEvent, key: string): string | undefined {\n    return event.pathParameters?.[key];\n  }\n\n  /**\n   * Helper: Get header value\n   */\n  protected getHeader(event: APIGatewayProxyEvent, key: string): string | undefined {\n    return event.headers[key] || event.headers[key.toLowerCase()];\n  }\n\n  /**\n   * Helper: Create success response with data\n   */\n  protected success<T>(data: T, message?: string): APIGatewayProxyResult {\n    return ResponseBuilder.success(data, 200, message);\n  }\n\n  /**\n   * Helper: Create created response\n   */\n  protected created<T>(data: T, message?: string): APIGatewayProxyResult {\n    return ResponseBuilder.success(data, 201, message);\n  }\n\n  /**\n   * Helper: Create no content response\n   */\n  protected noContent(): APIGatewayProxyResult {\n    return ResponseBuilder.success(null, 204);\n  }\n\n  /**\n   * Helper: Create bad request response\n   */\n  protected badRequest(message: string, details?: any): APIGatewayProxyResult {\n    return ResponseBuilder.badRequest(message, details);\n  }\n\n  /**\n   * Helper: Create not found response\n   */\n  protected notFound(message: string): APIGatewayProxyResult {\n    return ResponseBuilder.notFound(message);\n  }\n\n  /**\n   * Helper: Create internal error response\n   */\n  protected internalError(message: string): APIGatewayProxyResult {\n    return ResponseBuilder.internalError(message);\n  }\n}", "import { S3Client, GetObjectCommand, PutObjectCommand, ListObjectsV2Command } from '@aws-sdk/client-s3';\nimport { Logger } from '../shared/logger';\n\n/**\n * S3 Service - Handles all S3 operations for study data\n * Provides methods for loading providers, questions, and managing data files\n */\nexport class S3Service {\n  private client: S3Client;\n  private logger: Logger;\n  private readonly bucketName: string;\n  private readonly region: string;\n\n  constructor() {\n    this.logger = new Logger('S3Service');\n    this.bucketName = process.env.DATA_BUCKET || 'study-app-data';\n    this.region = process.env.AWS_REGION || 'us-east-1';\n    \n    this.client = new S3Client({\n      region: this.region,\n    });\n\n    this.logger.info('S3Service initialized', {\n      bucketName: this.bucketName,\n      region: this.region\n    });\n  }\n\n  /**\n   * Get JSON object from S3\n   */\n  async getJsonObject<T>(key: string): Promise<T | null> {\n    const startTime = Date.now();\n    \n    try {\n      this.logger.debug('Fetching object from S3', { key, bucket: this.bucketName });\n\n      const command = new GetObjectCommand({\n        Bucket: this.bucketName,\n        Key: key\n      });\n\n      const response = await this.client.send(command);\n      \n      if (!response.Body) {\n        this.logger.warn('Empty response body from S3', { key });\n        return null;\n      }\n\n      const bodyString = await response.Body.transformToString();\n      const data = JSON.parse(bodyString);\n      \n      this.logger.perf('S3 getJsonObject', Date.now() - startTime, { \n        key, \n        sizeBytes: bodyString.length \n      });\n      \n      return data;\n    } catch (error) {\n      this.logger.error('Failed to get object from S3', {\n        key,\n        bucket: this.bucketName,\n        error: error instanceof Error ? error.message : error\n      });\n      \n      // Return null for not found, throw for other errors\n      if (error instanceof Error && error.name === 'NoSuchKey') {\n        return null;\n      }\n      \n      throw error;\n    }\n  }\n\n  /**\n   * Put JSON object to S3\n   */\n  async putJsonObject<T>(key: string, data: T): Promise<void> {\n    const startTime = Date.now();\n    \n    try {\n      const jsonString = JSON.stringify(data, null, 2);\n      \n      this.logger.debug('Putting object to S3', { key, sizeBytes: jsonString.length });\n\n      const command = new PutObjectCommand({\n        Bucket: this.bucketName,\n        Key: key,\n        Body: jsonString,\n        ContentType: 'application/json',\n        ServerSideEncryption: 'AES256'\n      });\n\n      await this.client.send(command);\n      \n      this.logger.perf('S3 putJsonObject', Date.now() - startTime, { \n        key, \n        sizeBytes: jsonString.length \n      });\n      \n      this.logger.info('Successfully uploaded object to S3', { key });\n    } catch (error) {\n      this.logger.error('Failed to put object to S3', {\n        key,\n        bucket: this.bucketName,\n        error: error instanceof Error ? error.message : error\n      });\n      \n      throw error;\n    }\n  }\n\n  /**\n   * List objects with a prefix\n   */\n  async listObjects(prefix: string): Promise<string[]> {\n    const startTime = Date.now();\n    \n    try {\n      this.logger.debug('Listing objects from S3', { prefix });\n\n      const command = new ListObjectsV2Command({\n        Bucket: this.bucketName,\n        Prefix: prefix,\n        MaxKeys: 1000\n      });\n\n      const response = await this.client.send(command);\n      const keys = (response.Contents || [])\n        .map(obj => obj.Key)\n        .filter((key): key is string => key !== undefined);\n      \n      this.logger.perf('S3 listObjects', Date.now() - startTime, { \n        prefix, \n        count: keys.length \n      });\n      \n      return keys;\n    } catch (error) {\n      this.logger.error('Failed to list objects from S3', {\n        prefix,\n        bucket: this.bucketName,\n        error: error instanceof Error ? error.message : error\n      });\n      \n      throw error;\n    }\n  }\n\n  /**\n   * Check if an object exists\n   */\n  async objectExists(key: string): Promise<boolean> {\n    try {\n      const command = new GetObjectCommand({\n        Bucket: this.bucketName,\n        Key: key\n      });\n\n      await this.client.send(command);\n      return true;\n    } catch (error) {\n      if (error instanceof Error && error.name === 'NoSuchKey') {\n        return false;\n      }\n      \n      // Re-throw other errors\n      throw error;\n    }\n  }\n\n  /**\n   * Get the configured bucket name\n   */\n  getBucketName(): string {\n    return this.bucketName;\n  }\n}", "import { DynamoDBClient } from '@aws-sdk/client-dynamodb';\nimport { DynamoDBDocumentClient, GetCommand, PutCommand } from '@aws-sdk/lib-dynamodb';\nimport { Logger } from '../shared/logger';\n\n/**\n * Cache Service - DynamoDB-based caching layer\n * Provides persistent caching for study data across Lambda invocations\n */\nexport class CacheService {\n  private client: DynamoDBDocumentClient;\n  private logger: Logger;\n  private readonly tableName: string;\n  private readonly region: string;\n\n  constructor() {\n    this.logger = new Logger('CacheService');\n    this.tableName = process.env.CACHE_TABLE || 'study-app-cache';\n    this.region = process.env.AWS_REGION || 'us-east-1';\n\n    const ddbClient = new DynamoDBClient({ region: this.region });\n    this.client = DynamoDBDocumentClient.from(ddbClient);\n\n    this.logger.info('CacheService initialized', {\n      tableName: this.tableName,\n      region: this.region\n    });\n  }\n\n  /**\n   * Get item from cache\n   */\n  async get<T>(key: string): Promise<T | null> {\n    const startTime = Date.now();\n\n    try {\n      this.logger.debug('Getting item from cache', { key });\n\n      const command = new GetCommand({\n        TableName: this.tableName,\n        Key: { cacheKey: key }\n      });\n\n      const response = await this.client.send(command);\n\n      if (!response.Item) {\n        this.logger.debug('Cache miss', { key });\n        return null;\n      }\n\n      // Check if item has expired\n      const now = Date.now();\n      if (response.Item.ttl && response.Item.ttl * 1000 < now) {\n        this.logger.debug('Cache item expired', { key, ttl: response.Item.ttl });\n        return null;\n      }\n\n      this.logger.perf('Cache get', Date.now() - startTime, { \n        key, \n        hit: true,\n        sizeBytes: JSON.stringify(response.Item.data).length \n      });\n\n      return response.Item.data as T;\n\n    } catch (error) {\n      this.logger.error('Failed to get item from cache', { key, error });\n      \n      // Return null on cache errors to allow fallback to primary source\n      return null;\n    }\n  }\n\n  /**\n   * Put item in cache with TTL\n   */\n  async put<T>(key: string, data: T, ttlMinutes: number = 60): Promise<void> {\n    const startTime = Date.now();\n\n    try {\n      const ttl = Math.floor(Date.now() / 1000) + (ttlMinutes * 60);\n      const item = {\n        cacheKey: key,\n        data,\n        ttl,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n      };\n\n      this.logger.debug('Putting item in cache', { \n        key, \n        ttlMinutes,\n        sizeBytes: JSON.stringify(data).length \n      });\n\n      const command = new PutCommand({\n        TableName: this.tableName,\n        Item: item\n      });\n\n      await this.client.send(command);\n\n      this.logger.perf('Cache put', Date.now() - startTime, { \n        key, \n        ttlMinutes,\n        sizeBytes: JSON.stringify(data).length \n      });\n\n    } catch (error) {\n      this.logger.error('Failed to put item in cache', { key, error });\n      \n      // Don't throw on cache errors - it's not critical\n      // The application should continue to work without cache\n    }\n  }\n\n  /**\n   * Generate cache key for providers\n   */\n  getProvidersCacheKey(): string {\n    return 'providers:all';\n  }\n\n  /**\n   * Generate cache key for specific provider\n   */\n  getProviderCacheKey(providerId: string): string {\n    return `provider:${providerId}`;\n  }\n\n  /**\n   * Generate cache key for questions\n   */\n  getQuestionsCacheKey(provider: string, exam: string): string {\n    return `questions:${provider}:${exam}`;\n  }\n\n  /**\n   * Generate cache key for question stats\n   */\n  getQuestionStatsCacheKey(provider: string, exam: string): string {\n    return `stats:questions:${provider}:${exam}`;\n  }\n\n  /**\n   * Generate cache key for filtered questions\n   * Note: This creates a lot of cache entries, use sparingly\n   */\n  getFilteredQuestionsCacheKey(\n    provider: string, \n    exam: string, \n    filter: any,\n    pagination: any\n  ): string {\n    const filterHash = this.hashObject({ filter, pagination });\n    return `filtered:${provider}:${exam}:${filterHash}`;\n  }\n\n  /**\n   * Simple hash function for objects\n   */\n  private hashObject(obj: any): string {\n    const str = JSON.stringify(obj, Object.keys(obj).sort());\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    return Math.abs(hash).toString(36);\n  }\n\n  /**\n   * Clear specific cache entries\n   */\n  async clearCache(pattern: string): Promise<void> {\n    // For DynamoDB, we'd need to implement a scan and delete operation\n    // This is expensive and not recommended for production\n    this.logger.warn('Cache clear not implemented for DynamoDB', { pattern });\n  }\n\n  /**\n   * Get cache statistics\n   */\n  async getCacheStats(): Promise<{\n    tableName: string;\n    region: string;\n    // Additional stats could be added by scanning the table\n  }> {\n    return {\n      tableName: this.tableName,\n      region: this.region\n    };\n  }\n}\n\n/**\n * Multi-layer Cache Manager\n * Combines Lambda memory cache with DynamoDB persistent cache\n */\nexport class MultiLayerCache {\n  private memoryCache: Map<string, { data: any; timestamp: number; ttl: number }> = new Map();\n  private dynamoCache: CacheService;\n  private logger: Logger;\n  private readonly memoryTtl = 5 * 60 * 1000; // 5 minutes in memory\n\n  constructor() {\n    this.dynamoCache = new CacheService();\n    this.logger = new Logger('MultiLayerCache');\n  }\n\n  /**\n   * Get item from multi-layer cache\n   * Checks memory first, then DynamoDB\n   */\n  async get<T>(key: string): Promise<T | null> {\n    // Check memory cache first\n    const memoryItem = this.memoryCache.get(key);\n    if (memoryItem && Date.now() - memoryItem.timestamp < memoryItem.ttl) {\n      this.logger.debug('Memory cache hit', { key });\n      return memoryItem.data as T;\n    }\n\n    // Remove expired memory cache item\n    if (memoryItem) {\n      this.memoryCache.delete(key);\n    }\n\n    // Check DynamoDB cache\n    const dynamoItem = await this.dynamoCache.get<T>(key);\n    if (dynamoItem) {\n      // Store in memory cache for faster future access\n      this.memoryCache.set(key, {\n        data: dynamoItem,\n        timestamp: Date.now(),\n        ttl: this.memoryTtl\n      });\n      \n      this.logger.debug('DynamoDB cache hit, stored in memory', { key });\n      return dynamoItem;\n    }\n\n    this.logger.debug('Cache miss on all layers', { key });\n    return null;\n  }\n\n  /**\n   * Put item in multi-layer cache\n   */\n  async put<T>(key: string, data: T, dynamoTtlMinutes: number = 60): Promise<void> {\n    // Store in memory cache immediately\n    this.memoryCache.set(key, {\n      data,\n      timestamp: Date.now(),\n      ttl: this.memoryTtl\n    });\n\n    // Store in DynamoDB cache asynchronously\n    await this.dynamoCache.put(key, data, dynamoTtlMinutes);\n    \n    this.logger.debug('Stored in multi-layer cache', { \n      key, \n      memoryTtlMinutes: this.memoryTtl / 60000,\n      dynamoTtlMinutes \n    });\n  }\n\n  /**\n   * Clear memory cache (DynamoDB cache remains)\n   */\n  clearMemoryCache(): void {\n    const size = this.memoryCache.size;\n    this.memoryCache.clear();\n    this.logger.info('Cleared memory cache', { entriesRemoved: size });\n  }\n\n  /**\n   * Get cache statistics\n   */\n  async getStats(): Promise<{\n    memory: {\n      entries: number;\n      totalSizeBytes: number;\n    };\n    dynamo: {\n      tableName: string;\n      region: string;\n    };\n  }> {\n    let totalSizeBytes = 0;\n    for (const [key, value] of this.memoryCache.entries()) {\n      totalSizeBytes += JSON.stringify(value).length;\n    }\n\n    const dynamoStats = await this.dynamoCache.getCacheStats();\n\n    return {\n      memory: {\n        entries: this.memoryCache.size,\n        totalSizeBytes\n      },\n      dynamo: dynamoStats\n    };\n  }\n\n  /**\n   * Cleanup expired memory cache entries\n   */\n  cleanup(): void {\n    const now = Date.now();\n    let removed = 0;\n\n    for (const [key, value] of this.memoryCache.entries()) {\n      if (now - value.timestamp >= value.ttl) {\n        this.memoryCache.delete(key);\n        removed++;\n      }\n    }\n\n    if (removed > 0) {\n      this.logger.debug('Cleaned up expired memory cache entries', { removed });\n    }\n  }\n}", "import validate from './validate.js';\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  //\n  // Note to future-self: No, you can't remove the `toLowerCase()` call.\n  // REF: https://github.com/uuidjs/uuid/pull/677#issuecomment-1757351351\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset);\n  // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n  return uuid;\n}\nexport default stringify;", "import crypto from 'node:crypto';\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\nlet poolPtr = rnds8Pool.length;\nexport default function rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    crypto.randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}", "import crypto from 'node:crypto';\nexport default {\n  randomUUID: crypto.randomUUID\n};", "import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    offset = offset || 0;\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n    return buf;\n  }\n  return unsafeStringify(rnds);\n}\nexport default v4;", "import { Question, RawQuestionData, QuestionFilter, PaginationOptions, QuestionSearchResult } from '../types';\nimport { S3Service } from './s3-service';\nimport { MultiLayerCache } from './cache-service';\nimport { Logger } from '../shared/logger';\nimport { v4 as uuidv4 } from 'uuid';\n\n/**\n * Question Service - Manages study questions with S3 backend\n * Provides filtering, search, and pagination capabilities with multi-layer caching\n */\nexport class QuestionService {\n  private s3Service: S3Service;\n  private cache: MultiLayerCache;\n  private logger: Logger;\n\n  constructor() {\n    this.s3Service = new S3Service();\n    this.cache = new MultiLayerCache();\n    this.logger = new Logger('QuestionService');\n  }\n\n  /**\n   * Get questions with filtering, search, and pagination\n   */\n  async getQuestions(\n    provider: string, \n    exam: string, \n    filter?: QuestionFilter,\n    pagination?: PaginationOptions\n  ): Promise<QuestionSearchResult> {\n    const startTime = Date.now();\n    const cacheKey = `${provider}-${exam}`;\n\n    try {\n      this.logger.info('Getting questions', { \n        provider, \n        exam, \n        filter, \n        pagination \n      });\n\n      // Load all questions for the exam\n      const allQuestions = await this.loadQuestionsFromCache(cacheKey, provider, exam);\n      \n      // Apply filters\n      let filteredQuestions = this.applyFilters(allQuestions, filter);\n      \n      // Get filter metadata\n      const filterMetadata = this.generateFilterMetadata(allQuestions);\n\n      // Apply pagination\n      const paginationOptions = pagination || { limit: 50, offset: 0 };\n      const totalCount = filteredQuestions.length;\n      const paginatedQuestions = filteredQuestions.slice(\n        paginationOptions.offset,\n        paginationOptions.offset + paginationOptions.limit\n      );\n\n      const result: QuestionSearchResult = {\n        questions: paginatedQuestions,\n        totalCount,\n        hasMore: paginationOptions.offset + paginatedQuestions.length < totalCount,\n        filters: filterMetadata\n      };\n\n      this.logger.perf('getQuestions', Date.now() - startTime, {\n        provider,\n        exam,\n        totalQuestions: allQuestions.length,\n        filteredCount: totalCount,\n        returnedCount: paginatedQuestions.length\n      });\n\n      return result;\n    } catch (error) {\n      this.logger.error('Failed to get questions', {\n        provider,\n        exam,\n        filter,\n        pagination,\n        error\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get a specific question by ID\n   */\n  async getQuestion(\n    provider: string, \n    exam: string, \n    questionId: string\n  ): Promise<Question | null> {\n    const startTime = Date.now();\n    const cacheKey = `${provider}-${exam}`;\n\n    try {\n      const allQuestions = await this.loadQuestionsFromCache(cacheKey, provider, exam);\n      const question = allQuestions.find(q => q.questionId === questionId);\n\n      this.logger.perf('getQuestion', Date.now() - startTime, {\n        provider,\n        exam,\n        questionId,\n        found: !!question\n      });\n\n      return question || null;\n    } catch (error) {\n      this.logger.error('Failed to get specific question', {\n        provider,\n        exam,\n        questionId,\n        error\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get random questions for practice\n   */\n  async getRandomQuestions(\n    provider: string,\n    exam: string,\n    count: number,\n    filter?: QuestionFilter\n  ): Promise<Question[]> {\n    try {\n      const cacheKey = `${provider}-${exam}`;\n      const allQuestions = await this.loadQuestionsFromCache(cacheKey, provider, exam);\n      \n      // Apply filters\n      let filteredQuestions = this.applyFilters(allQuestions, filter);\n      \n      // Shuffle and take random questions\n      const shuffled = this.shuffleArray([...filteredQuestions]);\n      return shuffled.slice(0, Math.min(count, shuffled.length));\n    } catch (error) {\n      this.logger.error('Failed to get random questions', {\n        provider,\n        exam,\n        count,\n        filter,\n        error\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get question statistics\n   */\n  async getQuestionStats(provider: string, exam: string): Promise<{\n    totalQuestions: number;\n    difficultyDistribution: { [key: string]: number };\n    topicDistribution: { [key: string]: number };\n    serviceDistribution: { [key: string]: number };\n    hasExplanationCount: number;\n  }> {\n    try {\n      const cacheKey = `${provider}-${exam}`;\n      const allQuestions = await this.loadQuestionsFromCache(cacheKey, provider, exam);\n\n      const stats = {\n        totalQuestions: allQuestions.length,\n        difficultyDistribution: {},\n        topicDistribution: {},\n        serviceDistribution: {},\n        hasExplanationCount: 0\n      } as any;\n\n      allQuestions.forEach(question => {\n        // Difficulty distribution\n        const difficulty = question.difficulty || 'unknown';\n        stats.difficultyDistribution[difficulty] = (stats.difficultyDistribution[difficulty] || 0) + 1;\n\n        // Topic distribution\n        question.topics.forEach(topic => {\n          stats.topicDistribution[topic] = (stats.topicDistribution[topic] || 0) + 1;\n        });\n\n        // Service distribution\n        if (question.awsServices) {\n          question.awsServices.forEach(service => {\n            stats.serviceDistribution[service] = (stats.serviceDistribution[service] || 0) + 1;\n          });\n        }\n\n        // Explanation count\n        if (question.hasExplanation) {\n          stats.hasExplanationCount++;\n        }\n      });\n\n      return stats;\n    } catch (error) {\n      this.logger.error('Failed to get question stats', { provider, exam, error });\n      throw error;\n    }\n  }\n\n  /**\n   * Clear cache for specific provider/exam or all\n   */\n  clearCache(provider?: string, exam?: string): void {\n    // Only clear memory cache, DynamoDB cache will expire naturally\n    this.cache.clearMemoryCache();\n    this.logger.info('Cleared question cache', { provider, exam });\n  }\n\n  /**\n   * Load questions from cache or S3\n   */\n  private async loadQuestionsFromCache(\n    cacheKey: string, \n    provider: string, \n    exam: string\n  ): Promise<Question[]> {\n    // Check multi-layer cache first\n    const cachedQuestions = await this.cache.get<Question[]>(cacheKey);\n    if (cachedQuestions) {\n      this.logger.debug('Returning cached questions', { cacheKey });\n      return cachedQuestions;\n    }\n\n    this.logger.info('Loading questions from S3', { cacheKey, provider, exam });\n\n    // Load from S3\n    const questions = await this.loadQuestionsFromS3(provider, exam);\n    \n    // Update cache with 30 minute TTL\n    await this.cache.put(cacheKey, questions, 30);\n\n    return questions;\n  }\n\n  /**\n   * Load questions from S3\n   */\n  private async loadQuestionsFromS3(provider: string, exam: string): Promise<Question[]> {\n    try {\n      // Try to load processed questions first\n      let questions = await this.s3Service.getJsonObject<Question[]>(`questions/${provider}/${exam}/questions.json`);\n      \n      if (questions && questions.length > 0) {\n        return questions;\n      }\n\n      // If processed questions don't exist, try to load raw data and convert\n      const rawData = await this.s3Service.getJsonObject<{ study_data: RawQuestionData[] }>(`questions/${provider}/${exam}/raw-data.json`);\n      \n      if (rawData && rawData.study_data) {\n        questions = rawData.study_data.map(raw => this.convertRawToQuestion(raw, provider, exam));\n        \n        // Save processed questions back to S3 for faster future loads\n        await this.s3Service.putJsonObject(`questions/${provider}/${exam}/questions.json`, questions);\n        \n        return questions;\n      }\n\n      // Return empty array if no data found\n      this.logger.warn('No questions found for exam', { provider, exam });\n      return [];\n\n    } catch (error) {\n      this.logger.error('Failed to load questions from S3', { provider, exam, error });\n      \n      // Return empty array on error rather than throwing\n      return [];\n    }\n  }\n\n  /**\n   * Convert raw question data to Question interface\n   */\n  private convertRawToQuestion(raw: RawQuestionData, provider: string, exam: string): Question {\n    return {\n      questionId: uuidv4(),\n      questionNumber: raw.question_number,\n      provider,\n      exam,\n      text: raw.question.text,\n      options: raw.question.options,\n      questionType: raw.question.question_type,\n      expectedAnswers: raw.question.expected_answers,\n      correctAnswer: raw.answer?.correct_answer || '',\n      explanation: raw.answer?.explanation,\n      difficulty: raw.study_metadata?.difficulty || 'medium',\n      topics: raw.question.topic ? [raw.question.topic] : [],\n      serviceCategory: raw.question.service_category,\n      awsServices: raw.question.aws_services || [],\n      keywords: raw.answer?.keywords || [],\n      createdAt: new Date().toISOString(),\n      parsingConfidence: raw.answer?.parsing_confidence,\n      hasExplanation: raw.study_metadata?.has_explanation || false\n    };\n  }\n\n  /**\n   * Apply filters to questions\n   */\n  private applyFilters(questions: Question[], filter?: QuestionFilter): Question[] {\n    if (!filter) {\n      return questions;\n    }\n\n    let filtered = questions;\n\n    if (filter.difficulty) {\n      filtered = filtered.filter(q => q.difficulty === filter.difficulty);\n    }\n\n    if (filter.topics && filter.topics.length > 0) {\n      filtered = filtered.filter(q => \n        filter.topics!.some(topic => q.topics.includes(topic))\n      );\n    }\n\n    if (filter.serviceCategory) {\n      filtered = filtered.filter(q => q.serviceCategory === filter.serviceCategory);\n    }\n\n    if (filter.awsServices && filter.awsServices.length > 0) {\n      filtered = filtered.filter(q => \n        q.awsServices && filter.awsServices!.some(service => q.awsServices!.includes(service))\n      );\n    }\n\n    if (filter.hasExplanation !== undefined) {\n      filtered = filtered.filter(q => q.hasExplanation === filter.hasExplanation);\n    }\n\n    if (filter.questionType) {\n      filtered = filtered.filter(q => q.questionType === filter.questionType);\n    }\n\n    if (filter.search) {\n      const searchTerm = filter.search.toLowerCase();\n      filtered = filtered.filter(q => \n        q.text.toLowerCase().includes(searchTerm) ||\n        (q.explanation && q.explanation.toLowerCase().includes(searchTerm)) ||\n        q.topics.some(topic => topic.toLowerCase().includes(searchTerm)) ||\n        (q.keywords && q.keywords.some(keyword => keyword.toLowerCase().includes(searchTerm)))\n      );\n    }\n\n    return filtered;\n  }\n\n  /**\n   * Generate filter metadata from all questions\n   */\n  private generateFilterMetadata(questions: Question[]): {\n    availableTopics: string[];\n    availableServiceCategories: string[];\n    availableAwsServices: string[];\n    difficultyDistribution: { [key: string]: number };\n  } {\n    const topics = new Set<string>();\n    const serviceCategories = new Set<string>();\n    const awsServices = new Set<string>();\n    const difficultyDistribution: { [key: string]: number } = {};\n\n    questions.forEach(question => {\n      // Collect topics\n      question.topics.forEach(topic => topics.add(topic));\n\n      // Collect service categories\n      if (question.serviceCategory) {\n        serviceCategories.add(question.serviceCategory);\n      }\n\n      // Collect AWS services\n      if (question.awsServices) {\n        question.awsServices.forEach(service => awsServices.add(service));\n      }\n\n      // Count difficulty distribution\n      const difficulty = question.difficulty || 'unknown';\n      difficultyDistribution[difficulty] = (difficultyDistribution[difficulty] || 0) + 1;\n    });\n\n    return {\n      availableTopics: Array.from(topics).sort(),\n      availableServiceCategories: Array.from(serviceCategories).sort(),\n      availableAwsServices: Array.from(awsServices).sort(),\n      difficultyDistribution\n    };\n  }\n\n  /**\n   * Shuffle array using Fisher-Yates algorithm\n   */\n  private shuffleArray<T>(array: T[]): T[] {\n    const shuffled = [...array];\n    for (let i = shuffled.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [shuffled[i], shuffled[j]] = [shuffled[j]!, shuffled[i]!];\n    }\n    return shuffled;\n  }\n}"],
  "mappings": "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",
  "names": ["question_handler_exports", "__export", "handler", "__toCommonJS", "ApiError", "code", "message", "details", "ResponseBuilder", "data", "statusCode", "message", "response", "code", "details", "items", "totalCount", "page", "pageSize", "totalPages", "hasNextPage", "hasPrevPage", "Logger", "context", "message", "data", "error", "errorData", "operation", "duration", "level", "logEntry", "levels", "currentLevelIndex", "BaseHandler", "handlerName", "Logger", "handler", "event", "requestId", "route", "ResponseBuilder", "userId", "validationError", "startTime", "result", "duration", "error", "authorizer", "ApiError", "bodyString", "key", "defaultValue", "data", "message", "details", "import_client_s3", "S3Service", "Logger", "key", "startTime", "command", "response", "bodyString", "data", "error", "jsonString", "prefix", "keys", "obj", "import_client_dynamodb", "import_lib_dynamodb", "CacheService", "Logger", "ddbClient", "key", "startTime", "command", "response", "now", "error", "data", "ttlMinutes", "ttl", "item", "providerId", "provider", "exam", "filter", "pagination", "filterHash", "obj", "str", "hash", "i", "char", "pattern", "MultiLayerCache", "memoryItem", "dynamoItem", "dynamoTtlMinutes", "size", "totalSizeBytes", "value", "dynamoStats", "removed", "byteToHex", "i", "unsafeStringify", "arr", "offset", "import_node_crypto", "rnds8Pool", "poolPtr", "rng", "crypto", "import_node_crypto", "native_default", "crypto", "v4", "options", "buf", "offset", "native_default", "rnds", "rng", "i", "unsafeStringify", "v4_default", "QuestionService", "S3Service", "MultiLayerCache", "Logger", "provider", "exam", "filter", "pagination", "startTime", "cacheKey", "allQuestions", "filteredQuestions", "filterMetadata", "paginationOptions", "totalCount", "paginatedQuestions", "result", "error", "questionId", "question", "q", "count", "shuffled", "stats", "difficulty", "topic", "service", "cachedQuestions", "questions", "rawData", "raw", "v4_default", "filtered", "searchTerm", "keyword", "topics", "serviceCategories", "awsServices", "difficultyDistribution", "array", "i", "j", "QuestionHandler", "BaseHandler", "QuestionService", "event", "userId", "provider", "exam", "limit", "offset", "filter", "pagination", "result", "error", "questionId", "question", "count", "questions", "stats", "httpMethod", "resource", "message", "questionHandler", "handler"]
}
