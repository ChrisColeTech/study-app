{
  "version": 3,
  "sources": ["../../src/handlers/provider-handler.ts", "../../src/types/index.ts", "../../src/shared/response-builder.ts", "../../src/shared/logger.ts", "../../src/shared/base-handler.ts", "../../src/services/s3-service.ts", "../../src/services/cache-service.ts", "../../src/services/provider-service.ts"],
  "sourcesContent": ["import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';\nimport { BaseHandler } from '../shared/base-handler';\nimport { Provider } from '../types';\nimport { ProviderService } from '../services/provider-service';\n\n/**\n * Provider Handler V2 - Demonstrates the new base handler pattern\n * \n * Compare this to V1 where every handler had 15+ lines of duplicate auth code.\n * Now it's just clean business logic with zero boilerplate!\n */\nclass ProviderHandler extends BaseHandler {\n  private providerService: ProviderService;\n\n  constructor() {\n    super('ProviderHandler');\n    this.providerService = new ProviderService();\n  }\n\n  /**\n   * Get all providers and their exams\n   */\n  private async getProviders(event: APIGatewayProxyEvent, userId: string): Promise<APIGatewayProxyResult> {\n    this.logger.info('Fetching providers for user', { userId });\n\n    try {\n      const providers = await this.providerService.getAllProviders();\n      const stats = await this.providerService.getProviderStats();\n\n      return this.success({\n        providers,\n        totalProviders: stats.totalProviders,\n        totalExams: stats.totalExams,\n        providerBreakdown: stats.providerBreakdown\n      }, 'Providers retrieved successfully');\n\n    } catch (error) {\n      this.logger.error('Failed to fetch providers', { userId, error });\n      return this.internalError('Failed to retrieve providers');\n    }\n  }\n\n  /**\n   * Get specific provider by ID\n   */\n  private async getProvider(event: APIGatewayProxyEvent, userId: string): Promise<APIGatewayProxyResult> {\n    const providerId = this.getPathParam(event, 'providerId');\n    \n    if (!providerId) {\n      return this.badRequest('Provider ID is required');\n    }\n\n    this.logger.info('Fetching specific provider', { userId, providerId });\n\n    try {\n      const provider = await this.providerService.getProvider(providerId);\n\n      if (!provider) {\n        return this.notFound(`Provider '${providerId}' not found`);\n      }\n\n      return this.success(provider, `Provider '${providerId}' retrieved successfully`);\n\n    } catch (error) {\n      this.logger.error('Failed to fetch specific provider', { userId, providerId, error });\n      return this.internalError('Failed to retrieve provider');\n    }\n  }\n\n  /**\n   * Route handler - determines which method to call\n   */\n  public async handleRequest(event: APIGatewayProxyEvent, userId: string): Promise<APIGatewayProxyResult> {\n    const { httpMethod } = event;\n    const providerId = this.getPathParam(event, 'providerId');\n\n    switch (httpMethod) {\n      case 'GET':\n        return providerId ? \n          this.getProvider(event, userId) : \n          this.getProviders(event, userId);\n      \n      default:\n        return this.methodNotAllowed(`${httpMethod} method not supported`);\n    }\n  }\n\n  private methodNotAllowed(message: string): APIGatewayProxyResult {\n    return {\n      statusCode: 405,\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ error: message })\n    };\n  }\n}\n\n// Export the handler with authentication middleware\nconst providerHandler = new ProviderHandler();\nexport const handler = providerHandler.withAuth(\n  (event: APIGatewayProxyEvent, userId: string) => providerHandler.handleRequest(event, userId)\n);", "import { APIGatewayProxyEvent, APIGatewayProxyResult, APIGatewayTokenAuthorizerEvent, APIGatewayAuthorizerResult } from 'aws-lambda';\n\n// Base Handler Types\nexport type PublicHandler = (event: APIGatewayProxyEvent) => Promise<APIGatewayProxyResult>;\nexport type AuthenticatedHandler = (event: APIGatewayProxyEvent, userId: string) => Promise<APIGatewayProxyResult>;\nexport type AuthorizerHandler = (event: APIGatewayTokenAuthorizerEvent) => Promise<APIGatewayAuthorizerResult>;\n\n// Common API Response Structure\nexport interface ApiResponse<T = any> {\n  success: boolean;\n  data?: T;\n  message?: string;\n  error?: string;\n  timestamp: string;\n  version: string;\n}\n\n// Error Types\nexport enum ErrorCode {\n  UNAUTHORIZED = 'UNAUTHORIZED',\n  FORBIDDEN = 'FORBIDDEN',\n  NOT_FOUND = 'NOT_FOUND',\n  VALIDATION_ERROR = 'VALIDATION_ERROR',\n  INTERNAL_ERROR = 'INTERNAL_ERROR',\n  RATE_LIMITED = 'RATE_LIMITED'\n}\n\nexport class ApiError extends Error {\n  constructor(\n    public code: ErrorCode,\n    message: string,\n    public details?: any\n  ) {\n    super(message);\n    this.name = 'ApiError';\n  }\n}\n\n// User Context\nexport interface UserContext {\n  userId: string;\n  email: string;\n  role?: string;\n  permissions?: string[];\n}\n\n// JWT Token Payload\nexport interface JwtPayload {\n  userId: string;\n  email: string;\n  role?: string;\n  iat: number;\n  exp: number;\n}\n\n// Database Entities\nexport interface User {\n  userId: string;\n  email: string;\n  name?: string;\n  role: string;\n  createdAt: string;\n  updatedAt: string;\n  lastLoginAt?: string;\n  isActive: boolean;\n}\n\n// Auth-related types\nexport interface UserRegistrationRequest {\n  email: string;\n  password: string;\n  name?: string;\n}\n\nexport interface UserLoginRequest {\n  email: string;\n  password: string;\n}\n\nexport interface AuthResponse {\n  user: User;\n  token: string;\n  refreshToken: string;\n  expiresIn: number;\n}\n\nexport interface RefreshTokenRequest {\n  refreshToken: string;\n}\n\n// Enhanced Session Types for comprehensive session management\nexport interface StudySession {\n  sessionId: string;\n  userId: string;\n  provider: string;\n  exam: string;\n  status: 'active' | 'completed' | 'paused' | 'expired';\n  startTime: string;\n  endTime?: string;\n  \n  // Question Management\n  totalQuestions: number;\n  questionsAnswered: number;\n  correctAnswers: number;\n  currentQuestionIndex: number;\n  selectedQuestionIds: string[]; // Pre-selected questions for the session\n  \n  // Session Configuration\n  sessionConfig: SessionConfiguration;\n  \n  // Progress Tracking\n  progress: SessionProgress;\n  \n  // Performance Analytics\n  analytics: SessionAnalytics;\n  \n  // Timestamps and TTL\n  createdAt: string;\n  updatedAt: string;\n  lastActivityAt: string;\n  expiresAt: number; // DynamoDB TTL (Unix timestamp)\n}\n\n// Session configuration options\nexport interface SessionConfiguration {\n  questionCount: number;\n  timeLimit?: number; // in minutes, optional\n  difficulty?: 'easy' | 'medium' | 'hard';\n  topics?: string[];\n  serviceCategories?: string[];\n  awsServices?: string[];\n  questionTypes?: ('single_choice' | 'multiple_choice')[];\n  shuffleQuestions: boolean;\n  immediateResultsFeedback: boolean;\n  allowReview: boolean;\n}\n\n// Detailed progress tracking\nexport interface SessionProgress {\n  percentage: number; // 0-100\n  questionsCorrect: number;\n  questionsIncorrect: number;\n  questionsSkipped: number;\n  averageTimePerQuestion: number; // in seconds\n  timeSpent: number; // total time spent in seconds\n  streakCurrent: number;\n  streakBest: number;\n}\n\n// Session performance analytics\nexport interface SessionAnalytics {\n  difficultyBreakdown: {\n    easy: { correct: number; total: number };\n    medium: { correct: number; total: number };\n    hard: { correct: number; total: number };\n  };\n  topicPerformance: { [topic: string]: { correct: number; total: number } };\n  servicePerformance: { [service: string]: { correct: number; total: number } };\n  questionTypePerformance: {\n    single_choice: { correct: number; total: number };\n    multiple_choice: { correct: number; total: number };\n  };\n  timeAnalytics: {\n    fastestAnswer: number; // in seconds\n    slowestAnswer: number; // in seconds\n    averageAnswerTime: number; // in seconds\n  };\n}\n\n// Answer submission for a question in a session\nexport interface SessionAnswer {\n  questionId: string;\n  questionIndex: number;\n  userAnswer: string | string[];\n  isCorrect: boolean;\n  timeSpent: number; // in seconds\n  submittedAt: string;\n  explanation?: string;\n}\n\n// Session state for current question delivery\nexport interface SessionState {\n  sessionId: string;\n  currentQuestion: Question;\n  questionIndex: number;\n  progress: SessionProgress;\n  timeRemaining?: number; // if timed session\n  canGoBack: boolean;\n  canSkip: boolean;\n}\n\n// Session results when completed\nexport interface SessionResults {\n  sessionId: string;\n  finalScore: number; // percentage\n  questionsCorrect: number;\n  questionsTotal: number;\n  timeSpent: number; // in seconds\n  performance: SessionAnalytics;\n  grade: 'A' | 'B' | 'C' | 'D' | 'F';\n  passed: boolean;\n  recommendations: string[];\n  completedAt: string;\n}\n\nexport interface StudyGoal {\n  goalId: string;\n  userId: string;\n  title: string;\n  description?: string;\n  targetDate: string;\n  status: 'active' | 'completed' | 'paused';\n  progress: number; // 0-100\n  metrics: {\n    questionsTarget: number;\n    questionsCompleted: number;\n    accuracyTarget: number;\n    currentAccuracy: number;\n  };\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport interface AnalyticsEvent {\n  userId: string;\n  eventType: string;\n  eventData: any;\n  timestamp: string;\n  sessionId?: string;\n  provider?: string;\n  exam?: string;\n  expiresAt: number; // TTL\n}\n\nexport interface Provider {\n  id: string;\n  name: string;\n  description: string;\n  exams: Exam[];\n}\n\nexport interface Exam {\n  id: string;\n  name: string;\n  description: string;\n  questionCount: number;\n  duration?: number;\n  passingScore?: number;\n}\n\nexport interface Question {\n  questionId: string;\n  questionNumber: number;\n  provider: string;\n  exam: string;\n  text: string;\n  options: string[][];\n  questionType: 'single_choice' | 'multiple_choice';\n  expectedAnswers: number;\n  correctAnswer: string | string[];\n  explanation?: string;\n  difficulty: 'easy' | 'medium' | 'hard';\n  topics: string[];\n  serviceCategory?: string;\n  awsServices?: string[];\n  keywords?: string[];\n  createdAt: string;\n  parsingConfidence?: number;\n  hasExplanation?: boolean;\n}\n\n// Raw question data from S3 (matches study_data_final.json structure)\nexport interface RawQuestionData {\n  question_number: number;\n  question: {\n    text: string;\n    options: string[][];\n    question_type: 'single_choice' | 'multiple_choice';\n    expected_answers: number;\n    topic: string;\n    service_category?: string;\n    aws_services?: string[];\n  };\n  answer?: {\n    correct_answer: string;\n    explanation?: string;\n    keywords?: string[];\n    parsing_confidence?: number;\n    source?: string;\n  };\n  study_metadata?: {\n    difficulty: 'easy' | 'medium' | 'hard';\n    completeness: string;\n    question_preview: string;\n    has_explanation: boolean;\n    confidence_level: string;\n  };\n}\n\n// Session Request/Response Types\nexport interface CreateSessionRequest {\n  provider: string;\n  exam: string;\n  config?: Partial<SessionConfiguration>;\n}\n\nexport interface UpdateSessionRequest {\n  config?: Partial<SessionConfiguration>;\n  status?: 'paused' | 'active';\n}\n\nexport interface SubmitAnswerRequest {\n  questionId: string;\n  answer: string | string[];\n  timeSpent?: number; // in seconds\n}\n\nexport interface SubmitAnswerResponse {\n  isCorrect: boolean;\n  correctAnswer: string | string[];\n  explanation?: string;\n  nextQuestion?: Question;\n  sessionProgress: SessionProgress;\n  sessionCompleted: boolean;\n}\n\nexport interface GetSessionResponse {\n  session: StudySession;\n  currentState?: SessionState;\n}\n\nexport interface ListSessionsRequest {\n  status?: 'active' | 'completed' | 'paused';\n  provider?: string;\n  exam?: string;\n  limit?: number;\n  lastEvaluatedKey?: string;\n}\n\nexport interface CompleteSessionResponse {\n  results: SessionResults;\n  achievements?: Achievement[];\n}\n\n// Achievement system for gamification\nexport interface Achievement {\n  id: string;\n  name: string;\n  description: string;\n  type: 'accuracy' | 'speed' | 'streak' | 'completion' | 'improvement';\n  criteria: any;\n  earnedAt: string;\n}\n\nexport interface CreateGoalRequest {\n  title: string;\n  description?: string;\n  targetDate: string;\n  questionsTarget: number;\n  accuracyTarget: number;\n}\n\n// ============================================================================\n// AI-POWERED STUDY FEATURES TYPES - Phase 5\n// ============================================================================\n\n// Enhanced Goal Types with AI Features\nexport interface EnhancedStudyGoal extends StudyGoal {\n  aiOptimized: boolean;\n  adaptiveSettings: {\n    difficultyLevel: 'adaptive' | 'fixed';\n    spacedRepetition: boolean;\n    personalizedSchedule: boolean;\n  };\n  milestones: GoalMilestone[];\n  studyPlan: StudyPlanReference;\n  aiRecommendations: AIRecommendation[];\n  learningPath: LearningPathNode[];\n  achievements: GoalAchievement[];\n  analyticsSnapshot: GoalAnalyticsSnapshot;\n}\n\nexport interface GoalMilestone {\n  milestoneId: string;\n  title: string;\n  description?: string;\n  targetDate: string;\n  completed: boolean;\n  completedAt?: string;\n  requirements: MilestoneRequirement[];\n  rewards: string[];\n  aiGenerated: boolean;\n}\n\nexport interface MilestoneRequirement {\n  type: 'accuracy' | 'questions' | 'time' | 'topics' | 'sessions';\n  target: number;\n  current: number;\n  description: string;\n}\n\nexport interface StudyPlanReference {\n  planId: string;\n  generatedAt: string;\n  duration: number; // days\n  adaptiveAdjustments: number;\n  lastOptimized: string;\n}\n\nexport interface AIRecommendation {\n  id: string;\n  type: 'study_schedule' | 'difficulty_adjustment' | 'topic_focus' | 'break_suggestion';\n  priority: 'high' | 'medium' | 'low';\n  title: string;\n  description: string;\n  reasoning: string;\n  actionItems: string[];\n  validUntil: string;\n  applied: boolean;\n  appliedAt?: string;\n  effectiveness?: number; // 0-100, measured after application\n}\n\nexport interface LearningPathNode {\n  nodeId: string;\n  topic: string;\n  estimatedTime: number; // minutes\n  prerequisites: string[];\n  completed: boolean;\n  completedAt?: string;\n  difficultyLevel: number; // 1-5\n  adaptiveWeight: number; // Higher weight = more important\n  nextReviewDate?: string; // For spaced repetition\n}\n\nexport interface GoalAchievement {\n  achievementId: string;\n  name: string;\n  description: string;\n  earnedAt: string;\n  category: 'progress' | 'consistency' | 'improvement' | 'mastery';\n  points: number;\n}\n\nexport interface GoalAnalyticsSnapshot {\n  lastUpdated: string;\n  currentAccuracy: number;\n  weeklyProgress: number;\n  studyVelocity: number; // questions per day\n  difficultyTrend: 'increasing' | 'decreasing' | 'stable';\n  topicMastery: { [topic: string]: number }; // 0-100 mastery score\n  predictedCompletionDate: string;\n  confidenceScore: number; // 0-100\n}\n\n// Spaced Repetition and Adaptive Learning Types\nexport interface SpacedRepetitionItem {\n  itemId: string;\n  userId: string;\n  conceptId: string; // Could be questionId, topicId, or skill\n  conceptType: 'question' | 'topic' | 'skill';\n  \n  // SM-2 Algorithm fields\n  easinessFactor: number; // 1.3 - 2.5, default 2.5\n  interval: number; // Days until next review\n  repetition: number; // Number of successful reviews\n  nextReviewDate: string;\n  \n  // Performance tracking\n  totalAttempts: number;\n  correctAttempts: number;\n  lastAttemptDate: string;\n  averageResponseTime: number; // milliseconds\n  masteryLevel: 'learning' | 'reviewing' | 'mastered';\n  \n  // Difficulty adaptation\n  currentDifficulty: number; // 0-100\n  optimalDifficulty: number; // Target difficulty for user\n  difficultyAdjustments: DifficultyAdjustment[];\n  \n  // Context and metadata\n  provider?: string;\n  exam?: string;\n  topic?: string;\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport interface DifficultyAdjustment {\n  adjustmentDate: string;\n  previousDifficulty: number;\n  newDifficulty: number;\n  reason: string;\n  performanceMetrics: {\n    accuracy: number;\n    responseTime: number;\n    confidence: number;\n  };\n}\n\nexport interface LearningSessionPlan {\n  planId: string;\n  userId: string;\n  sessionType: 'review' | 'learning' | 'mixed' | 'assessment';\n  \n  // Content selection\n  selectedItems: SpacedRepetitionItem[];\n  questionPool: Question[];\n  targetDifficulty: number;\n  adaptiveDifficultyEnabled: boolean;\n  \n  // Session parameters\n  estimatedDuration: number; // minutes\n  targetQuestions: number;\n  difficultyDistribution: {\n    easy: number;\n    medium: number;\n    hard: number;\n  };\n  \n  // Spaced repetition settings\n  reviewPriority: 'overdue' | 'due_today' | 'upcoming' | 'mixed';\n  newContentRatio: number; // 0-1, percentage of new vs review content\n  \n  // AI optimization\n  personalizedOrder: string[]; // Question IDs in optimized order\n  difficultyProgression: number[]; // Difficulty progression through session\n  breakSuggestions: number[]; // Suggested break points (question indices)\n  \n  createdAt: string;\n  validUntil: string;\n}\n\n// AI Recommendation System Types\nexport interface AIStudyRecommendation extends RecommendationItem {\n  confidence: number; // 0-100, confidence in recommendation\n  personalizedData: {\n    userPerformanceFactors: UserPerformanceFactors;\n    adaptiveLearningInsights: AdaptiveLearningInsights;\n    behavioralPatterns: BehavioralPatterns;\n  };\n  dynamicAdjustments: DynamicAdjustment[];\n  successMetrics: SuccessMetric[];\n  followUpActions: FollowUpAction[];\n}\n\nexport interface UserPerformanceFactors {\n  overallAccuracy: number;\n  accuracyTrend: 'improving' | 'stable' | 'declining';\n  strongTopics: string[];\n  weakTopics: string[];\n  averageStudyTime: number; // minutes per day\n  studyConsistency: number; // 0-100\n  difficultyPreference: 'easy' | 'medium' | 'hard' | 'adaptive';\n  learningVelocity: number; // questions mastered per week\n}\n\nexport interface AdaptiveLearningInsights {\n  spacedRepetitionEffectiveness: number; // 0-100\n  optimalReviewInterval: number; // hours\n  difficultyAdaptationSuccess: number; // 0-100\n  masteredConcepts: number;\n  strugglingConcepts: number;\n  overdueReviews: number;\n  predictedPerformanceGain: number; // Expected improvement with recommendation\n}\n\nexport interface BehavioralPatterns {\n  preferredStudyTimes: string[]; // e.g., ['morning', 'evening']\n  averageSessionLength: number; // minutes\n  studyFrequency: number; // sessions per week\n  breakPreferences: BreakPreference;\n  motivationFactors: MotivationFactor[];\n  procrastinationRisk: 'low' | 'medium' | 'high';\n  studyConsistency: number; // 0-100, consistency score\n}\n\nexport interface BreakPreference {\n  frequency: number; // minutes between breaks\n  duration: number; // break duration in minutes\n  type: 'short' | 'medium' | 'long';\n}\n\nexport interface MotivationFactor {\n  factor: 'achievements' | 'progress' | 'competition' | 'learning' | 'goals';\n  weight: number; // 0-1, importance to user\n  effectiveness: number; // 0-100, how well it works for user\n}\n\nexport interface DynamicAdjustment {\n  parameter: string;\n  originalValue: any;\n  adjustedValue: any;\n  reason: string;\n  expectedImpact: number; // 0-100\n}\n\nexport interface SuccessMetric {\n  metric: string;\n  currentValue: number;\n  targetValue: number;\n  timeframe: string; // e.g., '1 week', '1 month'\n  probability: number; // 0-100, probability of achieving target\n}\n\nexport interface FollowUpAction {\n  action: string;\n  timing: string; // when to perform action\n  condition: string; // condition that triggers action\n  priority: 'high' | 'medium' | 'low';\n}\n\n// Enhanced Study Plan Types\nexport interface AIStudyPlan extends StudyPlan {\n  aiOptimizations: {\n    personalizedScheduling: boolean;\n    adaptiveDifficulty: boolean;\n    spacedRepetitionIntegration: boolean;\n    behaviorBasedAdjustments: boolean;\n  };\n  performancePredictions: {\n    expectedAccuracyImprovement: number;\n    estimatedCompletionDate: string;\n    confidenceLevel: number;\n  };\n  contingencyPlans: ContingencyPlan[];\n  motivationalElements: MotivationalElement[];\n}\n\nexport interface ContingencyPlan {\n  trigger: string; // What triggers this plan\n  adjustments: string[]; // What adjustments to make\n  timeline: string; // How long to try adjustments\n}\n\nexport interface MotivationalElement {\n  type: 'achievement' | 'progress_visualization' | 'competition' | 'reward';\n  description: string;\n  triggerConditions: string[];\n  impact: 'high' | 'medium' | 'low';\n}\n\n// Performance Prediction and Analytics\nexport interface PerformancePrediction {\n  userId: string;\n  conceptId: string;\n  \n  // Predictions\n  predictedAccuracy: number; // 0-100\n  predictedResponseTime: number; // milliseconds\n  confidenceScore: number; // 0-100, confidence in predictions\n  \n  // Model factors\n  factors: {\n    historicalPerformance: number; // Weight: 40%\n    timeSinceLastPractice: number; // Weight: 20%\n    conceptDifficulty: number; // Weight: 15%\n    userSkillLevel: number; // Weight: 15%\n    contextualFactors: number; // Weight: 10%\n  };\n  \n  // Recommendations\n  recommendedAction: 'practice' | 'review' | 'skip' | 'intensive_study';\n  optimalTimingHours: number; // Optimal time until next practice\n  \n  calculatedAt: string;\n}\n\n// Recommendation Feedback System\nexport interface RecommendationFeedback {\n  recommendationId: string;\n  userId: string;\n  feedbackType: 'helpful' | 'not_helpful' | 'partially_helpful' | 'irrelevant';\n  effectiveness: number; // 0-100, how effective was the recommendation\n  appliedSuggestions: string[];\n  ignoredSuggestions: string[];\n  userComments?: string;\n  performanceChange: {\n    beforeAccuracy: number;\n    afterAccuracy: number;\n    beforeStudyTime: number;\n    afterStudyTime: number;\n    timeframe: string;\n  };\n  submittedAt: string;\n}\n\n// Achievement System for Gamification\nexport interface AchievementDefinition {\n  id: string;\n  name: string;\n  description: string;\n  type: 'accuracy' | 'speed' | 'streak' | 'completion' | 'improvement' | 'consistency';\n  criteria: AchievementCriteria;\n  points: number;\n  badge?: string;\n  rarity: 'common' | 'uncommon' | 'rare' | 'epic' | 'legendary';\n}\n\nexport interface AchievementCriteria {\n  metric: string;\n  threshold: number;\n  timeframe?: string;\n  conditions?: { [key: string]: any };\n}\n\nexport interface UserAchievementProgress {\n  userId: string;\n  achievementId: string;\n  currentProgress: number;\n  targetProgress: number;\n  progressPercentage: number;\n  isCompleted: boolean;\n  completedAt?: string;\n  lastUpdated: string;\n}\n\n// Study Session Enhancement Types\nexport interface EnhancedStudySession extends StudySession {\n  aiEnhancements: {\n    adaptiveDifficultyEnabled: boolean;\n    spacedRepetitionIntegrated: boolean;\n    personalizedOrdering: boolean;\n    realTimeAdjustments: boolean;\n  };\n  learningMetrics: {\n    conceptsMastered: string[];\n    conceptsReviewed: string[];\n    difficultyAdjustments: DifficultyAdjustment[];\n    optimalBreakPoints: number[];\n    retentionPrediction: number; // 0-100\n  };\n  aiRecommendations: {\n    nextSessionType: 'review' | 'learning' | 'mixed' | 'assessment';\n    optimalTimingHours: number;\n    suggestedTopics: string[];\n    difficultyRecommendation: 'increase' | 'decrease' | 'maintain';\n  };\n}\n\n// API Request/Response Types for AI Features\nexport interface GenerateRecommendationsRequest {\n  includeStudyPlan?: boolean;\n  planDuration?: number; // days\n  focusAreas?: string[];\n  urgency?: 'low' | 'medium' | 'high';\n  timeAvailable?: number; // minutes per day\n}\n\nexport interface GenerateRecommendationsResponse {\n  recommendations: AIStudyRecommendation[];\n  studyPlan?: AIStudyPlan;\n  lastUpdated: string;\n  metadata: {\n    totalRecommendations: number;\n    highPriorityCount: number;\n    averageConfidence: number;\n    planIncluded: boolean;\n  };\n}\n\nexport interface SessionRecommendationsRequest {\n  availableTime: number; // minutes\n  preferredDifficulty?: 'easy' | 'medium' | 'hard' | 'adaptive';\n  focusTopics?: string[];\n  sessionType?: 'review' | 'learning' | 'mixed' | 'assessment';\n}\n\nexport interface SessionRecommendationsResponse {\n  sessionPlan: LearningSessionPlan;\n  recommendations: AIStudyRecommendation[];\n  sessionInfo: {\n    estimatedDuration: number;\n    targetQuestions: number;\n    sessionType: string;\n    difficultyDistribution: { easy: number; medium: number; hard: number };\n    breakSuggestions: number[];\n    personalizedOrder: boolean;\n  };\n}\n\n// Learning Analytics Enhancement\nexport interface LearningAnalytics extends UserProgressAnalytics {\n  aiInsights: {\n    learningEfficiency: number; // 0-100\n    retentionRate: number; // 0-100\n    optimalStudyPattern: string;\n    predictedPerformance: PerformancePrediction[];\n    recommendedAdjustments: string[];\n  };\n  adaptiveLearningStats: {\n    spacedRepetitionItems: number;\n    masteryProgression: { [concept: string]: number };\n    difficultyAdaptationSuccess: number;\n    overallLearningVelocity: number;\n  };\n}\n\nexport interface GetQuestionsRequest {\n  provider: string;\n  exam: string;\n  limit?: number;\n  offset?: number;\n  difficulty?: 'easy' | 'medium' | 'hard';\n  topics?: string[];\n  serviceCategory?: string;\n  awsServices?: string[];\n  search?: string;\n  hasExplanation?: boolean;\n  questionType?: 'single_choice' | 'multiple_choice';\n}\n\nexport interface QuestionFilter {\n  difficulty?: 'easy' | 'medium' | 'hard';\n  topics?: string[];\n  serviceCategory?: string;\n  awsServices?: string[];\n  search?: string;\n  hasExplanation?: boolean;\n  questionType?: 'single_choice' | 'multiple_choice';\n}\n\nexport interface PaginationOptions {\n  limit: number;\n  offset: number;\n}\n\nexport interface QuestionSearchResult {\n  questions: Question[];\n  totalCount: number;\n  hasMore: boolean;\n  filters: {\n    availableTopics: string[];\n    availableServiceCategories: string[];\n    availableAwsServices: string[];\n    difficultyDistribution: { [key: string]: number };\n  };\n}\n\n// ============================================================================\n// ANALYTICS TYPES - Phase 4: Analytics & Progress Tracking\n// ============================================================================\n\n// User Progress Analytics\nexport interface UserProgressAnalytics {\n  userId: string;\n  overallStats: OverallProgressStats;\n  providerStats: ProviderProgressStats[];\n  examStats: ExamProgressStats[];\n  recentActivity: RecentActivityStats;\n  achievements: Achievement[];\n  calculatedAt: string;\n}\n\nexport interface OverallProgressStats {\n  totalSessions: number;\n  completedSessions: number;\n  totalQuestions: number;\n  correctAnswers: number;\n  overallAccuracy: number;\n  totalStudyTime: number; // in seconds\n  averageSessionScore: number;\n  bestSessionScore: number;\n  currentStreak: number;\n  longestStreak: number;\n  lastActivityDate: string;\n  studyDaysCount: number;\n}\n\nexport interface ProviderProgressStats {\n  provider: string;\n  totalSessions: number;\n  completedSessions: number;\n  totalQuestions: number;\n  correctAnswers: number;\n  accuracy: number;\n  studyTime: number;\n  averageScore: number;\n  bestScore: number;\n  lastSessionDate?: string;\n  exams: ExamProgressStats[];\n}\n\nexport interface ExamProgressStats {\n  provider: string;\n  exam: string;\n  totalSessions: number;\n  completedSessions: number;\n  totalQuestions: number;\n  correctAnswers: number;\n  accuracy: number;\n  studyTime: number;\n  averageScore: number;\n  bestScore: number;\n  lastSessionDate?: string;\n  readinessScore: number; // 0-100, calculated readiness for this exam\n  topicMastery: TopicMasteryStats[];\n}\n\nexport interface TopicMasteryStats {\n  topic: string;\n  questionsAnswered: number;\n  correctAnswers: number;\n  accuracy: number;\n  masteryLevel: 'beginner' | 'intermediate' | 'advanced' | 'expert';\n  confidenceScore: number; // 0-100\n  lastPracticed?: string;\n  improvementTrend: 'improving' | 'stable' | 'declining';\n}\n\nexport interface RecentActivityStats {\n  last7Days: DailyActivityStats[];\n  last30Days: DailyActivityStats[];\n  currentWeekStats: WeeklyActivityStats;\n  currentMonthStats: MonthlyActivityStats;\n}\n\nexport interface DailyActivityStats {\n  date: string; // YYYY-MM-DD\n  sessionsCount: number;\n  questionsAnswered: number;\n  correctAnswers: number;\n  studyTimeMinutes: number;\n  accuracy: number;\n}\n\nexport interface WeeklyActivityStats {\n  weekStartDate: string;\n  totalSessions: number;\n  totalQuestions: number;\n  totalCorrect: number;\n  totalStudyTime: number;\n  averageAccuracy: number;\n  studyDays: number;\n}\n\nexport interface MonthlyActivityStats {\n  month: string; // YYYY-MM\n  totalSessions: number;\n  totalQuestions: number;\n  totalCorrect: number;\n  totalStudyTime: number;\n  averageAccuracy: number;\n  studyDays: number;\n}\n\n// Performance Metrics and Trends\nexport interface PerformanceMetrics {\n  userId: string;\n  timeRange: 'week' | 'month' | 'quarter' | 'year' | 'all';\n  trends: PerformanceTrends;\n  comparisons: PerformanceComparisons;\n  insights: PerformanceInsights;\n  calculatedAt: string;\n}\n\nexport interface PerformanceTrends {\n  accuracyTrend: TrendData[];\n  speedTrend: TrendData[];\n  studyTimeTrend: TrendData[];\n  sessionCompletionTrend: TrendData[];\n  difficultyProgressionTrend: DifficultyTrendData[];\n}\n\nexport interface TrendData {\n  date: string;\n  value: number;\n  change?: number; // percentage change from previous period\n}\n\nexport interface DifficultyTrendData {\n  date: string;\n  easy: { accuracy: number; count: number };\n  medium: { accuracy: number; count: number };\n  hard: { accuracy: number; count: number };\n}\n\nexport interface PerformanceComparisons {\n  vsLastPeriod: ComparisonData;\n  vsPersonalBest: ComparisonData;\n  vsAverageUser: ComparisonData; // if available\n}\n\nexport interface ComparisonData {\n  accuracy: { current: number; comparison: number; change: number };\n  speed: { current: number; comparison: number; change: number };\n  studyTime: { current: number; comparison: number; change: number };\n  completion: { current: number; comparison: number; change: number };\n}\n\nexport interface PerformanceInsights {\n  strengths: string[];\n  weaknesses: string[];\n  recommendations: string[];\n  milestoneProgress: MilestoneProgress[];\n}\n\nexport interface MilestoneProgress {\n  milestone: string;\n  description: string;\n  progress: number; // 0-100\n  target: number;\n  current: number;\n  estimatedCompletion?: string;\n}\n\n// Session Analytics and History\nexport interface SessionAnalyticsData {\n  userId: string;\n  sessions: SessionSummary[];\n  aggregatedStats: SessionAggregatedStats;\n  patterns: SessionPatterns;\n  calculatedAt: string;\n}\n\nexport interface SessionSummary {\n  sessionId: string;\n  provider: string;\n  exam: string;\n  startTime: string;\n  endTime?: string;\n  duration: number; // in seconds\n  status: 'active' | 'completed' | 'paused' | 'expired';\n  score: number;\n  questionsTotal: number;\n  questionsCorrect: number;\n  accuracy: number;\n  averageTimePerQuestion: number;\n  difficultyBreakdown: {\n    easy: { correct: number; total: number };\n    medium: { correct: number; total: number };\n    hard: { correct: number; total: number };\n  };\n}\n\nexport interface SessionAggregatedStats {\n  totalSessions: number;\n  completedSessions: number;\n  averageScore: number;\n  averageDuration: number;\n  averageAccuracy: number;\n  bestPerformance: SessionSummary;\n  recentPerformance: SessionSummary[];\n}\n\nexport interface SessionPatterns {\n  preferredStudyTimes: TimeOfDayPattern[];\n  sessionLengthDistribution: SessionLengthPattern;\n  accuracyByTimeOfDay: TimeOfDayAccuracy[];\n  studyStreak: StreakData;\n}\n\nexport interface TimeOfDayPattern {\n  hour: number;\n  sessionCount: number;\n  averageAccuracy: number;\n}\n\nexport interface SessionLengthPattern {\n  short: number; // < 15 minutes\n  medium: number; // 15-60 minutes\n  long: number; // > 60 minutes\n}\n\nexport interface TimeOfDayAccuracy {\n  timeRange: string; // e.g., \"09:00-12:00\"\n  averageAccuracy: number;\n  sessionCount: number;\n}\n\nexport interface StreakData {\n  currentStreak: number;\n  longestStreak: number;\n  streakDates: string[];\n}\n\n// Cross-Provider Comparison Analytics\nexport interface CrossProviderAnalytics {\n  userId: string;\n  providerComparisons: ProviderComparison[];\n  skillTransferability: SkillTransferAnalysis[];\n  recommendations: CrossProviderRecommendations;\n  calculatedAt: string;\n}\n\nexport interface ProviderComparison {\n  provider: string;\n  totalQuestions: number;\n  accuracy: number;\n  averageScore: number;\n  studyTime: number;\n  completionRate: number;\n  strengthAreas: string[];\n  weaknessAreas: string[];\n  relativePerformance: number; // compared to user's average across all providers\n}\n\nexport interface SkillTransferAnalysis {\n  sharedTopic: string;\n  providers: string[];\n  consistencyScore: number; // 0-100, how consistent performance is across providers\n  averageAccuracy: number;\n  recommendations: string[];\n}\n\nexport interface CrossProviderRecommendations {\n  suggestedFocusProvider: string;\n  reasonForSuggestion: string;\n  skillGapAreas: string[];\n  strengthLeverageOpportunities: string[];\n}\n\n// Predictive Analytics for Exam Readiness\nexport interface ExamReadinessAssessment {\n  userId: string;\n  provider: string;\n  exam: string;\n  readinessScore: number; // 0-100\n  confidence: 'low' | 'medium' | 'high';\n  prediction: ReadinessPrediction;\n  factors: ReadinessFactors;\n  timeline: ReadinessTimeline;\n  calculatedAt: string;\n}\n\nexport interface ReadinessPrediction {\n  passLikelihood: number; // 0-100\n  recommendedWaitTime: number; // days before attempting real exam\n  minimumStudyHours: number;\n  targetAccuracy: number;\n}\n\nexport interface ReadinessFactors {\n  currentAccuracy: { value: number; weight: number; impact: 'positive' | 'negative' | 'neutral' };\n  topicCoverage: { value: number; weight: number; impact: 'positive' | 'negative' | 'neutral' };\n  consistencyScore: { value: number; weight: number; impact: 'positive' | 'negative' | 'neutral' };\n  recentPerformance: { value: number; weight: number; impact: 'positive' | 'negative' | 'neutral' };\n  studyVolume: { value: number; weight: number; impact: 'positive' | 'negative' | 'neutral' };\n  timeSpent: { value: number; weight: number; impact: 'positive' | 'negative' | 'neutral' };\n}\n\nexport interface ReadinessTimeline {\n  currentLevel: ReadinessLevel;\n  milestones: ReadinessMilestone[];\n  projectedReadyDate: string;\n}\n\nexport interface ReadinessLevel {\n  level: 'beginner' | 'intermediate' | 'advanced' | 'ready';\n  description: string;\n  requirements: string[];\n}\n\nexport interface ReadinessMilestone {\n  milestone: string;\n  description: string;\n  targetDate: string;\n  completed: boolean;\n  requirements: string[];\n}\n\n// Study Recommendations System\nexport interface StudyRecommendations {\n  userId: string;\n  recommendations: RecommendationItem[];\n  priorityActions: PriorityAction[];\n  studyPlan: StudyPlan;\n  calculatedAt: string;\n}\n\nexport interface RecommendationItem {\n  id: string;\n  type: 'topic_focus' | 'difficulty_adjustment' | 'study_pattern' | 'exam_preparation' | 'skill_development';\n  priority: 'high' | 'medium' | 'low';\n  title: string;\n  description: string;\n  reasoning: string;\n  actionItems: string[];\n  estimatedImpact: number; // 0-100\n  estimatedTimeInvestment: number; // in hours\n  applicableProviders: string[];\n  applicableExams: string[];\n}\n\nexport interface PriorityAction {\n  action: string;\n  description: string;\n  timeframe: string;\n  expectedOutcome: string;\n}\n\nexport interface StudyPlan {\n  planId: string;\n  duration: number; // in days\n  dailyTargets: DailyStudyTarget[];\n  weeklyGoals: WeeklyStudyGoal[];\n  milestones: StudyMilestone[];\n}\n\nexport interface DailyStudyTarget {\n  date: string;\n  targetQuestions: number;\n  targetAccuracy: number;\n  recommendedTopics: string[];\n  estimatedTime: number; // in minutes\n}\n\nexport interface WeeklyStudyGoal {\n  weekStartDate: string;\n  focusAreas: string[];\n  targetSessions: number;\n  targetQuestions: number;\n  targetAccuracy: number;\n}\n\nexport interface StudyMilestone {\n  milestone: string;\n  targetDate: string;\n  criteria: MilestoneCriteria;\n  rewards: string[];\n}\n\nexport interface MilestoneCriteria {\n  minimumSessions: number;\n  minimumAccuracy: number;\n  requiredTopics: string[];\n  requiredQuestions: number;\n}\n\n// Analytics API Request/Response Types\nexport interface GetProgressAnalyticsRequest {\n  timeRange?: 'week' | 'month' | 'quarter' | 'year' | 'all';\n  includeProviders?: string[];\n  includeExams?: string[];\n}\n\nexport interface GetPerformanceMetricsRequest {\n  timeRange: 'week' | 'month' | 'quarter' | 'year' | 'all';\n  includeComparisons?: boolean;\n  includeTrends?: boolean;\n}\n\nexport interface GetSessionAnalyticsRequest {\n  timeRange?: 'week' | 'month' | 'quarter' | 'year' | 'all';\n  provider?: string;\n  exam?: string;\n  status?: 'active' | 'completed' | 'paused';\n  limit?: number;\n  lastEvaluatedKey?: string;\n}\n\nexport interface GetTopicAnalyticsRequest {\n  provider?: string;\n  exam?: string;\n  topics?: string[];\n  timeRange?: 'week' | 'month' | 'quarter' | 'year' | 'all';\n}\n\nexport interface GetReadinessAssessmentRequest {\n  provider: string;\n  exam: string;\n  includeTimeline?: boolean;\n  includeDetailedFactors?: boolean;\n}\n\nexport interface GetRecommendationsRequest {\n  includeStudyPlan?: boolean;\n  planDuration?: number; // in days\n  focusAreas?: string[];\n}\n\nexport interface GetComparisonAnalyticsRequest {\n  providers?: string[];\n  includeSkillTransfer?: boolean;\n  includeRecommendations?: boolean;\n}\n\n// Analytics Storage Types for DynamoDB\nexport interface AnalyticsRecord {\n  PK: string; // Partition Key: userId\n  SK: string; // Sort Key: analyticsType#provider#exam#date\n  userId: string;\n  analyticsType: 'progress' | 'performance' | 'session' | 'topic' | 'readiness' | 'recommendation';\n  provider?: string;\n  exam?: string;\n  data: any;\n  calculatedAt: string;\n  expiresAt: number; // TTL\n}\n\nexport interface AnalyticsAggregation {\n  PK: string; // Partition Key: userId#provider#exam\n  SK: string; // Sort Key: aggregationType#date\n  aggregationType: 'daily' | 'weekly' | 'monthly' | 'quarterly' | 'yearly';\n  date: string;\n  data: {\n    sessions: number;\n    questions: number;\n    correct: number;\n    studyTime: number;\n    averageAccuracy: number;\n  };\n  expiresAt: number; // TTL\n}\n\n// ============================================================================\n// HEALTH & MONITORING TYPES - Phase 6: System Health & Monitoring\n// ============================================================================\n\n// System Health Types\nexport interface SystemHealthCheck {\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  timestamp: string;\n  environment: EnvironmentInfo;\n  dependencies: DependencyHealth;\n  performance: HealthPerformanceMetrics;\n  dataQuality: DataQualityStatus;\n  alerts: HealthAlert[];\n  recommendations: string[];\n}\n\nexport interface EnvironmentInfo {\n  stage: string;\n  version: string;\n  region: string;\n  functionName: string;\n  memorySize: string;\n  logLevel: string;\n  uptime: number; // in seconds\n  coldStart: boolean;\n}\n\nexport interface DependencyHealth {\n  dynamodb: DatabaseHealthStatus;\n  s3: S3HealthStatus;\n  external: ExternalServiceHealthStatus[];\n  overall: 'healthy' | 'degraded' | 'unhealthy';\n}\n\nexport interface DatabaseHealthStatus {\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  tables: TableHealthStatus[];\n  connectivity: {\n    canConnect: boolean;\n    responseTime: number; // in milliseconds\n    lastChecked: string;\n  };\n  performance: {\n    readLatency: number;\n    writeLatency: number;\n    throughputUtilization: number; // percentage\n    errorRate: number; // percentage\n  };\n  capacity: {\n    consumedReadCapacity: number;\n    consumedWriteCapacity: number;\n    provisionedReadCapacity: number;\n    provisionedWriteCapacity: number;\n    utilizationPercentage: number;\n  };\n}\n\nexport interface TableHealthStatus {\n  tableName: string;\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  itemCount?: number;\n  sizeBytes?: number;\n  readCapacityUtilization: number;\n  writeCapacityUtilization: number;\n  gsiStatus?: GSIHealthStatus[];\n  errors: string[];\n}\n\nexport interface GSIHealthStatus {\n  indexName: string;\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  readCapacityUtilization: number;\n  writeCapacityUtilization: number;\n}\n\nexport interface S3HealthStatus {\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  buckets: S3BucketHealthStatus[];\n  connectivity: {\n    canConnect: boolean;\n    responseTime: number;\n    lastChecked: string;\n  };\n  performance: {\n    uploadLatency: number;\n    downloadLatency: number;\n    errorRate: number;\n  };\n}\n\nexport interface S3BucketHealthStatus {\n  bucketName: string;\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  accessible: boolean;\n  objectCount?: number;\n  sizeBytes?: number;\n  errors: string[];\n}\n\nexport interface ExternalServiceHealthStatus {\n  serviceName: string;\n  url: string;\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  responseTime: number;\n  statusCode?: number;\n  lastChecked: string;\n  uptime: number; // percentage over last 24 hours\n  errors: string[];\n}\n\n// Performance Monitoring Types for Health System\nexport interface HealthPerformanceMetrics {\n  memory: MemoryMetrics;\n  execution: ExecutionMetrics;\n  throughput: ThroughputMetrics;\n  errors: ErrorMetrics;\n  trends: HealthPerformanceTrends;\n}\n\nexport interface MemoryMetrics {\n  current: number; // MB\n  peak: number; // MB\n  limit: number; // MB\n  utilizationPercentage: number;\n  gcFrequency: number; // garbage collections per minute\n}\n\nexport interface ExecutionMetrics {\n  coldStartFrequency: number; // percentage of executions\n  averageExecutionTime: number; // milliseconds\n  p95ExecutionTime: number; // milliseconds\n  p99ExecutionTime: number; // milliseconds\n  timeouts: number; // count over last hour\n}\n\nexport interface ThroughputMetrics {\n  requestsPerSecond: number;\n  requestsPerMinute: number;\n  requestsPerHour: number;\n  peakThroughput: number;\n  averageResponseTime: number; // milliseconds\n}\n\nexport interface ErrorMetrics {\n  errorRate: number; // percentage over last hour\n  errorCount: number; // count over last hour\n  errorsByType: { [errorType: string]: number };\n  criticalErrors: number;\n  warnings: number;\n}\n\nexport interface HealthPerformanceTrends {\n  responseTimeTrend: 'improving' | 'stable' | 'degrading';\n  errorRateTrend: 'improving' | 'stable' | 'degrading';\n  throughputTrend: 'increasing' | 'stable' | 'decreasing';\n  memoryUsageTrend: 'improving' | 'stable' | 'degrading';\n}\n\n// Data Quality Types\nexport interface DataQualityStatus {\n  overall: 'excellent' | 'good' | 'fair' | 'poor';\n  checks: DataQualityCheck[];\n  lastAssessment: string;\n  trends: DataQualityTrends;\n}\n\nexport interface DataQualityCheck {\n  checkName: string;\n  table: string;\n  status: 'passed' | 'warning' | 'failed';\n  result: {\n    expected: number | string;\n    actual: number | string;\n    threshold?: number;\n  };\n  lastChecked: string;\n  impact: 'low' | 'medium' | 'high' | 'critical';\n  description: string;\n}\n\nexport interface DataQualityTrends {\n  dataConsistency: 'improving' | 'stable' | 'degrading';\n  dataCompleteness: 'improving' | 'stable' | 'degrading';\n  dataAccuracy: 'improving' | 'stable' | 'degrading';\n  dataDuplication: 'improving' | 'stable' | 'degrading';\n}\n\n// Health Alert Types\nexport interface HealthAlert {\n  alertId: string;\n  severity: 'info' | 'warning' | 'error' | 'critical';\n  category: 'performance' | 'availability' | 'data_quality' | 'security' | 'capacity';\n  title: string;\n  description: string;\n  source: string; // service or component that generated the alert\n  threshold?: {\n    metric: string;\n    value: number;\n    comparison: 'greater_than' | 'less_than' | 'equals';\n  };\n  currentValue: number | string;\n  impact: string;\n  recommendations: string[];\n  createdAt: string;\n  resolvedAt?: string;\n  acknowledged: boolean;\n  acknowledgedBy?: string;\n  tags: string[];\n}\n\nexport interface AlertThreshold {\n  metric: string;\n  warningThreshold: number;\n  errorThreshold: number;\n  criticalThreshold: number;\n  comparison: 'greater_than' | 'less_than';\n  enabled: boolean;\n}\n\n// Health History and Reporting Types\nexport interface HealthHistoryEntry {\n  timestamp: string;\n  overallStatus: 'healthy' | 'degraded' | 'unhealthy';\n  componentStatuses: { [component: string]: 'healthy' | 'degraded' | 'unhealthy' };\n  metrics: {\n    responseTime: number;\n    errorRate: number;\n    throughput: number;\n    memoryUsage: number;\n  };\n  alerts: number; // count of active alerts\n  incidents: number; // count of active incidents\n}\n\nexport interface HealthReport {\n  reportId: string;\n  generatedAt: string;\n  timeRange: {\n    start: string;\n    end: string;\n    duration: string; // e.g., '24h', '7d', '30d'\n  };\n  summary: {\n    overallHealth: 'excellent' | 'good' | 'fair' | 'poor';\n    uptimePercentage: number;\n    totalIncidents: number;\n    resolvedIncidents: number;\n    averageResponseTime: number;\n    errorRate: number;\n  };\n  trends: {\n    availabilityTrend: 'improving' | 'stable' | 'degrading';\n    performanceTrend: 'improving' | 'stable' | 'degrading';\n    errorTrend: 'improving' | 'stable' | 'degrading';\n    dataQualityTrend: 'improving' | 'stable' | 'degrading';\n  };\n  topIssues: HealthAlert[];\n  recommendations: SystemRecommendation[];\n  history: HealthHistoryEntry[];\n}\n\nexport interface SystemRecommendation {\n  id: string;\n  priority: 'high' | 'medium' | 'low';\n  category: 'performance' | 'reliability' | 'cost' | 'security';\n  title: string;\n  description: string;\n  reasoning: string;\n  actionItems: string[];\n  estimatedImpact: {\n    performance: number; // percentage improvement\n    cost: number; // dollar savings or cost\n    reliability: number; // uptime improvement percentage\n  };\n  effort: 'low' | 'medium' | 'high';\n  timeline: string;\n}\n\n// Health Check Configuration Types\nexport interface HealthCheckConfig {\n  enabled: boolean;\n  interval: number; // seconds between checks\n  timeout: number; // seconds before timeout\n  retries: number;\n  dependencies: {\n    dynamodb: {\n      enabled: boolean;\n      tables: string[];\n      performanceChecks: boolean;\n    };\n    s3: {\n      enabled: boolean;\n      buckets: string[];\n      performanceChecks: boolean;\n    };\n    external: {\n      enabled: boolean;\n      services: ExternalServiceConfig[];\n    };\n  };\n  dataQuality: {\n    enabled: boolean;\n    checks: DataQualityCheckConfig[];\n  };\n  alerts: {\n    enabled: boolean;\n    thresholds: AlertThreshold[];\n  };\n}\n\nexport interface ExternalServiceConfig {\n  name: string;\n  url: string;\n  method: 'GET' | 'POST' | 'HEAD';\n  headers?: { [key: string]: string };\n  timeout: number;\n  expectedStatusCode: number;\n}\n\nexport interface DataQualityCheckConfig {\n  name: string;\n  table: string;\n  checkType: 'count' | 'consistency' | 'completeness' | 'accuracy' | 'duplication';\n  query: string; // DynamoDB query or expression\n  expectedValue?: number | string;\n  threshold?: number;\n  critical: boolean;\n}\n\n// Health API Request/Response Types\nexport interface GetHealthRequest {\n  includeDetails?: boolean;\n  includeHistory?: boolean;\n  components?: string[];\n}\n\nexport interface GetHealthResponse {\n  health: SystemHealthCheck;\n  history?: HealthHistoryEntry[];\n  uptime: {\n    current: number; // percentage\n    last24h: number;\n    last7d: number;\n    last30d: number;\n  };\n}\n\nexport interface GetHealthPerformanceMetricsRequest {\n  timeRange?: 'hour' | 'day' | 'week' | 'month';\n  metrics?: string[];\n  includeHistorical?: boolean;\n}\n\nexport interface GetHealthPerformanceMetricsResponse {\n  current: HealthPerformanceMetrics;\n  historical?: { [timestamp: string]: HealthPerformanceMetrics };\n  trends: HealthPerformanceTrends;\n}\n\nexport interface GetAlertsRequest {\n  severity?: 'info' | 'warning' | 'error' | 'critical';\n  category?: 'performance' | 'availability' | 'data_quality' | 'security' | 'capacity';\n  status?: 'active' | 'resolved' | 'acknowledged';\n  limit?: number;\n}\n\nexport interface GetAlertsResponse {\n  alerts: HealthAlert[];\n  summary: {\n    total: number;\n    active: number;\n    resolved: number;\n    acknowledged: number;\n    bySeverity: { [severity: string]: number };\n    byCategory: { [category: string]: number };\n  };\n}\n\nexport interface GetHealthHistoryRequest {\n  timeRange: 'hour' | 'day' | 'week' | 'month';\n  resolution?: 'minute' | 'hour' | 'day';\n  components?: string[];\n}\n\nexport interface GetHealthHistoryResponse {\n  entries: HealthHistoryEntry[];\n  summary: {\n    totalDataPoints: number;\n    averageHealth: number; // 0-100 score\n    incidents: number;\n    majorOutages: number;\n  };\n}\n\nexport interface GenerateHealthReportRequest {\n  timeRange: {\n    start: string;\n    end: string;\n  };\n  includeRecommendations?: boolean;\n  format?: 'json' | 'summary';\n}\n\nexport interface GenerateHealthReportResponse {\n  report: HealthReport;\n  downloadUrl?: string; // if format is not json\n}", "import { APIGatewayProxyResult } from 'aws-lambda';\nimport { ApiResponse, ErrorCode } from '../types';\n\n/**\n * Enhanced Response Builder - V2\n * Provides consistent API responses with proper CORS headers\n */\nexport class ResponseBuilder {\n  private static readonly VERSION = '2.0.0';\n\n  private static readonly CORS_HEADERS = {\n    'Content-Type': 'application/json',\n    'Access-Control-Allow-Origin': '*', // Configure specific origins in production\n    'Access-Control-Allow-Headers': 'Content-Type,Authorization,X-Amz-Date,X-Api-Key,X-Amz-Security-Token,X-Amz-User-Agent,X-Auth-Token',\n    'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS,HEAD',\n    'Access-Control-Allow-Credentials': 'true',\n    'Cache-Control': 'no-cache, no-store, must-revalidate',\n    'Pragma': 'no-cache',\n    'Expires': '0'\n  };\n\n  /**\n   * Create successful response\n   */\n  public static success<T>(\n    data: T, \n    statusCode: number = 200,\n    message?: string\n  ): APIGatewayProxyResult {\n    const response: ApiResponse<T> = {\n      success: true,\n      data,\n      message,\n      timestamp: new Date().toISOString(),\n      version: this.VERSION\n    };\n\n    return {\n      statusCode,\n      headers: this.CORS_HEADERS,\n      body: JSON.stringify(response)\n    };\n  }\n\n  /**\n   * Create error response\n   */\n  public static error(\n    message: string,\n    code: ErrorCode = ErrorCode.INTERNAL_ERROR,\n    details?: any,\n    statusCode: number = 500\n  ): APIGatewayProxyResult {\n    const response: ApiResponse = {\n      success: false,\n      error: message,\n      message: `[${code}] ${message}`,\n      timestamp: new Date().toISOString(),\n      version: this.VERSION,\n      ...(details && { data: details })\n    };\n\n    return {\n      statusCode,\n      headers: this.CORS_HEADERS,\n      body: JSON.stringify(response)\n    };\n  }\n\n  /**\n   * Bad Request (400)\n   */\n  public static badRequest(message: string, details?: any): APIGatewayProxyResult {\n    return this.error(message, ErrorCode.VALIDATION_ERROR, details, 400);\n  }\n\n  /**\n   * Unauthorized (401)\n   */\n  public static unauthorized(message: string = 'Unauthorized'): APIGatewayProxyResult {\n    return this.error(message, ErrorCode.UNAUTHORIZED, undefined, 401);\n  }\n\n  /**\n   * Forbidden (403)\n   */\n  public static forbidden(message: string = 'Forbidden'): APIGatewayProxyResult {\n    return this.error(message, ErrorCode.FORBIDDEN, undefined, 403);\n  }\n\n  /**\n   * Not Found (404)\n   */\n  public static notFound(message: string = 'Resource not found'): APIGatewayProxyResult {\n    return this.error(message, ErrorCode.NOT_FOUND, undefined, 404);\n  }\n\n  /**\n   * Rate Limited (429)\n   */\n  public static rateLimited(message: string = 'Rate limit exceeded'): APIGatewayProxyResult {\n    return this.error(message, ErrorCode.RATE_LIMITED, undefined, 429);\n  }\n\n  /**\n   * Internal Server Error (500)\n   */\n  public static internalError(message: string = 'Internal server error'): APIGatewayProxyResult {\n    return this.error(message, ErrorCode.INTERNAL_ERROR, undefined, 500);\n  }\n\n  /**\n   * CORS preflight response\n   */\n  public static cors(): APIGatewayProxyResult {\n    return {\n      statusCode: 200,\n      headers: {\n        ...this.CORS_HEADERS,\n        'Access-Control-Max-Age': '86400' // Cache preflight for 24 hours\n      },\n      body: ''\n    };\n  }\n\n  /**\n   * Health check response\n   */\n  public static health(data: any): APIGatewayProxyResult {\n    return this.success({\n      status: 'healthy',\n      timestamp: new Date().toISOString(),\n      version: this.VERSION,\n      environment: process.env.STAGE || 'unknown',\n      ...data\n    });\n  }\n\n  /**\n   * Paginated response\n   */\n  public static paginated<T>(\n    items: T[],\n    totalCount: number,\n    page: number,\n    pageSize: number,\n    message?: string\n  ): APIGatewayProxyResult {\n    const totalPages = Math.ceil(totalCount / pageSize);\n    const hasNextPage = page < totalPages;\n    const hasPrevPage = page > 1;\n\n    return this.success({\n      items,\n      pagination: {\n        totalCount,\n        totalPages,\n        currentPage: page,\n        pageSize,\n        hasNextPage,\n        hasPrevPage\n      }\n    }, 200, message);\n  }\n}", "/**\n * Structured Logger - V2\n * Provides consistent logging across all Lambda functions\n */\nexport class Logger {\n  private readonly context: string;\n  private readonly logLevel: string;\n\n  constructor(context: string) {\n    this.context = context;\n    this.logLevel = process.env.LOG_LEVEL || 'INFO';\n  }\n\n  /**\n   * Info level logging\n   */\n  public info(message: string, data?: any): void {\n    if (this.shouldLog('INFO')) {\n      this.log('INFO', message, data);\n    }\n  }\n\n  /**\n   * Debug level logging\n   */\n  public debug(message: string, data?: any): void {\n    if (this.shouldLog('DEBUG')) {\n      this.log('DEBUG', message, data);\n    }\n  }\n\n  /**\n   * Warning level logging\n   */\n  public warn(message: string, data?: any): void {\n    if (this.shouldLog('WARN')) {\n      this.log('WARN', message, data);\n    }\n  }\n\n  /**\n   * Error level logging\n   */\n  public error(message: string, error?: any): void {\n    const errorData = error instanceof Error ? {\n      name: error.name,\n      message: error.message,\n      stack: error.stack\n    } : error;\n\n    this.log('ERROR', message, errorData);\n  }\n\n  /**\n   * Performance logging\n   */\n  public perf(operation: string, duration: number, data?: any): void {\n    this.info(`Performance: ${operation}`, {\n      duration: `${duration}ms`,\n      operation,\n      ...data\n    });\n  }\n\n  /**\n   * Core logging method\n   */\n  private log(level: string, message: string, data?: any): void {\n    const logEntry = {\n      timestamp: new Date().toISOString(),\n      level,\n      context: this.context,\n      message,\n      stage: process.env.STAGE || 'unknown',\n      version: '2.0.0',\n      ...(data && { data })\n    };\n\n    // Use console methods for CloudWatch integration\n    switch (level) {\n      case 'ERROR':\n        console.error(JSON.stringify(logEntry));\n        break;\n      case 'WARN':\n        console.warn(JSON.stringify(logEntry));\n        break;\n      default:\n        console.log(JSON.stringify(logEntry));\n    }\n  }\n\n  /**\n   * Check if message should be logged based on log level\n   */\n  private shouldLog(level: string): boolean {\n    const levels = ['ERROR', 'WARN', 'INFO', 'DEBUG'];\n    const currentLevelIndex = levels.indexOf(this.logLevel);\n    const messageLevelIndex = levels.indexOf(level);\n    \n    return messageLevelIndex <= currentLevelIndex;\n  }\n}", "import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';\nimport { PublicHandler, AuthenticatedHandler, ApiResponse, ErrorCode, ApiError } from '../types';\nimport { ResponseBuilder } from './response-builder';\nimport { Logger } from './logger';\n\n/**\n * Base Handler Class - Eliminates ALL boilerplate code across Lambda functions\n * \n * This addresses the V1 issue where auth code was duplicated across 7+ handlers.\n * Now ALL common functionality is centralized in this base class.\n */\nexport abstract class BaseHandler {\n  protected logger: Logger;\n  protected version: string = '2.0.0';\n\n  constructor(protected handlerName: string) {\n    this.logger = new Logger(handlerName);\n  }\n\n  /**\n   * Main entry point for authenticated handlers\n   * Handles ALL common concerns: auth, CORS, logging, error handling\n   */\n  public withAuth(handler: AuthenticatedHandler): PublicHandler {\n    return async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {\n      const requestId = event.requestContext.requestId;\n      const route = `${event.httpMethod} ${event.resource}`;\n      \n      try {\n        this.logger.info(`[${requestId}] ${route} - Request started`, {\n          httpMethod: event.httpMethod,\n          resource: event.resource,\n          userAgent: event.headers['User-Agent'],\n          sourceIp: event.requestContext.identity.sourceIp\n        });\n\n        // Handle CORS preflight\n        if (event.httpMethod === 'OPTIONS') {\n          return ResponseBuilder.cors();\n        }\n\n        // Extract and validate user context\n        const userId = this.extractUserId(event);\n        \n        if (!userId) {\n          this.logger.warn(`[${requestId}] ${route} - No userId in authorizer context`, {\n            authorizerContext: event.requestContext.authorizer\n          });\n          return ResponseBuilder.unauthorized('User not authenticated');\n        }\n\n        this.logger.info(`[${requestId}] ${route} - Authenticated user: ${userId}`);\n\n        // Validate request if needed\n        const validationError = await this.validateRequest(event);\n        if (validationError) {\n          this.logger.warn(`[${requestId}] ${route} - Validation failed`, validationError);\n          return ResponseBuilder.badRequest(validationError.message, validationError);\n        }\n\n        // Execute the actual handler\n        const startTime = Date.now();\n        const result = await handler(event, userId);\n        const duration = Date.now() - startTime;\n\n        this.logger.info(`[${requestId}] ${route} - Request completed`, {\n          statusCode: result.statusCode,\n          duration: `${duration}ms`\n        });\n\n        return result;\n\n      } catch (error) {\n        this.logger.error(`[${requestId}] ${route} - Request failed`, error);\n        return this.handleError(error);\n      }\n    };\n  }\n\n  /**\n   * Entry point for public handlers (no auth required)\n   * Still handles common concerns: CORS, logging, error handling\n   */\n  public withoutAuth(handler: PublicHandler): PublicHandler {\n    return async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {\n      const requestId = event.requestContext.requestId;\n      const route = `${event.httpMethod} ${event.resource}`;\n      \n      try {\n        this.logger.info(`[${requestId}] ${route} - Public request started`);\n\n        // Handle CORS preflight\n        if (event.httpMethod === 'OPTIONS') {\n          return ResponseBuilder.cors();\n        }\n\n        // Execute the handler\n        const startTime = Date.now();\n        const result = await handler(event);\n        const duration = Date.now() - startTime;\n\n        this.logger.info(`[${requestId}] ${route} - Public request completed`, {\n          statusCode: result.statusCode,\n          duration: `${duration}ms`\n        });\n\n        return result;\n\n      } catch (error) {\n        this.logger.error(`[${requestId}] ${route} - Public request failed`, error);\n        return this.handleError(error);\n      }\n    };\n  }\n\n  /**\n   * Extract userId from API Gateway authorizer context\n   * Handles both TOKEN and REQUEST authorizer formats\n   */\n  private extractUserId(event: APIGatewayProxyEvent): string | null {\n    const authorizer = event.requestContext.authorizer;\n    \n    if (!authorizer) {\n      return null;\n    }\n\n    // Try different possible locations for userId\n    return (\n      authorizer.userId ||\n      authorizer.principalId ||\n      authorizer.claims?.userId ||\n      authorizer.claims?.sub ||\n      null\n    );\n  }\n\n  /**\n   * Validate request - override in specific handlers\n   */\n  protected async validateRequest(event: APIGatewayProxyEvent): Promise<ApiError | null> {\n    return null; // No validation by default\n  }\n\n  /**\n   * Centralized error handling\n   */\n  private handleError(error: any): APIGatewayProxyResult {\n    if (error instanceof ApiError) {\n      return ResponseBuilder.error(error.message, error.code, error.details);\n    }\n\n    if (error.name === 'ValidationError') {\n      return ResponseBuilder.badRequest(error.message);\n    }\n\n    if (error.name === 'UnauthorizedError') {\n      return ResponseBuilder.unauthorized(error.message);\n    }\n\n    if (error.name === 'ForbiddenError') {\n      return ResponseBuilder.forbidden(error.message);\n    }\n\n    if (error.name === 'NotFoundError') {\n      return ResponseBuilder.notFound(error.message);\n    }\n\n    // Default to internal server error\n    return ResponseBuilder.internalError('An unexpected error occurred');\n  }\n\n  /**\n   * Helper: Parse JSON body safely\n   */\n  protected parseJsonBody<T>(event: APIGatewayProxyEvent): T | null {\n    if (!event.body) {\n      return null;\n    }\n\n    try {\n      return JSON.parse(event.body) as T;\n    } catch (error) {\n      throw new ApiError(ErrorCode.VALIDATION_ERROR, 'Invalid JSON in request body');\n    }\n  }\n\n  /**\n   * Helper: Get query parameter with default\n   */\n  protected getQueryParam(event: APIGatewayProxyEvent, key: string, defaultValue?: string): string | undefined {\n    return event.queryStringParameters?.[key] || defaultValue;\n  }\n\n  /**\n   * Helper: Get path parameter\n   */\n  protected getPathParam(event: APIGatewayProxyEvent, key: string): string | undefined {\n    return event.pathParameters?.[key];\n  }\n\n  /**\n   * Helper: Get header value\n   */\n  protected getHeader(event: APIGatewayProxyEvent, key: string): string | undefined {\n    return event.headers[key] || event.headers[key.toLowerCase()];\n  }\n\n  /**\n   * Helper: Create success response with data\n   */\n  protected success<T>(data: T, message?: string): APIGatewayProxyResult {\n    return ResponseBuilder.success(data, 200, message);\n  }\n\n  /**\n   * Helper: Create created response\n   */\n  protected created<T>(data: T, message?: string): APIGatewayProxyResult {\n    return ResponseBuilder.success(data, 201, message);\n  }\n\n  /**\n   * Helper: Create no content response\n   */\n  protected noContent(): APIGatewayProxyResult {\n    return ResponseBuilder.success(null, 204);\n  }\n\n  /**\n   * Helper: Create bad request response\n   */\n  protected badRequest(message: string, details?: any): APIGatewayProxyResult {\n    return ResponseBuilder.badRequest(message, details);\n  }\n\n  /**\n   * Helper: Create not found response\n   */\n  protected notFound(message: string): APIGatewayProxyResult {\n    return ResponseBuilder.notFound(message);\n  }\n\n  /**\n   * Helper: Create internal error response\n   */\n  protected internalError(message: string): APIGatewayProxyResult {\n    return ResponseBuilder.internalError(message);\n  }\n}", "import { S3Client, GetObjectCommand, PutObjectCommand, ListObjectsV2Command } from '@aws-sdk/client-s3';\nimport { Logger } from '../shared/logger';\n\n/**\n * S3 Service - Handles all S3 operations for study data\n * Provides methods for loading providers, questions, and managing data files\n */\nexport class S3Service {\n  private client: S3Client;\n  private logger: Logger;\n  private readonly bucketName: string;\n  private readonly region: string;\n\n  constructor() {\n    this.logger = new Logger('S3Service');\n    this.bucketName = process.env.S3_STUDY_DATA_BUCKET || 'study-app-data';\n    this.region = process.env.AWS_REGION || 'us-east-1';\n    \n    this.client = new S3Client({\n      region: this.region,\n    });\n\n    this.logger.info('S3Service initialized', {\n      bucketName: this.bucketName,\n      region: this.region\n    });\n  }\n\n  /**\n   * Get JSON object from S3\n   */\n  async getJsonObject<T>(key: string): Promise<T | null> {\n    const startTime = Date.now();\n    \n    try {\n      this.logger.debug('Fetching object from S3', { key, bucket: this.bucketName });\n\n      const command = new GetObjectCommand({\n        Bucket: this.bucketName,\n        Key: key\n      });\n\n      const response = await this.client.send(command);\n      \n      if (!response.Body) {\n        this.logger.warn('Empty response body from S3', { key });\n        return null;\n      }\n\n      const bodyString = await response.Body.transformToString();\n      const data = JSON.parse(bodyString);\n      \n      this.logger.perf('S3 getJsonObject', Date.now() - startTime, { \n        key, \n        sizeBytes: bodyString.length \n      });\n      \n      return data;\n    } catch (error) {\n      this.logger.error('Failed to get object from S3', {\n        key,\n        bucket: this.bucketName,\n        error: error instanceof Error ? error.message : error\n      });\n      \n      // Return null for not found, throw for other errors\n      if (error instanceof Error && error.name === 'NoSuchKey') {\n        return null;\n      }\n      \n      throw error;\n    }\n  }\n\n  /**\n   * Put JSON object to S3\n   */\n  async putJsonObject<T>(key: string, data: T): Promise<void> {\n    const startTime = Date.now();\n    \n    try {\n      const jsonString = JSON.stringify(data, null, 2);\n      \n      this.logger.debug('Putting object to S3', { key, sizeBytes: jsonString.length });\n\n      const command = new PutObjectCommand({\n        Bucket: this.bucketName,\n        Key: key,\n        Body: jsonString,\n        ContentType: 'application/json',\n        ServerSideEncryption: 'AES256'\n      });\n\n      await this.client.send(command);\n      \n      this.logger.perf('S3 putJsonObject', Date.now() - startTime, { \n        key, \n        sizeBytes: jsonString.length \n      });\n      \n      this.logger.info('Successfully uploaded object to S3', { key });\n    } catch (error) {\n      this.logger.error('Failed to put object to S3', {\n        key,\n        bucket: this.bucketName,\n        error: error instanceof Error ? error.message : error\n      });\n      \n      throw error;\n    }\n  }\n\n  /**\n   * List objects with a prefix\n   */\n  async listObjects(prefix: string): Promise<string[]> {\n    const startTime = Date.now();\n    \n    try {\n      this.logger.debug('Listing objects from S3', { prefix });\n\n      const command = new ListObjectsV2Command({\n        Bucket: this.bucketName,\n        Prefix: prefix,\n        MaxKeys: 1000\n      });\n\n      const response = await this.client.send(command);\n      const keys = (response.Contents || [])\n        .map(obj => obj.Key)\n        .filter((key): key is string => key !== undefined);\n      \n      this.logger.perf('S3 listObjects', Date.now() - startTime, { \n        prefix, \n        count: keys.length \n      });\n      \n      return keys;\n    } catch (error) {\n      this.logger.error('Failed to list objects from S3', {\n        prefix,\n        bucket: this.bucketName,\n        error: error instanceof Error ? error.message : error\n      });\n      \n      throw error;\n    }\n  }\n\n  /**\n   * Check if an object exists\n   */\n  async objectExists(key: string): Promise<boolean> {\n    try {\n      const command = new GetObjectCommand({\n        Bucket: this.bucketName,\n        Key: key\n      });\n\n      await this.client.send(command);\n      return true;\n    } catch (error) {\n      if (error instanceof Error && error.name === 'NoSuchKey') {\n        return false;\n      }\n      \n      // Re-throw other errors\n      throw error;\n    }\n  }\n\n  /**\n   * Get the configured bucket name\n   */\n  getBucketName(): string {\n    return this.bucketName;\n  }\n}", "import { DynamoDBClient } from '@aws-sdk/client-dynamodb';\nimport { DynamoDBDocumentClient, GetCommand, PutCommand } from '@aws-sdk/lib-dynamodb';\nimport { Logger } from '../shared/logger';\n\n/**\n * Cache Service - DynamoDB-based caching layer\n * Provides persistent caching for study data across Lambda invocations\n */\nexport class CacheService {\n  private client: DynamoDBDocumentClient;\n  private logger: Logger;\n  private readonly tableName: string;\n  private readonly region: string;\n\n  constructor() {\n    this.logger = new Logger('CacheService');\n    this.tableName = process.env.CACHE_TABLE_NAME || 'study-app-cache';\n    this.region = process.env.AWS_REGION || 'us-east-1';\n\n    const ddbClient = new DynamoDBClient({ region: this.region });\n    this.client = DynamoDBDocumentClient.from(ddbClient);\n\n    this.logger.info('CacheService initialized', {\n      tableName: this.tableName,\n      region: this.region\n    });\n  }\n\n  /**\n   * Get item from cache\n   */\n  async get<T>(key: string): Promise<T | null> {\n    const startTime = Date.now();\n\n    try {\n      this.logger.debug('Getting item from cache', { key });\n\n      const command = new GetCommand({\n        TableName: this.tableName,\n        Key: { cacheKey: key }\n      });\n\n      const response = await this.client.send(command);\n\n      if (!response.Item) {\n        this.logger.debug('Cache miss', { key });\n        return null;\n      }\n\n      // Check if item has expired\n      const now = Date.now();\n      if (response.Item.ttl && response.Item.ttl * 1000 < now) {\n        this.logger.debug('Cache item expired', { key, ttl: response.Item.ttl });\n        return null;\n      }\n\n      this.logger.perf('Cache get', Date.now() - startTime, { \n        key, \n        hit: true,\n        sizeBytes: JSON.stringify(response.Item.data).length \n      });\n\n      return response.Item.data as T;\n\n    } catch (error) {\n      this.logger.error('Failed to get item from cache', { key, error });\n      \n      // Return null on cache errors to allow fallback to primary source\n      return null;\n    }\n  }\n\n  /**\n   * Put item in cache with TTL\n   */\n  async put<T>(key: string, data: T, ttlMinutes: number = 60): Promise<void> {\n    const startTime = Date.now();\n\n    try {\n      const ttl = Math.floor(Date.now() / 1000) + (ttlMinutes * 60);\n      const item = {\n        cacheKey: key,\n        data,\n        ttl,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n      };\n\n      this.logger.debug('Putting item in cache', { \n        key, \n        ttlMinutes,\n        sizeBytes: JSON.stringify(data).length \n      });\n\n      const command = new PutCommand({\n        TableName: this.tableName,\n        Item: item\n      });\n\n      await this.client.send(command);\n\n      this.logger.perf('Cache put', Date.now() - startTime, { \n        key, \n        ttlMinutes,\n        sizeBytes: JSON.stringify(data).length \n      });\n\n    } catch (error) {\n      this.logger.error('Failed to put item in cache', { key, error });\n      \n      // Don't throw on cache errors - it's not critical\n      // The application should continue to work without cache\n    }\n  }\n\n  /**\n   * Generate cache key for providers\n   */\n  getProvidersCacheKey(): string {\n    return 'providers:all';\n  }\n\n  /**\n   * Generate cache key for specific provider\n   */\n  getProviderCacheKey(providerId: string): string {\n    return `provider:${providerId}`;\n  }\n\n  /**\n   * Generate cache key for questions\n   */\n  getQuestionsCacheKey(provider: string, exam: string): string {\n    return `questions:${provider}:${exam}`;\n  }\n\n  /**\n   * Generate cache key for question stats\n   */\n  getQuestionStatsCacheKey(provider: string, exam: string): string {\n    return `stats:questions:${provider}:${exam}`;\n  }\n\n  /**\n   * Generate cache key for filtered questions\n   * Note: This creates a lot of cache entries, use sparingly\n   */\n  getFilteredQuestionsCacheKey(\n    provider: string, \n    exam: string, \n    filter: any,\n    pagination: any\n  ): string {\n    const filterHash = this.hashObject({ filter, pagination });\n    return `filtered:${provider}:${exam}:${filterHash}`;\n  }\n\n  /**\n   * Simple hash function for objects\n   */\n  private hashObject(obj: any): string {\n    const str = JSON.stringify(obj, Object.keys(obj).sort());\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    return Math.abs(hash).toString(36);\n  }\n\n  /**\n   * Clear specific cache entries\n   */\n  async clearCache(pattern: string): Promise<void> {\n    // For DynamoDB, we'd need to implement a scan and delete operation\n    // This is expensive and not recommended for production\n    this.logger.warn('Cache clear not implemented for DynamoDB', { pattern });\n  }\n\n  /**\n   * Get cache statistics\n   */\n  async getCacheStats(): Promise<{\n    tableName: string;\n    region: string;\n    // Additional stats could be added by scanning the table\n  }> {\n    return {\n      tableName: this.tableName,\n      region: this.region\n    };\n  }\n}\n\n/**\n * Multi-layer Cache Manager\n * Combines Lambda memory cache with DynamoDB persistent cache\n */\nexport class MultiLayerCache {\n  private memoryCache: Map<string, { data: any; timestamp: number; ttl: number }> = new Map();\n  private dynamoCache: CacheService;\n  private logger: Logger;\n  private readonly memoryTtl = 5 * 60 * 1000; // 5 minutes in memory\n\n  constructor() {\n    this.dynamoCache = new CacheService();\n    this.logger = new Logger('MultiLayerCache');\n  }\n\n  /**\n   * Get item from multi-layer cache\n   * Checks memory first, then DynamoDB\n   */\n  async get<T>(key: string): Promise<T | null> {\n    // Check memory cache first\n    const memoryItem = this.memoryCache.get(key);\n    if (memoryItem && Date.now() - memoryItem.timestamp < memoryItem.ttl) {\n      this.logger.debug('Memory cache hit', { key });\n      return memoryItem.data as T;\n    }\n\n    // Remove expired memory cache item\n    if (memoryItem) {\n      this.memoryCache.delete(key);\n    }\n\n    // Check DynamoDB cache\n    const dynamoItem = await this.dynamoCache.get<T>(key);\n    if (dynamoItem) {\n      // Store in memory cache for faster future access\n      this.memoryCache.set(key, {\n        data: dynamoItem,\n        timestamp: Date.now(),\n        ttl: this.memoryTtl\n      });\n      \n      this.logger.debug('DynamoDB cache hit, stored in memory', { key });\n      return dynamoItem;\n    }\n\n    this.logger.debug('Cache miss on all layers', { key });\n    return null;\n  }\n\n  /**\n   * Put item in multi-layer cache\n   */\n  async put<T>(key: string, data: T, dynamoTtlMinutes: number = 60): Promise<void> {\n    // Store in memory cache immediately\n    this.memoryCache.set(key, {\n      data,\n      timestamp: Date.now(),\n      ttl: this.memoryTtl\n    });\n\n    // Store in DynamoDB cache asynchronously\n    await this.dynamoCache.put(key, data, dynamoTtlMinutes);\n    \n    this.logger.debug('Stored in multi-layer cache', { \n      key, \n      memoryTtlMinutes: this.memoryTtl / 60000,\n      dynamoTtlMinutes \n    });\n  }\n\n  /**\n   * Clear memory cache (DynamoDB cache remains)\n   */\n  clearMemoryCache(): void {\n    const size = this.memoryCache.size;\n    this.memoryCache.clear();\n    this.logger.info('Cleared memory cache', { entriesRemoved: size });\n  }\n\n  /**\n   * Get cache statistics\n   */\n  async getStats(): Promise<{\n    memory: {\n      entries: number;\n      totalSizeBytes: number;\n    };\n    dynamo: {\n      tableName: string;\n      region: string;\n    };\n  }> {\n    let totalSizeBytes = 0;\n    for (const [key, value] of this.memoryCache.entries()) {\n      totalSizeBytes += JSON.stringify(value).length;\n    }\n\n    const dynamoStats = await this.dynamoCache.getCacheStats();\n\n    return {\n      memory: {\n        entries: this.memoryCache.size,\n        totalSizeBytes\n      },\n      dynamo: dynamoStats\n    };\n  }\n\n  /**\n   * Cleanup expired memory cache entries\n   */\n  cleanup(): void {\n    const now = Date.now();\n    let removed = 0;\n\n    for (const [key, value] of this.memoryCache.entries()) {\n      if (now - value.timestamp >= value.ttl) {\n        this.memoryCache.delete(key);\n        removed++;\n      }\n    }\n\n    if (removed > 0) {\n      this.logger.debug('Cleaned up expired memory cache entries', { removed });\n    }\n  }\n}", "import { Provider, Exam } from '../types';\nimport { S3Service } from './s3-service';\nimport { MultiLayerCache } from './cache-service';\nimport { Logger } from '../shared/logger';\n\n/**\n * Provider Service - Manages study providers and their exams\n * Handles S3-based provider metadata with multi-layer caching\n */\nexport class ProviderService {\n  private s3Service: S3Service;\n  private cache: MultiLayerCache;\n  private logger: Logger;\n\n  constructor() {\n    this.s3Service = new S3Service();\n    this.cache = new MultiLayerCache();\n    this.logger = new Logger('ProviderService');\n  }\n\n  /**\n   * Get all providers and their exams\n   */\n  async getAllProviders(): Promise<Provider[]> {\n    const startTime = Date.now();\n    const cacheKey = 'providers:all';\n\n    try {\n      // Check multi-layer cache first\n      const cachedProviders = await this.cache.get<Provider[]>(cacheKey);\n      if (cachedProviders) {\n        this.logger.debug('Returning cached providers');\n        return cachedProviders;\n      }\n\n      this.logger.info('Loading providers from S3');\n\n      // Load providers from S3\n      const providers = await this.loadProvidersFromS3();\n      \n      // Update cache with 6 hour TTL\n      await this.cache.put(cacheKey, providers, 360);\n\n      this.logger.perf('getAllProviders', Date.now() - startTime, {\n        providerCount: providers.length,\n        totalExams: providers.reduce((sum, p) => sum + p.exams.length, 0)\n      });\n\n      return providers;\n    } catch (error) {\n      this.logger.error('Failed to get all providers', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get specific provider by ID\n   */\n  async getProvider(providerId: string): Promise<Provider | null> {\n    const startTime = Date.now();\n    const cacheKey = `provider:${providerId}`;\n\n    try {\n      // Check multi-layer cache first\n      const cachedProvider = await this.cache.get<Provider>(cacheKey);\n      if (cachedProvider) {\n        this.logger.debug('Returning cached provider', { providerId });\n        return cachedProvider;\n      }\n\n      this.logger.info('Loading specific provider from S3', { providerId });\n\n      // Try to load specific provider from S3\n      const provider = await this.loadProviderFromS3(providerId);\n      \n      if (provider) {\n        // Update cache with 6 hour TTL\n        await this.cache.put(cacheKey, provider, 360);\n        this.logger.perf('getProvider', Date.now() - startTime, { providerId });\n        return provider;\n      }\n\n      // If specific provider file doesn't exist, load all and find it\n      const allProviders = await this.getAllProviders();\n      const foundProvider = allProviders.find(p => p.id === providerId);\n      \n      if (foundProvider) {\n        // Cache the found provider\n        await this.cache.put(cacheKey, foundProvider, 360);\n      }\n      \n      this.logger.perf('getProvider', Date.now() - startTime, { \n        providerId,\n        found: !!foundProvider \n      });\n\n      return foundProvider || null;\n    } catch (error) {\n      this.logger.error('Failed to get provider', { providerId, error });\n      throw error;\n    }\n  }\n\n  /**\n   * Get exam from provider\n   */\n  async getExam(providerId: string, examId: string): Promise<Exam | null> {\n    try {\n      const provider = await this.getProvider(providerId);\n      if (!provider) {\n        return null;\n      }\n\n      return provider.exams.find(exam => exam.id === examId) || null;\n    } catch (error) {\n      this.logger.error('Failed to get exam', { providerId, examId, error });\n      throw error;\n    }\n  }\n\n  /**\n   * Get provider statistics\n   */\n  async getProviderStats(): Promise<{\n    totalProviders: number;\n    totalExams: number;\n    providerBreakdown: { [key: string]: number };\n  }> {\n    try {\n      const providers = await this.getAllProviders();\n      \n      return {\n        totalProviders: providers.length,\n        totalExams: providers.reduce((sum, p) => sum + p.exams.length, 0),\n        providerBreakdown: providers.reduce((breakdown, provider) => {\n          breakdown[provider.id] = provider.exams.length;\n          return breakdown;\n        }, {} as { [key: string]: number })\n      };\n    } catch (error) {\n      this.logger.error('Failed to get provider stats', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Clear cache - useful for testing or forced refresh\n   */\n  clearCache(): void {\n    this.cache.clearMemoryCache();\n    this.logger.info('Provider cache cleared');\n  }\n\n  /**\n   * Load all providers from S3\n   */\n  private async loadProvidersFromS3(): Promise<Provider[]> {\n    try {\n      // First try to load consolidated providers file\n      let providers = await this.s3Service.getJsonObject<Provider[]>('providers/providers.json');\n      \n      if (providers) {\n        return providers;\n      }\n\n      // If consolidated file doesn't exist, try to load individual provider files\n      this.logger.debug('Consolidated providers file not found, trying individual files');\n      \n      const providerKeys = await this.s3Service.listObjects('providers/');\n      const individualProviders: Provider[] = [];\n\n      for (const key of providerKeys) {\n        if (key.endsWith('.json') && key !== 'providers/providers.json') {\n          const provider = await this.s3Service.getJsonObject<Provider>(key);\n          if (provider) {\n            individualProviders.push(provider);\n          }\n        }\n      }\n\n      if (individualProviders.length > 0) {\n        return individualProviders;\n      }\n\n      // If no providers found in S3, return default providers\n      this.logger.warn('No providers found in S3, returning default providers');\n      return this.getDefaultProviders();\n\n    } catch (error) {\n      this.logger.error('Failed to load providers from S3, falling back to defaults', error);\n      return this.getDefaultProviders();\n    }\n  }\n\n  /**\n   * Load specific provider from S3\n   */\n  private async loadProviderFromS3(providerId: string): Promise<Provider | null> {\n    try {\n      const provider = await this.s3Service.getJsonObject<Provider>(`providers/${providerId}.json`);\n      return provider;\n    } catch (error) {\n      this.logger.debug('Failed to load specific provider from S3', { providerId });\n      return null;\n    }\n  }\n\n\n  /**\n   * Get default providers when S3 data is not available\n   */\n  private getDefaultProviders(): Provider[] {\n    return [\n      {\n        id: 'aws',\n        name: 'Amazon Web Services',\n        description: 'Cloud computing platform and services',\n        exams: [\n          {\n            id: 'saa-c03',\n            name: 'Solutions Architect Associate',\n            description: 'Validates ability to design distributed systems on AWS',\n            questionCount: 681,\n            duration: 130,\n            passingScore: 720\n          },\n          {\n            id: 'dva-c01',\n            name: 'Developer Associate',\n            description: 'Validates ability to develop applications on AWS',\n            questionCount: 0,\n            duration: 130,\n            passingScore: 720\n          },\n          {\n            id: 'soa-c02',\n            name: 'SysOps Administrator Associate',\n            description: 'Validates ability to deploy and manage systems on AWS',\n            questionCount: 0,\n            duration: 130,\n            passingScore: 720\n          }\n        ]\n      },\n      {\n        id: 'azure',\n        name: 'Microsoft Azure',\n        description: 'Cloud computing platform and services',\n        exams: [\n          {\n            id: 'az-900',\n            name: 'Azure Fundamentals',\n            description: 'Validates foundational knowledge of cloud services',\n            questionCount: 0,\n            duration: 60,\n            passingScore: 700\n          },\n          {\n            id: 'az-104',\n            name: 'Azure Administrator',\n            description: 'Validates skills to manage Azure subscriptions and resources',\n            questionCount: 0,\n            duration: 150,\n            passingScore: 700\n          }\n        ]\n      },\n      {\n        id: 'gcp',\n        name: 'Google Cloud Platform',\n        description: 'Cloud computing platform and services',\n        exams: [\n          {\n            id: 'ace',\n            name: 'Associate Cloud Engineer',\n            description: 'Validates ability to deploy and manage GCP resources',\n            questionCount: 0,\n            duration: 120,\n            passingScore: 70\n          }\n        ]\n      }\n    ];\n  }\n}"],
  "mappings": "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",
  "names": ["provider_handler_exports", "__export", "handler", "__toCommonJS", "ApiError", "code", "message", "details", "ResponseBuilder", "data", "statusCode", "message", "response", "code", "details", "items", "totalCount", "page", "pageSize", "totalPages", "hasNextPage", "hasPrevPage", "Logger", "context", "message", "data", "error", "errorData", "operation", "duration", "level", "logEntry", "levels", "currentLevelIndex", "BaseHandler", "handlerName", "Logger", "handler", "event", "requestId", "route", "ResponseBuilder", "userId", "validationError", "startTime", "result", "duration", "error", "authorizer", "ApiError", "key", "defaultValue", "data", "message", "details", "import_client_s3", "S3Service", "Logger", "key", "startTime", "command", "response", "bodyString", "data", "error", "jsonString", "prefix", "keys", "obj", "import_client_dynamodb", "import_lib_dynamodb", "CacheService", "Logger", "ddbClient", "key", "startTime", "command", "response", "now", "error", "data", "ttlMinutes", "ttl", "item", "providerId", "provider", "exam", "filter", "pagination", "filterHash", "obj", "str", "hash", "i", "char", "pattern", "MultiLayerCache", "memoryItem", "dynamoItem", "dynamoTtlMinutes", "size", "totalSizeBytes", "value", "dynamoStats", "removed", "ProviderService", "S3Service", "MultiLayerCache", "Logger", "startTime", "cacheKey", "cachedProviders", "providers", "sum", "p", "error", "providerId", "cachedProvider", "provider", "foundProvider", "examId", "exam", "breakdown", "providerKeys", "individualProviders", "key", "ProviderHandler", "BaseHandler", "ProviderService", "event", "userId", "providers", "stats", "error", "providerId", "provider", "httpMethod", "message", "providerHandler", "handler"]
}
