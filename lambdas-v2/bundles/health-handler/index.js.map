{
  "version": 3,
  "sources": ["../../src/handlers/health-handler.ts", "../../src/types/index.ts", "../../src/shared/response-builder.ts", "../../src/shared/logger.ts", "../../src/shared/base-handler.ts"],
  "sourcesContent": ["import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';\nimport { BaseHandler } from '../shared/base-handler';\n\n/**\n * Health Handler V2 - Demonstrates withoutAuth pattern\n * \n * This handler shows how to create public endpoints that don't require authentication\n * but still benefit from the common error handling, CORS, and logging infrastructure.\n */\nclass HealthHandler extends BaseHandler {\n  constructor() {\n    super('HealthHandler');\n  }\n\n  /**\n   * Health check endpoint - returns system status\n   */\n  public async checkHealth(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {\n    this.logger.info('Health check requested');\n\n    // Collect system information\n    const healthData = {\n      status: 'healthy',\n      version: this.version,\n      stage: process.env.STAGE || 'unknown',\n      timestamp: new Date().toISOString(),\n      environment: {\n        region: process.env.AWS_REGION || 'unknown',\n        functionName: process.env.AWS_LAMBDA_FUNCTION_NAME || 'unknown',\n        memorySize: process.env.AWS_LAMBDA_FUNCTION_MEMORY_SIZE || 'unknown',\n        logLevel: process.env.LOG_LEVEL || 'INFO'\n      },\n      dependencies: {\n        dynamodb: {\n          usersTable: process.env.USERS_TABLE || 'not-configured',\n          sessionsTable: process.env.SESSIONS_TABLE || 'not-configured',\n          goalsTable: process.env.GOALS_TABLE || 'not-configured',\n          analyticsTable: process.env.ANALYTICS_TABLE || 'not-configured'\n        },\n        s3: {\n          dataBucket: process.env.DATA_BUCKET || 'not-configured'\n        }\n      }\n    };\n\n    // In a real implementation, you might add actual dependency checks:\n    // - Test DynamoDB connectivity\n    // - Test S3 bucket access\n    // - Check external service availability\n\n    return this.success(healthData, 'Health check completed successfully');\n  }\n}\n\n// Export the handler using withoutAuth since no authentication is required\nconst healthHandler = new HealthHandler();\nexport const handler = healthHandler.withoutAuth(\n  (event: APIGatewayProxyEvent) => healthHandler.checkHealth(event)\n);", "import { APIGatewayProxyEvent, APIGatewayProxyResult, APIGatewayTokenAuthorizerEvent, APIGatewayAuthorizerResult } from 'aws-lambda';\n\n// Base Handler Types\nexport type PublicHandler = (event: APIGatewayProxyEvent) => Promise<APIGatewayProxyResult>;\nexport type AuthenticatedHandler = (event: APIGatewayProxyEvent, userId: string) => Promise<APIGatewayProxyResult>;\nexport type AuthorizerHandler = (event: APIGatewayTokenAuthorizerEvent) => Promise<APIGatewayAuthorizerResult>;\n\n// Common API Response Structure\nexport interface ApiResponse<T = any> {\n  success: boolean;\n  data?: T;\n  message?: string;\n  error?: string;\n  timestamp: string;\n  version: string;\n}\n\n// Error Types\nexport enum ErrorCode {\n  UNAUTHORIZED = 'UNAUTHORIZED',\n  FORBIDDEN = 'FORBIDDEN',\n  NOT_FOUND = 'NOT_FOUND',\n  VALIDATION_ERROR = 'VALIDATION_ERROR',\n  INTERNAL_ERROR = 'INTERNAL_ERROR',\n  RATE_LIMITED = 'RATE_LIMITED'\n}\n\nexport class ApiError extends Error {\n  constructor(\n    public code: ErrorCode,\n    message: string,\n    public details?: any\n  ) {\n    super(message);\n    this.name = 'ApiError';\n  }\n}\n\n// User Context\nexport interface UserContext {\n  userId: string;\n  email: string;\n  role?: string;\n  permissions?: string[];\n}\n\n// JWT Token Payload\nexport interface JwtPayload {\n  userId: string;\n  email: string;\n  role?: string;\n  iat: number;\n  exp: number;\n}\n\n// Database Entities\nexport interface User {\n  userId: string;\n  email: string;\n  name?: string;\n  role: string;\n  createdAt: string;\n  updatedAt: string;\n  lastLoginAt?: string;\n  isActive: boolean;\n}\n\nexport interface StudySession {\n  sessionId: string;\n  userId: string;\n  provider: string;\n  exam: string;\n  status: 'active' | 'completed' | 'paused';\n  startTime: string;\n  endTime?: string;\n  questionsAnswered: number;\n  correctAnswers: number;\n  totalQuestions: number;\n  createdAt: string;\n  updatedAt: string;\n  expiresAt?: number; // TTL\n}\n\nexport interface StudyGoal {\n  goalId: string;\n  userId: string;\n  title: string;\n  description?: string;\n  targetDate: string;\n  status: 'active' | 'completed' | 'paused';\n  progress: number; // 0-100\n  metrics: {\n    questionsTarget: number;\n    questionsCompleted: number;\n    accuracyTarget: number;\n    currentAccuracy: number;\n  };\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport interface AnalyticsEvent {\n  userId: string;\n  eventType: string;\n  eventData: any;\n  timestamp: string;\n  sessionId?: string;\n  provider?: string;\n  exam?: string;\n  expiresAt: number; // TTL\n}\n\nexport interface Provider {\n  id: string;\n  name: string;\n  description: string;\n  exams: Exam[];\n}\n\nexport interface Exam {\n  id: string;\n  name: string;\n  description: string;\n  questionCount: number;\n  duration?: number;\n  passingScore?: number;\n}\n\nexport interface Question {\n  questionId: string;\n  provider: string;\n  exam: string;\n  text: string;\n  options: string[];\n  correctAnswer: number;\n  explanation?: string;\n  difficulty: 'easy' | 'medium' | 'hard';\n  topics: string[];\n  createdAt: string;\n}\n\n// Request/Response Types\nexport interface CreateSessionRequest {\n  provider: string;\n  exam: string;\n  questionCount?: number;\n}\n\nexport interface CreateGoalRequest {\n  title: string;\n  description?: string;\n  targetDate: string;\n  questionsTarget: number;\n  accuracyTarget: number;\n}\n\nexport interface GetQuestionsRequest {\n  provider: string;\n  exam: string;\n  limit?: number;\n  difficulty?: string;\n  topics?: string[];\n}", "import { APIGatewayProxyResult } from 'aws-lambda';\nimport { ApiResponse, ErrorCode } from '../types';\n\n/**\n * Enhanced Response Builder - V2\n * Provides consistent API responses with proper CORS headers\n */\nexport class ResponseBuilder {\n  private static readonly VERSION = '2.0.0';\n\n  private static readonly CORS_HEADERS = {\n    'Content-Type': 'application/json',\n    'Access-Control-Allow-Origin': '*', // Configure specific origins in production\n    'Access-Control-Allow-Headers': 'Content-Type,Authorization,X-Amz-Date,X-Api-Key,X-Amz-Security-Token,X-Amz-User-Agent,X-Auth-Token',\n    'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS,HEAD',\n    'Access-Control-Allow-Credentials': 'true',\n    'Cache-Control': 'no-cache, no-store, must-revalidate',\n    'Pragma': 'no-cache',\n    'Expires': '0'\n  };\n\n  /**\n   * Create successful response\n   */\n  public static success<T>(\n    data: T, \n    statusCode: number = 200,\n    message?: string\n  ): APIGatewayProxyResult {\n    const response: ApiResponse<T> = {\n      success: true,\n      data,\n      message,\n      timestamp: new Date().toISOString(),\n      version: this.VERSION\n    };\n\n    return {\n      statusCode,\n      headers: this.CORS_HEADERS,\n      body: JSON.stringify(response)\n    };\n  }\n\n  /**\n   * Create error response\n   */\n  public static error(\n    message: string,\n    code: ErrorCode = ErrorCode.INTERNAL_ERROR,\n    details?: any,\n    statusCode: number = 500\n  ): APIGatewayProxyResult {\n    const response: ApiResponse = {\n      success: false,\n      error: message,\n      message: `[${code}] ${message}`,\n      timestamp: new Date().toISOString(),\n      version: this.VERSION,\n      ...(details && { data: details })\n    };\n\n    return {\n      statusCode,\n      headers: this.CORS_HEADERS,\n      body: JSON.stringify(response)\n    };\n  }\n\n  /**\n   * Bad Request (400)\n   */\n  public static badRequest(message: string, details?: any): APIGatewayProxyResult {\n    return this.error(message, ErrorCode.VALIDATION_ERROR, details, 400);\n  }\n\n  /**\n   * Unauthorized (401)\n   */\n  public static unauthorized(message: string = 'Unauthorized'): APIGatewayProxyResult {\n    return this.error(message, ErrorCode.UNAUTHORIZED, undefined, 401);\n  }\n\n  /**\n   * Forbidden (403)\n   */\n  public static forbidden(message: string = 'Forbidden'): APIGatewayProxyResult {\n    return this.error(message, ErrorCode.FORBIDDEN, undefined, 403);\n  }\n\n  /**\n   * Not Found (404)\n   */\n  public static notFound(message: string = 'Resource not found'): APIGatewayProxyResult {\n    return this.error(message, ErrorCode.NOT_FOUND, undefined, 404);\n  }\n\n  /**\n   * Rate Limited (429)\n   */\n  public static rateLimited(message: string = 'Rate limit exceeded'): APIGatewayProxyResult {\n    return this.error(message, ErrorCode.RATE_LIMITED, undefined, 429);\n  }\n\n  /**\n   * Internal Server Error (500)\n   */\n  public static internalError(message: string = 'Internal server error'): APIGatewayProxyResult {\n    return this.error(message, ErrorCode.INTERNAL_ERROR, undefined, 500);\n  }\n\n  /**\n   * CORS preflight response\n   */\n  public static cors(): APIGatewayProxyResult {\n    return {\n      statusCode: 200,\n      headers: {\n        ...this.CORS_HEADERS,\n        'Access-Control-Max-Age': '86400' // Cache preflight for 24 hours\n      },\n      body: ''\n    };\n  }\n\n  /**\n   * Health check response\n   */\n  public static health(data: any): APIGatewayProxyResult {\n    return this.success({\n      status: 'healthy',\n      timestamp: new Date().toISOString(),\n      version: this.VERSION,\n      environment: process.env.STAGE || 'unknown',\n      ...data\n    });\n  }\n\n  /**\n   * Paginated response\n   */\n  public static paginated<T>(\n    items: T[],\n    totalCount: number,\n    page: number,\n    pageSize: number,\n    message?: string\n  ): APIGatewayProxyResult {\n    const totalPages = Math.ceil(totalCount / pageSize);\n    const hasNextPage = page < totalPages;\n    const hasPrevPage = page > 1;\n\n    return this.success({\n      items,\n      pagination: {\n        totalCount,\n        totalPages,\n        currentPage: page,\n        pageSize,\n        hasNextPage,\n        hasPrevPage\n      }\n    }, 200, message);\n  }\n}", "/**\n * Structured Logger - V2\n * Provides consistent logging across all Lambda functions\n */\nexport class Logger {\n  private readonly context: string;\n  private readonly logLevel: string;\n\n  constructor(context: string) {\n    this.context = context;\n    this.logLevel = process.env.LOG_LEVEL || 'INFO';\n  }\n\n  /**\n   * Info level logging\n   */\n  public info(message: string, data?: any): void {\n    if (this.shouldLog('INFO')) {\n      this.log('INFO', message, data);\n    }\n  }\n\n  /**\n   * Debug level logging\n   */\n  public debug(message: string, data?: any): void {\n    if (this.shouldLog('DEBUG')) {\n      this.log('DEBUG', message, data);\n    }\n  }\n\n  /**\n   * Warning level logging\n   */\n  public warn(message: string, data?: any): void {\n    if (this.shouldLog('WARN')) {\n      this.log('WARN', message, data);\n    }\n  }\n\n  /**\n   * Error level logging\n   */\n  public error(message: string, error?: any): void {\n    const errorData = error instanceof Error ? {\n      name: error.name,\n      message: error.message,\n      stack: error.stack\n    } : error;\n\n    this.log('ERROR', message, errorData);\n  }\n\n  /**\n   * Performance logging\n   */\n  public perf(operation: string, duration: number, data?: any): void {\n    this.info(`Performance: ${operation}`, {\n      duration: `${duration}ms`,\n      operation,\n      ...data\n    });\n  }\n\n  /**\n   * Core logging method\n   */\n  private log(level: string, message: string, data?: any): void {\n    const logEntry = {\n      timestamp: new Date().toISOString(),\n      level,\n      context: this.context,\n      message,\n      stage: process.env.STAGE || 'unknown',\n      version: '2.0.0',\n      ...(data && { data })\n    };\n\n    // Use console methods for CloudWatch integration\n    switch (level) {\n      case 'ERROR':\n        console.error(JSON.stringify(logEntry));\n        break;\n      case 'WARN':\n        console.warn(JSON.stringify(logEntry));\n        break;\n      default:\n        console.log(JSON.stringify(logEntry));\n    }\n  }\n\n  /**\n   * Check if message should be logged based on log level\n   */\n  private shouldLog(level: string): boolean {\n    const levels = ['ERROR', 'WARN', 'INFO', 'DEBUG'];\n    const currentLevelIndex = levels.indexOf(this.logLevel);\n    const messageLevelIndex = levels.indexOf(level);\n    \n    return messageLevelIndex <= currentLevelIndex;\n  }\n}", "import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';\nimport { PublicHandler, AuthenticatedHandler, ApiResponse, ErrorCode, ApiError } from '../types';\nimport { ResponseBuilder } from './response-builder';\nimport { Logger } from './logger';\n\n/**\n * Base Handler Class - Eliminates ALL boilerplate code across Lambda functions\n * \n * This addresses the V1 issue where auth code was duplicated across 7+ handlers.\n * Now ALL common functionality is centralized in this base class.\n */\nexport abstract class BaseHandler {\n  protected logger: Logger;\n  protected version: string = '2.0.0';\n\n  constructor(protected handlerName: string) {\n    this.logger = new Logger(handlerName);\n  }\n\n  /**\n   * Main entry point for authenticated handlers\n   * Handles ALL common concerns: auth, CORS, logging, error handling\n   */\n  public withAuth(handler: AuthenticatedHandler): PublicHandler {\n    return async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {\n      const requestId = event.requestContext.requestId;\n      const route = `${event.httpMethod} ${event.resource}`;\n      \n      try {\n        this.logger.info(`[${requestId}] ${route} - Request started`, {\n          httpMethod: event.httpMethod,\n          resource: event.resource,\n          userAgent: event.headers['User-Agent'],\n          sourceIp: event.requestContext.identity.sourceIp\n        });\n\n        // Handle CORS preflight\n        if (event.httpMethod === 'OPTIONS') {\n          return ResponseBuilder.cors();\n        }\n\n        // Extract and validate user context\n        const userId = this.extractUserId(event);\n        \n        if (!userId) {\n          this.logger.warn(`[${requestId}] ${route} - No userId in authorizer context`, {\n            authorizerContext: event.requestContext.authorizer\n          });\n          return ResponseBuilder.unauthorized('User not authenticated');\n        }\n\n        this.logger.info(`[${requestId}] ${route} - Authenticated user: ${userId}`);\n\n        // Validate request if needed\n        const validationError = await this.validateRequest(event);\n        if (validationError) {\n          this.logger.warn(`[${requestId}] ${route} - Validation failed`, validationError);\n          return ResponseBuilder.badRequest(validationError.message, validationError);\n        }\n\n        // Execute the actual handler\n        const startTime = Date.now();\n        const result = await handler(event, userId);\n        const duration = Date.now() - startTime;\n\n        this.logger.info(`[${requestId}] ${route} - Request completed`, {\n          statusCode: result.statusCode,\n          duration: `${duration}ms`\n        });\n\n        return result;\n\n      } catch (error) {\n        this.logger.error(`[${requestId}] ${route} - Request failed`, error);\n        return this.handleError(error);\n      }\n    };\n  }\n\n  /**\n   * Entry point for public handlers (no auth required)\n   * Still handles common concerns: CORS, logging, error handling\n   */\n  public withoutAuth(handler: PublicHandler): PublicHandler {\n    return async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {\n      const requestId = event.requestContext.requestId;\n      const route = `${event.httpMethod} ${event.resource}`;\n      \n      try {\n        this.logger.info(`[${requestId}] ${route} - Public request started`);\n\n        // Handle CORS preflight\n        if (event.httpMethod === 'OPTIONS') {\n          return ResponseBuilder.cors();\n        }\n\n        // Execute the handler\n        const startTime = Date.now();\n        const result = await handler(event);\n        const duration = Date.now() - startTime;\n\n        this.logger.info(`[${requestId}] ${route} - Public request completed`, {\n          statusCode: result.statusCode,\n          duration: `${duration}ms`\n        });\n\n        return result;\n\n      } catch (error) {\n        this.logger.error(`[${requestId}] ${route} - Public request failed`, error);\n        return this.handleError(error);\n      }\n    };\n  }\n\n  /**\n   * Extract userId from API Gateway authorizer context\n   * Handles both TOKEN and REQUEST authorizer formats\n   */\n  private extractUserId(event: APIGatewayProxyEvent): string | null {\n    const authorizer = event.requestContext.authorizer;\n    \n    if (!authorizer) {\n      return null;\n    }\n\n    // Try different possible locations for userId\n    return (\n      authorizer.userId ||\n      authorizer.principalId ||\n      authorizer.claims?.userId ||\n      authorizer.claims?.sub ||\n      null\n    );\n  }\n\n  /**\n   * Validate request - override in specific handlers\n   */\n  protected async validateRequest(event: APIGatewayProxyEvent): Promise<ApiError | null> {\n    return null; // No validation by default\n  }\n\n  /**\n   * Centralized error handling\n   */\n  private handleError(error: any): APIGatewayProxyResult {\n    if (error instanceof ApiError) {\n      return ResponseBuilder.error(error.message, error.code, error.details);\n    }\n\n    if (error.name === 'ValidationError') {\n      return ResponseBuilder.badRequest(error.message);\n    }\n\n    if (error.name === 'UnauthorizedError') {\n      return ResponseBuilder.unauthorized(error.message);\n    }\n\n    if (error.name === 'ForbiddenError') {\n      return ResponseBuilder.forbidden(error.message);\n    }\n\n    if (error.name === 'NotFoundError') {\n      return ResponseBuilder.notFound(error.message);\n    }\n\n    // Default to internal server error\n    return ResponseBuilder.internalError('An unexpected error occurred');\n  }\n\n  /**\n   * Helper: Parse JSON body safely\n   */\n  protected parseJsonBody<T>(event: APIGatewayProxyEvent): T | null {\n    if (!event.body) {\n      return null;\n    }\n\n    try {\n      return JSON.parse(event.body) as T;\n    } catch (error) {\n      throw new ApiError(ErrorCode.VALIDATION_ERROR, 'Invalid JSON in request body');\n    }\n  }\n\n  /**\n   * Helper: Get query parameter with default\n   */\n  protected getQueryParam(event: APIGatewayProxyEvent, key: string, defaultValue?: string): string | undefined {\n    return event.queryStringParameters?.[key] || defaultValue;\n  }\n\n  /**\n   * Helper: Get path parameter\n   */\n  protected getPathParam(event: APIGatewayProxyEvent, key: string): string | undefined {\n    return event.pathParameters?.[key];\n  }\n\n  /**\n   * Helper: Get header value\n   */\n  protected getHeader(event: APIGatewayProxyEvent, key: string): string | undefined {\n    return event.headers[key] || event.headers[key.toLowerCase()];\n  }\n\n  /**\n   * Helper: Create success response with data\n   */\n  protected success<T>(data: T, message?: string): APIGatewayProxyResult {\n    return ResponseBuilder.success(data, 200, message);\n  }\n\n  /**\n   * Helper: Create created response\n   */\n  protected created<T>(data: T, message?: string): APIGatewayProxyResult {\n    return ResponseBuilder.success(data, 201, message);\n  }\n\n  /**\n   * Helper: Create no content response\n   */\n  protected noContent(): APIGatewayProxyResult {\n    return ResponseBuilder.success(null, 204);\n  }\n}"],
  "mappings": "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",
  "names": ["health_handler_exports", "__export", "handler", "__toCommonJS", "ApiError", "code", "message", "details", "ResponseBuilder", "data", "statusCode", "message", "response", "code", "details", "items", "totalCount", "page", "pageSize", "totalPages", "hasNextPage", "hasPrevPage", "Logger", "context", "message", "data", "error", "errorData", "operation", "duration", "level", "logEntry", "levels", "currentLevelIndex", "BaseHandler", "handlerName", "Logger", "handler", "event", "requestId", "route", "ResponseBuilder", "userId", "validationError", "startTime", "result", "duration", "error", "authorizer", "ApiError", "key", "defaultValue", "data", "message", "HealthHandler", "BaseHandler", "event", "healthData", "healthHandler", "handler"]
}
