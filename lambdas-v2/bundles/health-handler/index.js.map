{
  "version": 3,
  "sources": ["../../src/handlers/health-handler.ts", "../../src/types/index.ts", "../../src/shared/response-builder.ts", "../../src/shared/logger.ts", "../../src/shared/base-handler.ts", "../../src/services/health-service.ts", "../../node_modules/uuid/dist/esm-node/stringify.js", "../../node_modules/uuid/dist/esm-node/rng.js", "../../node_modules/uuid/dist/esm-node/native.js", "../../node_modules/uuid/dist/esm-node/v4.js", "../../src/services/monitoring-service.ts"],
  "sourcesContent": ["import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';\nimport { BaseHandler } from '../shared/base-handler';\nimport { HealthService } from '../services/health-service';\nimport { MonitoringService } from '../services/monitoring-service';\nimport { \n  GetHealthRequest,\n  GetHealthResponse,\n  GetHealthPerformanceMetricsRequest,\n  GetHealthPerformanceMetricsResponse,\n  GetAlertsRequest,\n  GetAlertsResponse,\n  GetHealthHistoryRequest,\n  GetHealthHistoryResponse,\n  GenerateHealthReportRequest,\n  GenerateHealthReportResponse\n} from '../types';\n\n/**\n * Health Handler V2 - Comprehensive System Health & Monitoring\n * \n * Provides multiple endpoints for system health monitoring:\n * - GET /health - Basic health check\n * - GET /health/detailed - Comprehensive system health with dependencies\n * - GET /health/performance - Performance metrics and trends\n * - GET /health/database - Database connectivity and performance\n * - GET /health/storage - S3 and storage system health\n * - GET /health/services - All service health overview\n * - GET /health/alerts - Current alerts and recommendations\n * - GET /health/history - Health history and trends\n */\nclass HealthHandler extends BaseHandler {\n  private healthService: HealthService;\n  private monitoringService: MonitoringService;\n\n  constructor() {\n    super('HealthHandler');\n    this.healthService = new HealthService();\n    this.monitoringService = new MonitoringService();\n  }\n\n  /**\n   * Basic health check endpoint - returns simple status\n   * GET /health\n   */\n  public async checkHealth(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {\n    this.logger.info('Basic health check requested');\n\n    try {\n      const healthCheck = await this.healthService.performHealthCheck();\n      \n      // Record the health check for historical tracking\n      await this.monitoringService.recordHealthHistory(healthCheck);\n\n      // Return simplified response for basic health check\n      const basicHealth = {\n        status: healthCheck.status,\n        version: this.version,\n        stage: healthCheck.environment.stage,\n        timestamp: healthCheck.timestamp,\n        uptime: healthCheck.environment.uptime,\n        dependencies: {\n          overall: healthCheck.dependencies.overall,\n          dynamodb: healthCheck.dependencies.dynamodb.status,\n          s3: healthCheck.dependencies.s3.status\n        },\n        alerts: healthCheck.alerts.length,\n        recommendations: healthCheck.recommendations.length\n      };\n\n      return this.success(basicHealth, 'Health check completed successfully');\n    } catch (error) {\n      this.logger.error('Health check failed', { error });\n      return this.internalError('Health check failed');\n    }\n  }\n\n  /**\n   * Detailed health check endpoint - returns comprehensive system health\n   * GET /health/detailed\n   */\n  public async getDetailedHealth(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {\n    this.logger.info('Detailed health check requested');\n\n    try {\n      const includeHistory = event.queryStringParameters?.includeHistory === 'true';\n      \n      const healthCheck = await this.healthService.performHealthCheck();\n      \n      // Record the health check\n      await this.monitoringService.recordHealthHistory(healthCheck);\n      \n      // Get uptime statistics\n      const uptime = await this.monitoringService.getUptimeStats();\n      \n      let history = undefined;\n      if (includeHistory) {\n        const historyRequest: GetHealthHistoryRequest = {\n          timeRange: 'day',\n          resolution: 'hour'\n        };\n        const historyResponse = await this.monitoringService.getHealthHistory(historyRequest);\n        history = historyResponse.entries.slice(-24); // Last 24 hours\n      }\n\n      const response: GetHealthResponse = {\n        health: healthCheck,\n        history,\n        uptime\n      };\n\n      return this.success(response, 'Detailed health check completed successfully');\n    } catch (error) {\n      this.logger.error('Detailed health check failed', { error });\n      return this.internalError('Detailed health check failed');\n    }\n  }\n\n  /**\n   * Performance metrics endpoint - returns performance data and trends\n   * GET /health/performance\n   */\n  public async getPerformanceMetrics(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {\n    this.logger.info('Performance metrics requested');\n\n    try {\n      const timeRange = (event.queryStringParameters?.timeRange as 'hour' | 'day' | 'week' | 'month') || 'day';\n      const includeHistorical = event.queryStringParameters?.includeHistorical === 'true';\n\n      // Get current performance metrics from health check\n      const healthCheck = await this.healthService.performHealthCheck();\n      const currentMetrics = healthCheck.performance;\n\n      // Record current metrics\n      await this.monitoringService.recordMetrics(currentMetrics);\n\n      let historical = undefined;\n      if (includeHistorical) {\n        historical = await this.monitoringService.getPerformanceTrends(timeRange);\n      }\n\n      const response: GetHealthPerformanceMetricsResponse = {\n        current: currentMetrics,\n        historical,\n        trends: currentMetrics.trends\n      };\n\n      return this.success(response, 'Performance metrics retrieved successfully');\n    } catch (error) {\n      this.logger.error('Performance metrics retrieval failed', { error });\n      return this.internalError('Performance metrics retrieval failed');\n    }\n  }\n\n  /**\n   * Database health endpoint - returns database connectivity and performance\n   * GET /health/database\n   */\n  public async getDatabaseHealth(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {\n    this.logger.info('Database health check requested');\n\n    try {\n      const healthCheck = await this.healthService.performHealthCheck();\n      const databaseHealth = healthCheck.dependencies.dynamodb;\n\n      // Additional database-specific metrics\n      const databaseMetrics = {\n        ...databaseHealth,\n        timestamp: healthCheck.timestamp,\n        environment: {\n          region: healthCheck.environment.region,\n          stage: healthCheck.environment.stage\n        },\n        dataQuality: healthCheck.dataQuality.checks.filter(check => \n          check.table.includes('Users') || \n          check.table.includes('Sessions') || \n          check.table.includes('Goals') || \n          check.table.includes('Analytics')\n        )\n      };\n\n      return this.success(databaseMetrics, 'Database health check completed successfully');\n    } catch (error) {\n      this.logger.error('Database health check failed', { error });\n      return this.internalError('Database health check failed');\n    }\n  }\n\n  /**\n   * Storage health endpoint - returns S3 and storage system health\n   * GET /health/storage\n   */\n  public async getStorageHealth(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {\n    this.logger.info('Storage health check requested');\n\n    try {\n      const healthCheck = await this.healthService.performHealthCheck();\n      const storageHealth = healthCheck.dependencies.s3;\n\n      const storageMetrics = {\n        ...storageHealth,\n        timestamp: healthCheck.timestamp,\n        environment: {\n          region: healthCheck.environment.region,\n          stage: healthCheck.environment.stage\n        },\n        alerts: healthCheck.alerts.filter(alert => \n          alert.category === 'availability' || \n          alert.source.toLowerCase().includes('s3')\n        )\n      };\n\n      return this.success(storageMetrics, 'Storage health check completed successfully');\n    } catch (error) {\n      this.logger.error('Storage health check failed', { error });\n      return this.internalError('Storage health check failed');\n    }\n  }\n\n  /**\n   * Services overview endpoint - returns all service health overview\n   * GET /health/services\n   */\n  public async getServicesOverview(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {\n    this.logger.info('Services overview requested');\n\n    try {\n      const healthCheck = await this.healthService.performHealthCheck();\n\n      const servicesOverview = {\n        timestamp: healthCheck.timestamp,\n        overallStatus: healthCheck.status,\n        services: {\n          database: {\n            service: 'DynamoDB',\n            status: healthCheck.dependencies.dynamodb.status,\n            responseTime: healthCheck.dependencies.dynamodb.connectivity.responseTime,\n            tables: healthCheck.dependencies.dynamodb.tables.length,\n            errors: healthCheck.dependencies.dynamodb.tables.reduce((sum, table) => sum + table.errors.length, 0)\n          },\n          storage: {\n            service: 'S3',\n            status: healthCheck.dependencies.s3.status,\n            responseTime: healthCheck.dependencies.s3.connectivity.responseTime,\n            buckets: healthCheck.dependencies.s3.buckets.length,\n            errors: healthCheck.dependencies.s3.buckets.reduce((sum, bucket) => sum + bucket.errors.length, 0)\n          },\n          external: healthCheck.dependencies.external.map(ext => ({\n            service: ext.serviceName,\n            status: ext.status,\n            responseTime: ext.responseTime,\n            uptime: ext.uptime,\n            errors: ext.errors.length\n          }))\n        },\n        performance: {\n          averageResponseTime: healthCheck.performance.throughput.averageResponseTime,\n          errorRate: healthCheck.performance.errors.errorRate,\n          memoryUsage: healthCheck.performance.memory.utilizationPercentage,\n          throughput: healthCheck.performance.throughput.requestsPerSecond\n        },\n        summary: {\n          totalServices: 2 + healthCheck.dependencies.external.length,\n          healthyServices: [\n            healthCheck.dependencies.dynamodb.status === 'healthy' ? 1 : 0,\n            healthCheck.dependencies.s3.status === 'healthy' ? 1 : 0,\n            ...healthCheck.dependencies.external.map(ext => ext.status === 'healthy' ? 1 : 0)\n          ].reduce((sum, count) => sum + count, 0),\n          alerts: healthCheck.alerts.length,\n          recommendations: healthCheck.recommendations.length\n        }\n      };\n\n      return this.success(servicesOverview, 'Services overview retrieved successfully');\n    } catch (error) {\n      this.logger.error('Services overview retrieval failed', { error });\n      return this.internalError('Services overview retrieval failed');\n    }\n  }\n\n  /**\n   * Alerts endpoint - returns current alerts and recommendations\n   * GET /health/alerts\n   */\n  public async getAlerts(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {\n    this.logger.info('Alerts requested');\n\n    try {\n      const severity = event.queryStringParameters?.severity as 'info' | 'warning' | 'error' | 'critical';\n      const category = event.queryStringParameters?.category as 'performance' | 'availability' | 'data_quality' | 'security' | 'capacity';\n      const limit = parseInt(event.queryStringParameters?.limit || '50');\n\n      const healthCheck = await this.healthService.performHealthCheck();\n      let alerts = healthCheck.alerts;\n\n      // Apply filters\n      if (severity) {\n        alerts = alerts.filter(alert => alert.severity === severity);\n      }\n      if (category) {\n        alerts = alerts.filter(alert => alert.category === category);\n      }\n      \n      // Apply limit\n      alerts = alerts.slice(0, limit);\n\n      // Calculate summary statistics\n      const allAlerts = healthCheck.alerts;\n      const summary = {\n        total: allAlerts.length,\n        active: allAlerts.filter(a => !a.resolvedAt).length,\n        resolved: allAlerts.filter(a => a.resolvedAt).length,\n        acknowledged: allAlerts.filter(a => a.acknowledged).length,\n        bySeverity: {\n          critical: allAlerts.filter(a => a.severity === 'critical').length,\n          error: allAlerts.filter(a => a.severity === 'error').length,\n          warning: allAlerts.filter(a => a.severity === 'warning').length,\n          info: allAlerts.filter(a => a.severity === 'info').length\n        },\n        byCategory: {\n          performance: allAlerts.filter(a => a.category === 'performance').length,\n          availability: allAlerts.filter(a => a.category === 'availability').length,\n          data_quality: allAlerts.filter(a => a.category === 'data_quality').length,\n          security: allAlerts.filter(a => a.category === 'security').length,\n          capacity: allAlerts.filter(a => a.category === 'capacity').length\n        }\n      };\n\n      const response: GetAlertsResponse = {\n        alerts,\n        summary\n      };\n\n      return this.success(response, 'Alerts retrieved successfully');\n    } catch (error) {\n      this.logger.error('Alerts retrieval failed', { error });\n      return this.internalError('Alerts retrieval failed');\n    }\n  }\n\n  /**\n   * Health history endpoint - returns historical health data and trends\n   * GET /health/history\n   */\n  public async getHealthHistory(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {\n    this.logger.info('Health history requested');\n\n    try {\n      const timeRange = (event.queryStringParameters?.timeRange as 'hour' | 'day' | 'week' | 'month') || 'day';\n      const resolution = event.queryStringParameters?.resolution as 'minute' | 'hour' | 'day';\n      const components = event.queryStringParameters?.components?.split(',');\n\n      const request: GetHealthHistoryRequest = {\n        timeRange,\n        resolution,\n        components\n      };\n\n      const response = await this.monitoringService.getHealthHistory(request);\n\n      return this.success(response, 'Health history retrieved successfully');\n    } catch (error) {\n      this.logger.error('Health history retrieval failed', { error });\n      return this.internalError('Health history retrieval failed');\n    }\n  }\n\n  /**\n   * Health report endpoint - generates comprehensive health reports\n   * POST /health/report\n   */\n  public async generateHealthReport(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {\n    this.logger.info('Health report generation requested');\n\n    try {\n      const body = JSON.parse(event.body || '{}') as GenerateHealthReportRequest;\n      \n      // Validate request\n      if (!body.timeRange?.start || !body.timeRange?.end) {\n        return this.badRequest('Time range is required');\n      }\n\n      const response = await this.monitoringService.generateHealthReport(body);\n\n      return this.success(response, 'Health report generated successfully');\n    } catch (error) {\n      this.logger.error('Health report generation failed', { error });\n      return this.internalError('Health report generation failed');\n    }\n  }\n\n  /**\n   * Acknowledge alert endpoint - acknowledge a specific alert\n   * PUT /health/alerts/{alertId}/acknowledge\n   */\n  public async acknowledgeAlert(event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> {\n    this.logger.info('Alert acknowledgment requested');\n\n    try {\n      const alertId = event.pathParameters?.alertId;\n      const body = JSON.parse(event.body || '{}');\n      const acknowledgedBy = body.acknowledgedBy || 'system';\n\n      if (!alertId) {\n        return this.badRequest('Alert ID is required');\n      }\n\n      await this.monitoringService.acknowledgeAlert(alertId, acknowledgedBy);\n\n      return this.success({ alertId, acknowledgedBy, acknowledgedAt: new Date().toISOString() }, 'Alert acknowledged successfully');\n    } catch (error) {\n      this.logger.error('Alert acknowledgment failed', { error });\n      return this.internalError('Alert acknowledgment failed');\n    }\n  }\n}\n\n// Route handler for different endpoints\nconst healthHandler = new HealthHandler();\n\n// Export different endpoints\nexport const handler = healthHandler.withoutAuth(async (event: APIGatewayProxyEvent) => {\n  const path = event.pathParameters?.proxy || event.resource?.split('/').pop() || '';\n  const method = event.httpMethod;\n\n  try {\n    switch (true) {\n      case path === 'detailed' && method === 'GET':\n        return await healthHandler.getDetailedHealth(event);\n      \n      case path === 'performance' && method === 'GET':\n        return await healthHandler.getPerformanceMetrics(event);\n      \n      case path === 'database' && method === 'GET':\n        return await healthHandler.getDatabaseHealth(event);\n      \n      case path === 'storage' && method === 'GET':\n        return await healthHandler.getStorageHealth(event);\n      \n      case path === 'services' && method === 'GET':\n        return await healthHandler.getServicesOverview(event);\n      \n      case path === 'alerts' && method === 'GET':\n        return await healthHandler.getAlerts(event);\n      \n      case path === 'history' && method === 'GET':\n        return await healthHandler.getHealthHistory(event);\n      \n      case path === 'report' && method === 'POST':\n        return await healthHandler.generateHealthReport(event);\n      \n      case path.includes('alerts') && path.includes('acknowledge') && method === 'PUT':\n        return await healthHandler.acknowledgeAlert(event);\n      \n      default:\n        // Default to basic health check\n        return await healthHandler.checkHealth(event);\n    }\n  } catch (error) {\n    // Health handler routing error - return error response\n    return {\n      statusCode: 500,\n      headers: {\n        'Content-Type': 'application/json',\n        'Access-Control-Allow-Origin': '*',\n        'Access-Control-Allow-Headers': 'Content-Type,Authorization',\n        'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'\n      },\n      body: JSON.stringify({\n        success: false,\n        error: 'Internal server error',\n        timestamp: new Date().toISOString(),\n        version: '2.0.0'\n      })\n    };\n  }\n});", "import { APIGatewayProxyEvent, APIGatewayProxyResult, APIGatewayTokenAuthorizerEvent, APIGatewayAuthorizerResult } from 'aws-lambda';\n\n// Base Handler Types\nexport type PublicHandler = (event: APIGatewayProxyEvent) => Promise<APIGatewayProxyResult>;\nexport type AuthenticatedHandler = (event: APIGatewayProxyEvent, userId: string) => Promise<APIGatewayProxyResult>;\nexport type AuthorizerHandler = (event: APIGatewayTokenAuthorizerEvent) => Promise<APIGatewayAuthorizerResult>;\n\n// Common API Response Structure\nexport interface ApiResponse<T = any> {\n  success: boolean;\n  data?: T;\n  message?: string;\n  error?: string;\n  timestamp: string;\n  version: string;\n}\n\n// Error Types\nexport enum ErrorCode {\n  UNAUTHORIZED = 'UNAUTHORIZED',\n  FORBIDDEN = 'FORBIDDEN',\n  NOT_FOUND = 'NOT_FOUND',\n  VALIDATION_ERROR = 'VALIDATION_ERROR',\n  INTERNAL_ERROR = 'INTERNAL_ERROR',\n  RATE_LIMITED = 'RATE_LIMITED'\n}\n\nexport class ApiError extends Error {\n  constructor(\n    public code: ErrorCode,\n    message: string,\n    public details?: any\n  ) {\n    super(message);\n    this.name = 'ApiError';\n  }\n}\n\n// User Context\nexport interface UserContext {\n  userId: string;\n  email: string;\n  role?: string;\n  permissions?: string[];\n}\n\n// JWT Token Payload\nexport interface JwtPayload {\n  userId: string;\n  email: string;\n  role?: string;\n  iat: number;\n  exp: number;\n}\n\n// Database Entities\nexport interface User {\n  userId: string;\n  email: string;\n  name?: string;\n  role: string;\n  createdAt: string;\n  updatedAt: string;\n  lastLoginAt?: string;\n  isActive: boolean;\n}\n\n// Auth-related types\nexport interface UserRegistrationRequest {\n  email: string;\n  password: string;\n  name?: string;\n}\n\nexport interface UserLoginRequest {\n  email: string;\n  password: string;\n}\n\nexport interface AuthResponse {\n  user: User;\n  token: string;\n  refreshToken: string;\n  expiresIn: number;\n}\n\nexport interface RefreshTokenRequest {\n  refreshToken: string;\n}\n\n// Enhanced Session Types for comprehensive session management\nexport interface StudySession {\n  sessionId: string;\n  userId: string;\n  provider: string;\n  exam: string;\n  status: 'active' | 'completed' | 'paused' | 'expired';\n  startTime: string;\n  endTime?: string;\n  \n  // Question Management\n  totalQuestions: number;\n  questionsAnswered: number;\n  correctAnswers: number;\n  currentQuestionIndex: number;\n  selectedQuestionIds: string[]; // Pre-selected questions for the session\n  \n  // Session Configuration\n  sessionConfig: SessionConfiguration;\n  \n  // Progress Tracking\n  progress: SessionProgress;\n  \n  // Performance Analytics\n  analytics: SessionAnalytics;\n  \n  // Timestamps and TTL\n  createdAt: string;\n  updatedAt: string;\n  lastActivityAt: string;\n  expiresAt: number; // DynamoDB TTL (Unix timestamp)\n}\n\n// Session configuration options\nexport interface SessionConfiguration {\n  questionCount: number;\n  timeLimit?: number; // in minutes, optional\n  difficulty?: 'easy' | 'medium' | 'hard';\n  topics?: string[];\n  serviceCategories?: string[];\n  awsServices?: string[];\n  questionTypes?: ('single_choice' | 'multiple_choice')[];\n  shuffleQuestions: boolean;\n  immediateResultsFeedback: boolean;\n  allowReview: boolean;\n}\n\n// Detailed progress tracking\nexport interface SessionProgress {\n  percentage: number; // 0-100\n  questionsCorrect: number;\n  questionsIncorrect: number;\n  questionsSkipped: number;\n  averageTimePerQuestion: number; // in seconds\n  timeSpent: number; // total time spent in seconds\n  streakCurrent: number;\n  streakBest: number;\n}\n\n// Session performance analytics\nexport interface SessionAnalytics {\n  difficultyBreakdown: {\n    easy: { correct: number; total: number };\n    medium: { correct: number; total: number };\n    hard: { correct: number; total: number };\n  };\n  topicPerformance: { [topic: string]: { correct: number; total: number } };\n  servicePerformance: { [service: string]: { correct: number; total: number } };\n  questionTypePerformance: {\n    single_choice: { correct: number; total: number };\n    multiple_choice: { correct: number; total: number };\n  };\n  timeAnalytics: {\n    fastestAnswer: number; // in seconds\n    slowestAnswer: number; // in seconds\n    averageAnswerTime: number; // in seconds\n  };\n}\n\n// Answer submission for a question in a session\nexport interface SessionAnswer {\n  questionId: string;\n  questionIndex: number;\n  userAnswer: string | string[];\n  isCorrect: boolean;\n  timeSpent: number; // in seconds\n  submittedAt: string;\n  explanation?: string;\n}\n\n// Session state for current question delivery\nexport interface SessionState {\n  sessionId: string;\n  currentQuestion: Question;\n  questionIndex: number;\n  progress: SessionProgress;\n  timeRemaining?: number; // if timed session\n  canGoBack: boolean;\n  canSkip: boolean;\n}\n\n// Session results when completed\nexport interface SessionResults {\n  sessionId: string;\n  finalScore: number; // percentage\n  questionsCorrect: number;\n  questionsTotal: number;\n  timeSpent: number; // in seconds\n  performance: SessionAnalytics;\n  grade: 'A' | 'B' | 'C' | 'D' | 'F';\n  passed: boolean;\n  recommendations: string[];\n  completedAt: string;\n}\n\nexport interface StudyGoal {\n  goalId: string;\n  userId: string;\n  title: string;\n  description?: string;\n  targetDate: string;\n  status: 'active' | 'completed' | 'paused';\n  progress: number; // 0-100\n  metrics: {\n    questionsTarget: number;\n    questionsCompleted: number;\n    accuracyTarget: number;\n    currentAccuracy: number;\n  };\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport interface AnalyticsEvent {\n  userId: string;\n  eventType: string;\n  eventData: any;\n  timestamp: string;\n  sessionId?: string;\n  provider?: string;\n  exam?: string;\n  expiresAt: number; // TTL\n}\n\nexport interface Provider {\n  id: string;\n  name: string;\n  description: string;\n  exams: Exam[];\n}\n\nexport interface Exam {\n  id: string;\n  name: string;\n  description: string;\n  questionCount: number;\n  duration?: number;\n  passingScore?: number;\n}\n\nexport interface Question {\n  questionId: string;\n  questionNumber: number;\n  provider: string;\n  exam: string;\n  text: string;\n  options: string[][];\n  questionType: 'single_choice' | 'multiple_choice';\n  expectedAnswers: number;\n  correctAnswer: string | string[];\n  explanation?: string;\n  difficulty: 'easy' | 'medium' | 'hard';\n  topics: string[];\n  serviceCategory?: string;\n  awsServices?: string[];\n  keywords?: string[];\n  createdAt: string;\n  parsingConfidence?: number;\n  hasExplanation?: boolean;\n}\n\n// Raw question data from S3 (matches study_data_final.json structure)\nexport interface RawQuestionData {\n  question_number: number;\n  question: {\n    text: string;\n    options: string[][];\n    question_type: 'single_choice' | 'multiple_choice';\n    expected_answers: number;\n    topic: string;\n    service_category?: string;\n    aws_services?: string[];\n  };\n  answer?: {\n    correct_answer: string;\n    explanation?: string;\n    keywords?: string[];\n    parsing_confidence?: number;\n    source?: string;\n  };\n  study_metadata?: {\n    difficulty: 'easy' | 'medium' | 'hard';\n    completeness: string;\n    question_preview: string;\n    has_explanation: boolean;\n    confidence_level: string;\n  };\n}\n\n// Session Request/Response Types\nexport interface CreateSessionRequest {\n  provider: string;\n  exam: string;\n  config?: Partial<SessionConfiguration>;\n}\n\nexport interface UpdateSessionRequest {\n  config?: Partial<SessionConfiguration>;\n  status?: 'paused' | 'active';\n}\n\nexport interface SubmitAnswerRequest {\n  questionId: string;\n  answer: string | string[];\n  timeSpent?: number; // in seconds\n}\n\nexport interface SubmitAnswerResponse {\n  isCorrect: boolean;\n  correctAnswer: string | string[];\n  explanation?: string;\n  nextQuestion?: Question;\n  sessionProgress: SessionProgress;\n  sessionCompleted: boolean;\n}\n\nexport interface GetSessionResponse {\n  session: StudySession;\n  currentState?: SessionState;\n}\n\nexport interface ListSessionsRequest {\n  status?: 'active' | 'completed' | 'paused';\n  provider?: string;\n  exam?: string;\n  limit?: number;\n  lastEvaluatedKey?: string;\n}\n\nexport interface CompleteSessionResponse {\n  results: SessionResults;\n  achievements?: Achievement[];\n}\n\n// Achievement system for gamification\nexport interface Achievement {\n  id: string;\n  name: string;\n  description: string;\n  type: 'accuracy' | 'speed' | 'streak' | 'completion' | 'improvement';\n  criteria: any;\n  earnedAt: string;\n}\n\nexport interface CreateGoalRequest {\n  title: string;\n  description?: string;\n  targetDate: string;\n  questionsTarget: number;\n  accuracyTarget: number;\n}\n\n// ============================================================================\n// AI-POWERED STUDY FEATURES TYPES - Phase 5\n// ============================================================================\n\n// Enhanced Goal Types with AI Features\nexport interface EnhancedStudyGoal extends StudyGoal {\n  aiOptimized: boolean;\n  adaptiveSettings: {\n    difficultyLevel: 'adaptive' | 'fixed';\n    spacedRepetition: boolean;\n    personalizedSchedule: boolean;\n  };\n  milestones: GoalMilestone[];\n  studyPlan: StudyPlanReference;\n  aiRecommendations: AIRecommendation[];\n  learningPath: LearningPathNode[];\n  achievements: GoalAchievement[];\n  analyticsSnapshot: GoalAnalyticsSnapshot;\n}\n\nexport interface GoalMilestone {\n  milestoneId: string;\n  title: string;\n  description?: string;\n  targetDate: string;\n  completed: boolean;\n  completedAt?: string;\n  requirements: MilestoneRequirement[];\n  rewards: string[];\n  aiGenerated: boolean;\n}\n\nexport interface MilestoneRequirement {\n  type: 'accuracy' | 'questions' | 'time' | 'topics' | 'sessions';\n  target: number;\n  current: number;\n  description: string;\n}\n\nexport interface StudyPlanReference {\n  planId: string;\n  generatedAt: string;\n  duration: number; // days\n  adaptiveAdjustments: number;\n  lastOptimized: string;\n}\n\nexport interface AIRecommendation {\n  id: string;\n  type: 'study_schedule' | 'difficulty_adjustment' | 'topic_focus' | 'break_suggestion';\n  priority: 'high' | 'medium' | 'low';\n  title: string;\n  description: string;\n  reasoning: string;\n  actionItems: string[];\n  validUntil: string;\n  applied: boolean;\n  appliedAt?: string;\n  effectiveness?: number; // 0-100, measured after application\n}\n\nexport interface LearningPathNode {\n  nodeId: string;\n  topic: string;\n  estimatedTime: number; // minutes\n  prerequisites: string[];\n  completed: boolean;\n  completedAt?: string;\n  difficultyLevel: number; // 1-5\n  adaptiveWeight: number; // Higher weight = more important\n  nextReviewDate?: string; // For spaced repetition\n}\n\nexport interface GoalAchievement {\n  achievementId: string;\n  name: string;\n  description: string;\n  earnedAt: string;\n  category: 'progress' | 'consistency' | 'improvement' | 'mastery';\n  points: number;\n}\n\nexport interface GoalAnalyticsSnapshot {\n  lastUpdated: string;\n  currentAccuracy: number;\n  weeklyProgress: number;\n  studyVelocity: number; // questions per day\n  difficultyTrend: 'increasing' | 'decreasing' | 'stable';\n  topicMastery: { [topic: string]: number }; // 0-100 mastery score\n  predictedCompletionDate: string;\n  confidenceScore: number; // 0-100\n}\n\n// Spaced Repetition and Adaptive Learning Types\nexport interface SpacedRepetitionItem {\n  itemId: string;\n  userId: string;\n  conceptId: string; // Could be questionId, topicId, or skill\n  conceptType: 'question' | 'topic' | 'skill';\n  \n  // SM-2 Algorithm fields\n  easinessFactor: number; // 1.3 - 2.5, default 2.5\n  interval: number; // Days until next review\n  repetition: number; // Number of successful reviews\n  nextReviewDate: string;\n  \n  // Performance tracking\n  totalAttempts: number;\n  correctAttempts: number;\n  lastAttemptDate: string;\n  averageResponseTime: number; // milliseconds\n  masteryLevel: 'learning' | 'reviewing' | 'mastered';\n  \n  // Difficulty adaptation\n  currentDifficulty: number; // 0-100\n  optimalDifficulty: number; // Target difficulty for user\n  difficultyAdjustments: DifficultyAdjustment[];\n  \n  // Context and metadata\n  provider?: string;\n  exam?: string;\n  topic?: string;\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport interface DifficultyAdjustment {\n  adjustmentDate: string;\n  previousDifficulty: number;\n  newDifficulty: number;\n  reason: string;\n  performanceMetrics: {\n    accuracy: number;\n    responseTime: number;\n    confidence: number;\n  };\n}\n\nexport interface LearningSessionPlan {\n  planId: string;\n  userId: string;\n  sessionType: 'review' | 'learning' | 'mixed' | 'assessment';\n  \n  // Content selection\n  selectedItems: SpacedRepetitionItem[];\n  questionPool: Question[];\n  targetDifficulty: number;\n  adaptiveDifficultyEnabled: boolean;\n  \n  // Session parameters\n  estimatedDuration: number; // minutes\n  targetQuestions: number;\n  difficultyDistribution: {\n    easy: number;\n    medium: number;\n    hard: number;\n  };\n  \n  // Spaced repetition settings\n  reviewPriority: 'overdue' | 'due_today' | 'upcoming' | 'mixed';\n  newContentRatio: number; // 0-1, percentage of new vs review content\n  \n  // AI optimization\n  personalizedOrder: string[]; // Question IDs in optimized order\n  difficultyProgression: number[]; // Difficulty progression through session\n  breakSuggestions: number[]; // Suggested break points (question indices)\n  \n  createdAt: string;\n  validUntil: string;\n}\n\n// AI Recommendation System Types\nexport interface AIStudyRecommendation extends RecommendationItem {\n  confidence: number; // 0-100, confidence in recommendation\n  personalizedData: {\n    userPerformanceFactors: UserPerformanceFactors;\n    adaptiveLearningInsights: AdaptiveLearningInsights;\n    behavioralPatterns: BehavioralPatterns;\n  };\n  dynamicAdjustments: DynamicAdjustment[];\n  successMetrics: SuccessMetric[];\n  followUpActions: FollowUpAction[];\n}\n\nexport interface UserPerformanceFactors {\n  overallAccuracy: number;\n  accuracyTrend: 'improving' | 'stable' | 'declining';\n  strongTopics: string[];\n  weakTopics: string[];\n  averageStudyTime: number; // minutes per day\n  studyConsistency: number; // 0-100\n  difficultyPreference: 'easy' | 'medium' | 'hard' | 'adaptive';\n  learningVelocity: number; // questions mastered per week\n}\n\nexport interface AdaptiveLearningInsights {\n  spacedRepetitionEffectiveness: number; // 0-100\n  optimalReviewInterval: number; // hours\n  difficultyAdaptationSuccess: number; // 0-100\n  masteredConcepts: number;\n  strugglingConcepts: number;\n  overdueReviews: number;\n  predictedPerformanceGain: number; // Expected improvement with recommendation\n}\n\nexport interface BehavioralPatterns {\n  preferredStudyTimes: string[]; // e.g., ['morning', 'evening']\n  averageSessionLength: number; // minutes\n  studyFrequency: number; // sessions per week\n  breakPreferences: BreakPreference;\n  motivationFactors: MotivationFactor[];\n  procrastinationRisk: 'low' | 'medium' | 'high';\n  studyConsistency: number; // 0-100, consistency score\n}\n\nexport interface BreakPreference {\n  frequency: number; // minutes between breaks\n  duration: number; // break duration in minutes\n  type: 'short' | 'medium' | 'long';\n}\n\nexport interface MotivationFactor {\n  factor: 'achievements' | 'progress' | 'competition' | 'learning' | 'goals';\n  weight: number; // 0-1, importance to user\n  effectiveness: number; // 0-100, how well it works for user\n}\n\nexport interface DynamicAdjustment {\n  parameter: string;\n  originalValue: any;\n  adjustedValue: any;\n  reason: string;\n  expectedImpact: number; // 0-100\n}\n\nexport interface SuccessMetric {\n  metric: string;\n  currentValue: number;\n  targetValue: number;\n  timeframe: string; // e.g., '1 week', '1 month'\n  probability: number; // 0-100, probability of achieving target\n}\n\nexport interface FollowUpAction {\n  action: string;\n  timing: string; // when to perform action\n  condition: string; // condition that triggers action\n  priority: 'high' | 'medium' | 'low';\n}\n\n// Enhanced Study Plan Types\nexport interface AIStudyPlan extends StudyPlan {\n  aiOptimizations: {\n    personalizedScheduling: boolean;\n    adaptiveDifficulty: boolean;\n    spacedRepetitionIntegration: boolean;\n    behaviorBasedAdjustments: boolean;\n  };\n  performancePredictions: {\n    expectedAccuracyImprovement: number;\n    estimatedCompletionDate: string;\n    confidenceLevel: number;\n  };\n  contingencyPlans: ContingencyPlan[];\n  motivationalElements: MotivationalElement[];\n}\n\nexport interface ContingencyPlan {\n  trigger: string; // What triggers this plan\n  adjustments: string[]; // What adjustments to make\n  timeline: string; // How long to try adjustments\n}\n\nexport interface MotivationalElement {\n  type: 'achievement' | 'progress_visualization' | 'competition' | 'reward';\n  description: string;\n  triggerConditions: string[];\n  impact: 'high' | 'medium' | 'low';\n}\n\n// Performance Prediction and Analytics\nexport interface PerformancePrediction {\n  userId: string;\n  conceptId: string;\n  \n  // Predictions\n  predictedAccuracy: number; // 0-100\n  predictedResponseTime: number; // milliseconds\n  confidenceScore: number; // 0-100, confidence in predictions\n  \n  // Model factors\n  factors: {\n    historicalPerformance: number; // Weight: 40%\n    timeSinceLastPractice: number; // Weight: 20%\n    conceptDifficulty: number; // Weight: 15%\n    userSkillLevel: number; // Weight: 15%\n    contextualFactors: number; // Weight: 10%\n  };\n  \n  // Recommendations\n  recommendedAction: 'practice' | 'review' | 'skip' | 'intensive_study';\n  optimalTimingHours: number; // Optimal time until next practice\n  \n  calculatedAt: string;\n}\n\n// Recommendation Feedback System\nexport interface RecommendationFeedback {\n  recommendationId: string;\n  userId: string;\n  feedbackType: 'helpful' | 'not_helpful' | 'partially_helpful' | 'irrelevant';\n  effectiveness: number; // 0-100, how effective was the recommendation\n  appliedSuggestions: string[];\n  ignoredSuggestions: string[];\n  userComments?: string;\n  performanceChange: {\n    beforeAccuracy: number;\n    afterAccuracy: number;\n    beforeStudyTime: number;\n    afterStudyTime: number;\n    timeframe: string;\n  };\n  submittedAt: string;\n}\n\n// Achievement System for Gamification\nexport interface AchievementDefinition {\n  id: string;\n  name: string;\n  description: string;\n  type: 'accuracy' | 'speed' | 'streak' | 'completion' | 'improvement' | 'consistency';\n  criteria: AchievementCriteria;\n  points: number;\n  badge?: string;\n  rarity: 'common' | 'uncommon' | 'rare' | 'epic' | 'legendary';\n}\n\nexport interface AchievementCriteria {\n  metric: string;\n  threshold: number;\n  timeframe?: string;\n  conditions?: { [key: string]: any };\n}\n\nexport interface UserAchievementProgress {\n  userId: string;\n  achievementId: string;\n  currentProgress: number;\n  targetProgress: number;\n  progressPercentage: number;\n  isCompleted: boolean;\n  completedAt?: string;\n  lastUpdated: string;\n}\n\n// Study Session Enhancement Types\nexport interface EnhancedStudySession extends StudySession {\n  aiEnhancements: {\n    adaptiveDifficultyEnabled: boolean;\n    spacedRepetitionIntegrated: boolean;\n    personalizedOrdering: boolean;\n    realTimeAdjustments: boolean;\n  };\n  learningMetrics: {\n    conceptsMastered: string[];\n    conceptsReviewed: string[];\n    difficultyAdjustments: DifficultyAdjustment[];\n    optimalBreakPoints: number[];\n    retentionPrediction: number; // 0-100\n  };\n  aiRecommendations: {\n    nextSessionType: 'review' | 'learning' | 'mixed' | 'assessment';\n    optimalTimingHours: number;\n    suggestedTopics: string[];\n    difficultyRecommendation: 'increase' | 'decrease' | 'maintain';\n  };\n}\n\n// API Request/Response Types for AI Features\nexport interface GenerateRecommendationsRequest {\n  includeStudyPlan?: boolean;\n  planDuration?: number; // days\n  focusAreas?: string[];\n  urgency?: 'low' | 'medium' | 'high';\n  timeAvailable?: number; // minutes per day\n}\n\nexport interface GenerateRecommendationsResponse {\n  recommendations: AIStudyRecommendation[];\n  studyPlan?: AIStudyPlan;\n  lastUpdated: string;\n  metadata: {\n    totalRecommendations: number;\n    highPriorityCount: number;\n    averageConfidence: number;\n    planIncluded: boolean;\n  };\n}\n\nexport interface SessionRecommendationsRequest {\n  availableTime: number; // minutes\n  preferredDifficulty?: 'easy' | 'medium' | 'hard' | 'adaptive';\n  focusTopics?: string[];\n  sessionType?: 'review' | 'learning' | 'mixed' | 'assessment';\n}\n\nexport interface SessionRecommendationsResponse {\n  sessionPlan: LearningSessionPlan;\n  recommendations: AIStudyRecommendation[];\n  sessionInfo: {\n    estimatedDuration: number;\n    targetQuestions: number;\n    sessionType: string;\n    difficultyDistribution: { easy: number; medium: number; hard: number };\n    breakSuggestions: number[];\n    personalizedOrder: boolean;\n  };\n}\n\n// Learning Analytics Enhancement\nexport interface LearningAnalytics extends UserProgressAnalytics {\n  aiInsights: {\n    learningEfficiency: number; // 0-100\n    retentionRate: number; // 0-100\n    optimalStudyPattern: string;\n    predictedPerformance: PerformancePrediction[];\n    recommendedAdjustments: string[];\n  };\n  adaptiveLearningStats: {\n    spacedRepetitionItems: number;\n    masteryProgression: { [concept: string]: number };\n    difficultyAdaptationSuccess: number;\n    overallLearningVelocity: number;\n  };\n}\n\nexport interface GetQuestionsRequest {\n  provider: string;\n  exam: string;\n  limit?: number;\n  offset?: number;\n  difficulty?: 'easy' | 'medium' | 'hard';\n  topics?: string[];\n  serviceCategory?: string;\n  awsServices?: string[];\n  search?: string;\n  hasExplanation?: boolean;\n  questionType?: 'single_choice' | 'multiple_choice';\n}\n\nexport interface QuestionFilter {\n  difficulty?: 'easy' | 'medium' | 'hard';\n  topics?: string[];\n  serviceCategory?: string;\n  awsServices?: string[];\n  search?: string;\n  hasExplanation?: boolean;\n  questionType?: 'single_choice' | 'multiple_choice';\n}\n\nexport interface PaginationOptions {\n  limit: number;\n  offset: number;\n}\n\nexport interface QuestionSearchResult {\n  questions: Question[];\n  totalCount: number;\n  hasMore: boolean;\n  filters: {\n    availableTopics: string[];\n    availableServiceCategories: string[];\n    availableAwsServices: string[];\n    difficultyDistribution: { [key: string]: number };\n  };\n}\n\n// ============================================================================\n// ANALYTICS TYPES - Phase 4: Analytics & Progress Tracking\n// ============================================================================\n\n// User Progress Analytics\nexport interface UserProgressAnalytics {\n  userId: string;\n  overallStats: OverallProgressStats;\n  providerStats: ProviderProgressStats[];\n  examStats: ExamProgressStats[];\n  recentActivity: RecentActivityStats;\n  achievements: Achievement[];\n  calculatedAt: string;\n}\n\nexport interface OverallProgressStats {\n  totalSessions: number;\n  completedSessions: number;\n  totalQuestions: number;\n  correctAnswers: number;\n  overallAccuracy: number;\n  totalStudyTime: number; // in seconds\n  averageSessionScore: number;\n  bestSessionScore: number;\n  currentStreak: number;\n  longestStreak: number;\n  lastActivityDate: string;\n  studyDaysCount: number;\n}\n\nexport interface ProviderProgressStats {\n  provider: string;\n  totalSessions: number;\n  completedSessions: number;\n  totalQuestions: number;\n  correctAnswers: number;\n  accuracy: number;\n  studyTime: number;\n  averageScore: number;\n  bestScore: number;\n  lastSessionDate?: string;\n  exams: ExamProgressStats[];\n}\n\nexport interface ExamProgressStats {\n  provider: string;\n  exam: string;\n  totalSessions: number;\n  completedSessions: number;\n  totalQuestions: number;\n  correctAnswers: number;\n  accuracy: number;\n  studyTime: number;\n  averageScore: number;\n  bestScore: number;\n  lastSessionDate?: string;\n  readinessScore: number; // 0-100, calculated readiness for this exam\n  topicMastery: TopicMasteryStats[];\n}\n\nexport interface TopicMasteryStats {\n  topic: string;\n  questionsAnswered: number;\n  correctAnswers: number;\n  accuracy: number;\n  masteryLevel: 'beginner' | 'intermediate' | 'advanced' | 'expert';\n  confidenceScore: number; // 0-100\n  lastPracticed?: string;\n  improvementTrend: 'improving' | 'stable' | 'declining';\n}\n\nexport interface RecentActivityStats {\n  last7Days: DailyActivityStats[];\n  last30Days: DailyActivityStats[];\n  currentWeekStats: WeeklyActivityStats;\n  currentMonthStats: MonthlyActivityStats;\n}\n\nexport interface DailyActivityStats {\n  date: string; // YYYY-MM-DD\n  sessionsCount: number;\n  questionsAnswered: number;\n  correctAnswers: number;\n  studyTimeMinutes: number;\n  accuracy: number;\n}\n\nexport interface WeeklyActivityStats {\n  weekStartDate: string;\n  totalSessions: number;\n  totalQuestions: number;\n  totalCorrect: number;\n  totalStudyTime: number;\n  averageAccuracy: number;\n  studyDays: number;\n}\n\nexport interface MonthlyActivityStats {\n  month: string; // YYYY-MM\n  totalSessions: number;\n  totalQuestions: number;\n  totalCorrect: number;\n  totalStudyTime: number;\n  averageAccuracy: number;\n  studyDays: number;\n}\n\n// Performance Metrics and Trends\nexport interface PerformanceMetrics {\n  userId: string;\n  timeRange: 'week' | 'month' | 'quarter' | 'year' | 'all';\n  trends: PerformanceTrends;\n  comparisons: PerformanceComparisons;\n  insights: PerformanceInsights;\n  calculatedAt: string;\n}\n\nexport interface PerformanceTrends {\n  accuracyTrend: TrendData[];\n  speedTrend: TrendData[];\n  studyTimeTrend: TrendData[];\n  sessionCompletionTrend: TrendData[];\n  difficultyProgressionTrend: DifficultyTrendData[];\n}\n\nexport interface TrendData {\n  date: string;\n  value: number;\n  change?: number; // percentage change from previous period\n}\n\nexport interface DifficultyTrendData {\n  date: string;\n  easy: { accuracy: number; count: number };\n  medium: { accuracy: number; count: number };\n  hard: { accuracy: number; count: number };\n}\n\nexport interface PerformanceComparisons {\n  vsLastPeriod: ComparisonData;\n  vsPersonalBest: ComparisonData;\n  vsAverageUser: ComparisonData; // if available\n}\n\nexport interface ComparisonData {\n  accuracy: { current: number; comparison: number; change: number };\n  speed: { current: number; comparison: number; change: number };\n  studyTime: { current: number; comparison: number; change: number };\n  completion: { current: number; comparison: number; change: number };\n}\n\nexport interface PerformanceInsights {\n  strengths: string[];\n  weaknesses: string[];\n  recommendations: string[];\n  milestoneProgress: MilestoneProgress[];\n}\n\nexport interface MilestoneProgress {\n  milestone: string;\n  description: string;\n  progress: number; // 0-100\n  target: number;\n  current: number;\n  estimatedCompletion?: string;\n}\n\n// Session Analytics and History\nexport interface SessionAnalyticsData {\n  userId: string;\n  sessions: SessionSummary[];\n  aggregatedStats: SessionAggregatedStats;\n  patterns: SessionPatterns;\n  calculatedAt: string;\n}\n\nexport interface SessionSummary {\n  sessionId: string;\n  provider: string;\n  exam: string;\n  startTime: string;\n  endTime?: string;\n  duration: number; // in seconds\n  status: 'active' | 'completed' | 'paused' | 'expired';\n  score: number;\n  questionsTotal: number;\n  questionsCorrect: number;\n  accuracy: number;\n  averageTimePerQuestion: number;\n  difficultyBreakdown: {\n    easy: { correct: number; total: number };\n    medium: { correct: number; total: number };\n    hard: { correct: number; total: number };\n  };\n}\n\nexport interface SessionAggregatedStats {\n  totalSessions: number;\n  completedSessions: number;\n  averageScore: number;\n  averageDuration: number;\n  averageAccuracy: number;\n  bestPerformance: SessionSummary;\n  recentPerformance: SessionSummary[];\n}\n\nexport interface SessionPatterns {\n  preferredStudyTimes: TimeOfDayPattern[];\n  sessionLengthDistribution: SessionLengthPattern;\n  accuracyByTimeOfDay: TimeOfDayAccuracy[];\n  studyStreak: StreakData;\n}\n\nexport interface TimeOfDayPattern {\n  hour: number;\n  sessionCount: number;\n  averageAccuracy: number;\n}\n\nexport interface SessionLengthPattern {\n  short: number; // < 15 minutes\n  medium: number; // 15-60 minutes\n  long: number; // > 60 minutes\n}\n\nexport interface TimeOfDayAccuracy {\n  timeRange: string; // e.g., \"09:00-12:00\"\n  averageAccuracy: number;\n  sessionCount: number;\n}\n\nexport interface StreakData {\n  currentStreak: number;\n  longestStreak: number;\n  streakDates: string[];\n}\n\n// Cross-Provider Comparison Analytics\nexport interface CrossProviderAnalytics {\n  userId: string;\n  providerComparisons: ProviderComparison[];\n  skillTransferability: SkillTransferAnalysis[];\n  recommendations: CrossProviderRecommendations;\n  calculatedAt: string;\n}\n\nexport interface ProviderComparison {\n  provider: string;\n  totalQuestions: number;\n  accuracy: number;\n  averageScore: number;\n  studyTime: number;\n  completionRate: number;\n  strengthAreas: string[];\n  weaknessAreas: string[];\n  relativePerformance: number; // compared to user's average across all providers\n}\n\nexport interface SkillTransferAnalysis {\n  sharedTopic: string;\n  providers: string[];\n  consistencyScore: number; // 0-100, how consistent performance is across providers\n  averageAccuracy: number;\n  recommendations: string[];\n}\n\nexport interface CrossProviderRecommendations {\n  suggestedFocusProvider: string;\n  reasonForSuggestion: string;\n  skillGapAreas: string[];\n  strengthLeverageOpportunities: string[];\n}\n\n// Predictive Analytics for Exam Readiness\nexport interface ExamReadinessAssessment {\n  userId: string;\n  provider: string;\n  exam: string;\n  readinessScore: number; // 0-100\n  confidence: 'low' | 'medium' | 'high';\n  prediction: ReadinessPrediction;\n  factors: ReadinessFactors;\n  timeline: ReadinessTimeline;\n  calculatedAt: string;\n}\n\nexport interface ReadinessPrediction {\n  passLikelihood: number; // 0-100\n  recommendedWaitTime: number; // days before attempting real exam\n  minimumStudyHours: number;\n  targetAccuracy: number;\n}\n\nexport interface ReadinessFactors {\n  currentAccuracy: { value: number; weight: number; impact: 'positive' | 'negative' | 'neutral' };\n  topicCoverage: { value: number; weight: number; impact: 'positive' | 'negative' | 'neutral' };\n  consistencyScore: { value: number; weight: number; impact: 'positive' | 'negative' | 'neutral' };\n  recentPerformance: { value: number; weight: number; impact: 'positive' | 'negative' | 'neutral' };\n  studyVolume: { value: number; weight: number; impact: 'positive' | 'negative' | 'neutral' };\n  timeSpent: { value: number; weight: number; impact: 'positive' | 'negative' | 'neutral' };\n}\n\nexport interface ReadinessTimeline {\n  currentLevel: ReadinessLevel;\n  milestones: ReadinessMilestone[];\n  projectedReadyDate: string;\n}\n\nexport interface ReadinessLevel {\n  level: 'beginner' | 'intermediate' | 'advanced' | 'ready';\n  description: string;\n  requirements: string[];\n}\n\nexport interface ReadinessMilestone {\n  milestone: string;\n  description: string;\n  targetDate: string;\n  completed: boolean;\n  requirements: string[];\n}\n\n// Study Recommendations System\nexport interface StudyRecommendations {\n  userId: string;\n  recommendations: RecommendationItem[];\n  priorityActions: PriorityAction[];\n  studyPlan: StudyPlan;\n  calculatedAt: string;\n}\n\nexport interface RecommendationItem {\n  id: string;\n  type: 'topic_focus' | 'difficulty_adjustment' | 'study_pattern' | 'exam_preparation' | 'skill_development';\n  priority: 'high' | 'medium' | 'low';\n  title: string;\n  description: string;\n  reasoning: string;\n  actionItems: string[];\n  estimatedImpact: number; // 0-100\n  estimatedTimeInvestment: number; // in hours\n  applicableProviders: string[];\n  applicableExams: string[];\n}\n\nexport interface PriorityAction {\n  action: string;\n  description: string;\n  timeframe: string;\n  expectedOutcome: string;\n}\n\nexport interface StudyPlan {\n  planId: string;\n  duration: number; // in days\n  dailyTargets: DailyStudyTarget[];\n  weeklyGoals: WeeklyStudyGoal[];\n  milestones: StudyMilestone[];\n}\n\nexport interface DailyStudyTarget {\n  date: string;\n  targetQuestions: number;\n  targetAccuracy: number;\n  recommendedTopics: string[];\n  estimatedTime: number; // in minutes\n}\n\nexport interface WeeklyStudyGoal {\n  weekStartDate: string;\n  focusAreas: string[];\n  targetSessions: number;\n  targetQuestions: number;\n  targetAccuracy: number;\n}\n\nexport interface StudyMilestone {\n  milestone: string;\n  targetDate: string;\n  criteria: MilestoneCriteria;\n  rewards: string[];\n}\n\nexport interface MilestoneCriteria {\n  minimumSessions: number;\n  minimumAccuracy: number;\n  requiredTopics: string[];\n  requiredQuestions: number;\n}\n\n// Analytics API Request/Response Types\nexport interface GetProgressAnalyticsRequest {\n  timeRange?: 'week' | 'month' | 'quarter' | 'year' | 'all';\n  includeProviders?: string[];\n  includeExams?: string[];\n}\n\nexport interface GetPerformanceMetricsRequest {\n  timeRange: 'week' | 'month' | 'quarter' | 'year' | 'all';\n  includeComparisons?: boolean;\n  includeTrends?: boolean;\n}\n\nexport interface GetSessionAnalyticsRequest {\n  timeRange?: 'week' | 'month' | 'quarter' | 'year' | 'all';\n  provider?: string;\n  exam?: string;\n  status?: 'active' | 'completed' | 'paused';\n  limit?: number;\n  lastEvaluatedKey?: string;\n}\n\nexport interface GetTopicAnalyticsRequest {\n  provider?: string;\n  exam?: string;\n  topics?: string[];\n  timeRange?: 'week' | 'month' | 'quarter' | 'year' | 'all';\n}\n\nexport interface GetReadinessAssessmentRequest {\n  provider: string;\n  exam: string;\n  includeTimeline?: boolean;\n  includeDetailedFactors?: boolean;\n}\n\nexport interface GetRecommendationsRequest {\n  includeStudyPlan?: boolean;\n  planDuration?: number; // in days\n  focusAreas?: string[];\n}\n\nexport interface GetComparisonAnalyticsRequest {\n  providers?: string[];\n  includeSkillTransfer?: boolean;\n  includeRecommendations?: boolean;\n}\n\n// Analytics Storage Types for DynamoDB\nexport interface AnalyticsRecord {\n  PK: string; // Partition Key: userId\n  SK: string; // Sort Key: analyticsType#provider#exam#date\n  userId: string;\n  analyticsType: 'progress' | 'performance' | 'session' | 'topic' | 'readiness' | 'recommendation';\n  provider?: string;\n  exam?: string;\n  data: any;\n  calculatedAt: string;\n  expiresAt: number; // TTL\n}\n\nexport interface AnalyticsAggregation {\n  PK: string; // Partition Key: userId#provider#exam\n  SK: string; // Sort Key: aggregationType#date\n  aggregationType: 'daily' | 'weekly' | 'monthly' | 'quarterly' | 'yearly';\n  date: string;\n  data: {\n    sessions: number;\n    questions: number;\n    correct: number;\n    studyTime: number;\n    averageAccuracy: number;\n  };\n  expiresAt: number; // TTL\n}\n\n// ============================================================================\n// HEALTH & MONITORING TYPES - Phase 6: System Health & Monitoring\n// ============================================================================\n\n// System Health Types\nexport interface SystemHealthCheck {\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  timestamp: string;\n  environment: EnvironmentInfo;\n  dependencies: DependencyHealth;\n  performance: HealthPerformanceMetrics;\n  dataQuality: DataQualityStatus;\n  alerts: HealthAlert[];\n  recommendations: string[];\n}\n\nexport interface EnvironmentInfo {\n  stage: string;\n  version: string;\n  region: string;\n  functionName: string;\n  memorySize: string;\n  logLevel: string;\n  uptime: number; // in seconds\n  coldStart: boolean;\n}\n\nexport interface DependencyHealth {\n  dynamodb: DatabaseHealthStatus;\n  s3: S3HealthStatus;\n  external: ExternalServiceHealthStatus[];\n  overall: 'healthy' | 'degraded' | 'unhealthy';\n}\n\nexport interface DatabaseHealthStatus {\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  tables: TableHealthStatus[];\n  connectivity: {\n    canConnect: boolean;\n    responseTime: number; // in milliseconds\n    lastChecked: string;\n  };\n  performance: {\n    readLatency: number;\n    writeLatency: number;\n    throughputUtilization: number; // percentage\n    errorRate: number; // percentage\n  };\n  capacity: {\n    consumedReadCapacity: number;\n    consumedWriteCapacity: number;\n    provisionedReadCapacity: number;\n    provisionedWriteCapacity: number;\n    utilizationPercentage: number;\n  };\n}\n\nexport interface TableHealthStatus {\n  tableName: string;\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  itemCount?: number;\n  sizeBytes?: number;\n  readCapacityUtilization: number;\n  writeCapacityUtilization: number;\n  gsiStatus?: GSIHealthStatus[];\n  errors: string[];\n}\n\nexport interface GSIHealthStatus {\n  indexName: string;\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  readCapacityUtilization: number;\n  writeCapacityUtilization: number;\n}\n\nexport interface S3HealthStatus {\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  buckets: S3BucketHealthStatus[];\n  connectivity: {\n    canConnect: boolean;\n    responseTime: number;\n    lastChecked: string;\n  };\n  performance: {\n    uploadLatency: number;\n    downloadLatency: number;\n    errorRate: number;\n  };\n}\n\nexport interface S3BucketHealthStatus {\n  bucketName: string;\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  accessible: boolean;\n  objectCount?: number;\n  sizeBytes?: number;\n  errors: string[];\n}\n\nexport interface ExternalServiceHealthStatus {\n  serviceName: string;\n  url: string;\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  responseTime: number;\n  statusCode?: number;\n  lastChecked: string;\n  uptime: number; // percentage over last 24 hours\n  errors: string[];\n}\n\n// Performance Monitoring Types for Health System\nexport interface HealthPerformanceMetrics {\n  memory: MemoryMetrics;\n  execution: ExecutionMetrics;\n  throughput: ThroughputMetrics;\n  errors: ErrorMetrics;\n  trends: HealthPerformanceTrends;\n}\n\nexport interface MemoryMetrics {\n  current: number; // MB\n  peak: number; // MB\n  limit: number; // MB\n  utilizationPercentage: number;\n  gcFrequency: number; // garbage collections per minute\n}\n\nexport interface ExecutionMetrics {\n  coldStartFrequency: number; // percentage of executions\n  averageExecutionTime: number; // milliseconds\n  p95ExecutionTime: number; // milliseconds\n  p99ExecutionTime: number; // milliseconds\n  timeouts: number; // count over last hour\n}\n\nexport interface ThroughputMetrics {\n  requestsPerSecond: number;\n  requestsPerMinute: number;\n  requestsPerHour: number;\n  peakThroughput: number;\n  averageResponseTime: number; // milliseconds\n}\n\nexport interface ErrorMetrics {\n  errorRate: number; // percentage over last hour\n  errorCount: number; // count over last hour\n  errorsByType: { [errorType: string]: number };\n  criticalErrors: number;\n  warnings: number;\n}\n\nexport interface HealthPerformanceTrends {\n  responseTimeTrend: 'improving' | 'stable' | 'degrading';\n  errorRateTrend: 'improving' | 'stable' | 'degrading';\n  throughputTrend: 'increasing' | 'stable' | 'decreasing';\n  memoryUsageTrend: 'improving' | 'stable' | 'degrading';\n}\n\n// Data Quality Types\nexport interface DataQualityStatus {\n  overall: 'excellent' | 'good' | 'fair' | 'poor';\n  checks: DataQualityCheck[];\n  lastAssessment: string;\n  trends: DataQualityTrends;\n}\n\nexport interface DataQualityCheck {\n  checkName: string;\n  table: string;\n  status: 'passed' | 'warning' | 'failed';\n  result: {\n    expected: number | string;\n    actual: number | string;\n    threshold?: number;\n  };\n  lastChecked: string;\n  impact: 'low' | 'medium' | 'high' | 'critical';\n  description: string;\n}\n\nexport interface DataQualityTrends {\n  dataConsistency: 'improving' | 'stable' | 'degrading';\n  dataCompleteness: 'improving' | 'stable' | 'degrading';\n  dataAccuracy: 'improving' | 'stable' | 'degrading';\n  dataDuplication: 'improving' | 'stable' | 'degrading';\n}\n\n// Health Alert Types\nexport interface HealthAlert {\n  alertId: string;\n  severity: 'info' | 'warning' | 'error' | 'critical';\n  category: 'performance' | 'availability' | 'data_quality' | 'security' | 'capacity';\n  title: string;\n  description: string;\n  source: string; // service or component that generated the alert\n  threshold?: {\n    metric: string;\n    value: number;\n    comparison: 'greater_than' | 'less_than' | 'equals';\n  };\n  currentValue: number | string;\n  impact: string;\n  recommendations: string[];\n  createdAt: string;\n  resolvedAt?: string;\n  acknowledged: boolean;\n  acknowledgedBy?: string;\n  tags: string[];\n}\n\nexport interface AlertThreshold {\n  metric: string;\n  warningThreshold: number;\n  errorThreshold: number;\n  criticalThreshold: number;\n  comparison: 'greater_than' | 'less_than';\n  enabled: boolean;\n}\n\n// Health History and Reporting Types\nexport interface HealthHistoryEntry {\n  timestamp: string;\n  overallStatus: 'healthy' | 'degraded' | 'unhealthy';\n  componentStatuses: { [component: string]: 'healthy' | 'degraded' | 'unhealthy' };\n  metrics: {\n    responseTime: number;\n    errorRate: number;\n    throughput: number;\n    memoryUsage: number;\n  };\n  alerts: number; // count of active alerts\n  incidents: number; // count of active incidents\n}\n\nexport interface HealthReport {\n  reportId: string;\n  generatedAt: string;\n  timeRange: {\n    start: string;\n    end: string;\n    duration: string; // e.g., '24h', '7d', '30d'\n  };\n  summary: {\n    overallHealth: 'excellent' | 'good' | 'fair' | 'poor';\n    uptimePercentage: number;\n    totalIncidents: number;\n    resolvedIncidents: number;\n    averageResponseTime: number;\n    errorRate: number;\n  };\n  trends: {\n    availabilityTrend: 'improving' | 'stable' | 'degrading';\n    performanceTrend: 'improving' | 'stable' | 'degrading';\n    errorTrend: 'improving' | 'stable' | 'degrading';\n    dataQualityTrend: 'improving' | 'stable' | 'degrading';\n  };\n  topIssues: HealthAlert[];\n  recommendations: SystemRecommendation[];\n  history: HealthHistoryEntry[];\n}\n\nexport interface SystemRecommendation {\n  id: string;\n  priority: 'high' | 'medium' | 'low';\n  category: 'performance' | 'reliability' | 'cost' | 'security';\n  title: string;\n  description: string;\n  reasoning: string;\n  actionItems: string[];\n  estimatedImpact: {\n    performance: number; // percentage improvement\n    cost: number; // dollar savings or cost\n    reliability: number; // uptime improvement percentage\n  };\n  effort: 'low' | 'medium' | 'high';\n  timeline: string;\n}\n\n// Health Check Configuration Types\nexport interface HealthCheckConfig {\n  enabled: boolean;\n  interval: number; // seconds between checks\n  timeout: number; // seconds before timeout\n  retries: number;\n  dependencies: {\n    dynamodb: {\n      enabled: boolean;\n      tables: string[];\n      performanceChecks: boolean;\n    };\n    s3: {\n      enabled: boolean;\n      buckets: string[];\n      performanceChecks: boolean;\n    };\n    external: {\n      enabled: boolean;\n      services: ExternalServiceConfig[];\n    };\n  };\n  dataQuality: {\n    enabled: boolean;\n    checks: DataQualityCheckConfig[];\n  };\n  alerts: {\n    enabled: boolean;\n    thresholds: AlertThreshold[];\n  };\n}\n\nexport interface ExternalServiceConfig {\n  name: string;\n  url: string;\n  method: 'GET' | 'POST' | 'HEAD';\n  headers?: { [key: string]: string };\n  timeout: number;\n  expectedStatusCode: number;\n}\n\nexport interface DataQualityCheckConfig {\n  name: string;\n  table: string;\n  checkType: 'count' | 'consistency' | 'completeness' | 'accuracy' | 'duplication';\n  query: string; // DynamoDB query or expression\n  expectedValue?: number | string;\n  threshold?: number;\n  critical: boolean;\n}\n\n// Health API Request/Response Types\nexport interface GetHealthRequest {\n  includeDetails?: boolean;\n  includeHistory?: boolean;\n  components?: string[];\n}\n\nexport interface GetHealthResponse {\n  health: SystemHealthCheck;\n  history?: HealthHistoryEntry[];\n  uptime: {\n    current: number; // percentage\n    last24h: number;\n    last7d: number;\n    last30d: number;\n  };\n}\n\nexport interface GetHealthPerformanceMetricsRequest {\n  timeRange?: 'hour' | 'day' | 'week' | 'month';\n  metrics?: string[];\n  includeHistorical?: boolean;\n}\n\nexport interface GetHealthPerformanceMetricsResponse {\n  current: HealthPerformanceMetrics;\n  historical?: { [timestamp: string]: HealthPerformanceMetrics };\n  trends: HealthPerformanceTrends;\n}\n\nexport interface GetAlertsRequest {\n  severity?: 'info' | 'warning' | 'error' | 'critical';\n  category?: 'performance' | 'availability' | 'data_quality' | 'security' | 'capacity';\n  status?: 'active' | 'resolved' | 'acknowledged';\n  limit?: number;\n}\n\nexport interface GetAlertsResponse {\n  alerts: HealthAlert[];\n  summary: {\n    total: number;\n    active: number;\n    resolved: number;\n    acknowledged: number;\n    bySeverity: { [severity: string]: number };\n    byCategory: { [category: string]: number };\n  };\n}\n\nexport interface GetHealthHistoryRequest {\n  timeRange: 'hour' | 'day' | 'week' | 'month';\n  resolution?: 'minute' | 'hour' | 'day';\n  components?: string[];\n}\n\nexport interface GetHealthHistoryResponse {\n  entries: HealthHistoryEntry[];\n  summary: {\n    totalDataPoints: number;\n    averageHealth: number; // 0-100 score\n    incidents: number;\n    majorOutages: number;\n  };\n}\n\nexport interface GenerateHealthReportRequest {\n  timeRange: {\n    start: string;\n    end: string;\n  };\n  includeRecommendations?: boolean;\n  format?: 'json' | 'summary';\n}\n\nexport interface GenerateHealthReportResponse {\n  report: HealthReport;\n  downloadUrl?: string; // if format is not json\n}", "import { APIGatewayProxyResult } from 'aws-lambda';\nimport { ApiResponse, ErrorCode } from '../types';\n\n/**\n * Enhanced Response Builder - V2\n * Provides consistent API responses with proper CORS headers\n */\nexport class ResponseBuilder {\n  private static readonly VERSION = '2.0.0';\n\n  private static readonly CORS_HEADERS = {\n    'Content-Type': 'application/json',\n    'Access-Control-Allow-Origin': '*', // Configure specific origins in production\n    'Access-Control-Allow-Headers': 'Content-Type,Authorization,X-Amz-Date,X-Api-Key,X-Amz-Security-Token,X-Amz-User-Agent,X-Auth-Token',\n    'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS,HEAD',\n    'Access-Control-Allow-Credentials': 'true',\n    'Cache-Control': 'no-cache, no-store, must-revalidate',\n    'Pragma': 'no-cache',\n    'Expires': '0'\n  };\n\n  /**\n   * Create successful response\n   */\n  public static success<T>(\n    data: T, \n    statusCode: number = 200,\n    message?: string\n  ): APIGatewayProxyResult {\n    const response: ApiResponse<T> = {\n      success: true,\n      data,\n      message,\n      timestamp: new Date().toISOString(),\n      version: this.VERSION\n    };\n\n    return {\n      statusCode,\n      headers: this.CORS_HEADERS,\n      body: JSON.stringify(response)\n    };\n  }\n\n  /**\n   * Create error response\n   */\n  public static error(\n    message: string,\n    code: ErrorCode = ErrorCode.INTERNAL_ERROR,\n    details?: any,\n    statusCode: number = 500\n  ): APIGatewayProxyResult {\n    const response: ApiResponse = {\n      success: false,\n      error: message,\n      message: `[${code}] ${message}`,\n      timestamp: new Date().toISOString(),\n      version: this.VERSION,\n      ...(details && { data: details })\n    };\n\n    return {\n      statusCode,\n      headers: this.CORS_HEADERS,\n      body: JSON.stringify(response)\n    };\n  }\n\n  /**\n   * Bad Request (400)\n   */\n  public static badRequest(message: string, details?: any): APIGatewayProxyResult {\n    return this.error(message, ErrorCode.VALIDATION_ERROR, details, 400);\n  }\n\n  /**\n   * Unauthorized (401)\n   */\n  public static unauthorized(message: string = 'Unauthorized'): APIGatewayProxyResult {\n    return this.error(message, ErrorCode.UNAUTHORIZED, undefined, 401);\n  }\n\n  /**\n   * Forbidden (403)\n   */\n  public static forbidden(message: string = 'Forbidden'): APIGatewayProxyResult {\n    return this.error(message, ErrorCode.FORBIDDEN, undefined, 403);\n  }\n\n  /**\n   * Not Found (404)\n   */\n  public static notFound(message: string = 'Resource not found'): APIGatewayProxyResult {\n    return this.error(message, ErrorCode.NOT_FOUND, undefined, 404);\n  }\n\n  /**\n   * Rate Limited (429)\n   */\n  public static rateLimited(message: string = 'Rate limit exceeded'): APIGatewayProxyResult {\n    return this.error(message, ErrorCode.RATE_LIMITED, undefined, 429);\n  }\n\n  /**\n   * Internal Server Error (500)\n   */\n  public static internalError(message: string = 'Internal server error'): APIGatewayProxyResult {\n    return this.error(message, ErrorCode.INTERNAL_ERROR, undefined, 500);\n  }\n\n  /**\n   * CORS preflight response\n   */\n  public static cors(): APIGatewayProxyResult {\n    return {\n      statusCode: 200,\n      headers: {\n        ...this.CORS_HEADERS,\n        'Access-Control-Max-Age': '86400' // Cache preflight for 24 hours\n      },\n      body: ''\n    };\n  }\n\n  /**\n   * Health check response\n   */\n  public static health(data: any): APIGatewayProxyResult {\n    return this.success({\n      status: 'healthy',\n      timestamp: new Date().toISOString(),\n      version: this.VERSION,\n      environment: process.env.STAGE || 'unknown',\n      ...data\n    });\n  }\n\n  /**\n   * Paginated response\n   */\n  public static paginated<T>(\n    items: T[],\n    totalCount: number,\n    page: number,\n    pageSize: number,\n    message?: string\n  ): APIGatewayProxyResult {\n    const totalPages = Math.ceil(totalCount / pageSize);\n    const hasNextPage = page < totalPages;\n    const hasPrevPage = page > 1;\n\n    return this.success({\n      items,\n      pagination: {\n        totalCount,\n        totalPages,\n        currentPage: page,\n        pageSize,\n        hasNextPage,\n        hasPrevPage\n      }\n    }, 200, message);\n  }\n}", "/**\n * Structured Logger - V2\n * Provides consistent logging across all Lambda functions\n */\nexport class Logger {\n  private readonly context: string;\n  private readonly logLevel: string;\n\n  constructor(context: string) {\n    this.context = context;\n    this.logLevel = process.env.LOG_LEVEL || 'INFO';\n  }\n\n  /**\n   * Info level logging\n   */\n  public info(message: string, data?: any): void {\n    if (this.shouldLog('INFO')) {\n      this.log('INFO', message, data);\n    }\n  }\n\n  /**\n   * Debug level logging\n   */\n  public debug(message: string, data?: any): void {\n    if (this.shouldLog('DEBUG')) {\n      this.log('DEBUG', message, data);\n    }\n  }\n\n  /**\n   * Warning level logging\n   */\n  public warn(message: string, data?: any): void {\n    if (this.shouldLog('WARN')) {\n      this.log('WARN', message, data);\n    }\n  }\n\n  /**\n   * Error level logging\n   */\n  public error(message: string, error?: any): void {\n    const errorData = error instanceof Error ? {\n      name: error.name,\n      message: error.message,\n      stack: error.stack\n    } : error;\n\n    this.log('ERROR', message, errorData);\n  }\n\n  /**\n   * Performance logging\n   */\n  public perf(operation: string, duration: number, data?: any): void {\n    this.info(`Performance: ${operation}`, {\n      duration: `${duration}ms`,\n      operation,\n      ...data\n    });\n  }\n\n  /**\n   * Core logging method\n   */\n  private log(level: string, message: string, data?: any): void {\n    const logEntry = {\n      timestamp: new Date().toISOString(),\n      level,\n      context: this.context,\n      message,\n      stage: process.env.STAGE || 'unknown',\n      version: '2.0.0',\n      ...(data && { data })\n    };\n\n    // Use console methods for CloudWatch integration\n    switch (level) {\n      case 'ERROR':\n        console.error(JSON.stringify(logEntry));\n        break;\n      case 'WARN':\n        console.warn(JSON.stringify(logEntry));\n        break;\n      default:\n        console.log(JSON.stringify(logEntry));\n    }\n  }\n\n  /**\n   * Check if message should be logged based on log level\n   */\n  private shouldLog(level: string): boolean {\n    const levels = ['ERROR', 'WARN', 'INFO', 'DEBUG'];\n    const currentLevelIndex = levels.indexOf(this.logLevel);\n    const messageLevelIndex = levels.indexOf(level);\n    \n    return messageLevelIndex <= currentLevelIndex;\n  }\n}", "import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';\nimport { PublicHandler, AuthenticatedHandler, ApiResponse, ErrorCode, ApiError } from '../types';\nimport { ResponseBuilder } from './response-builder';\nimport { Logger } from './logger';\n\n/**\n * Base Handler Class - Eliminates ALL boilerplate code across Lambda functions\n * \n * This addresses the V1 issue where auth code was duplicated across 7+ handlers.\n * Now ALL common functionality is centralized in this base class.\n */\nexport abstract class BaseHandler {\n  protected logger: Logger;\n  protected version: string = '2.0.0';\n\n  constructor(protected handlerName: string) {\n    this.logger = new Logger(handlerName);\n  }\n\n  /**\n   * Main entry point for authenticated handlers\n   * Handles ALL common concerns: auth, CORS, logging, error handling\n   */\n  public withAuth(handler: AuthenticatedHandler): PublicHandler {\n    return async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {\n      const requestId = event.requestContext.requestId;\n      const route = `${event.httpMethod} ${event.resource}`;\n      \n      try {\n        this.logger.info(`[${requestId}] ${route} - Request started`, {\n          httpMethod: event.httpMethod,\n          resource: event.resource,\n          userAgent: event.headers['User-Agent'],\n          sourceIp: event.requestContext.identity.sourceIp\n        });\n\n        // Handle CORS preflight\n        if (event.httpMethod === 'OPTIONS') {\n          return ResponseBuilder.cors();\n        }\n\n        // Extract and validate user context\n        const userId = this.extractUserId(event);\n        \n        if (!userId) {\n          this.logger.warn(`[${requestId}] ${route} - No userId in authorizer context`, {\n            authorizerContext: event.requestContext.authorizer\n          });\n          return ResponseBuilder.unauthorized('User not authenticated');\n        }\n\n        this.logger.info(`[${requestId}] ${route} - Authenticated user: ${userId}`);\n\n        // Validate request if needed\n        const validationError = await this.validateRequest(event);\n        if (validationError) {\n          this.logger.warn(`[${requestId}] ${route} - Validation failed`, validationError);\n          return ResponseBuilder.badRequest(validationError.message, validationError);\n        }\n\n        // Execute the actual handler\n        const startTime = Date.now();\n        const result = await handler(event, userId);\n        const duration = Date.now() - startTime;\n\n        this.logger.info(`[${requestId}] ${route} - Request completed`, {\n          statusCode: result.statusCode,\n          duration: `${duration}ms`\n        });\n\n        return result;\n\n      } catch (error) {\n        this.logger.error(`[${requestId}] ${route} - Request failed`, error);\n        return this.handleError(error);\n      }\n    };\n  }\n\n  /**\n   * Entry point for public handlers (no auth required)\n   * Still handles common concerns: CORS, logging, error handling\n   */\n  public withoutAuth(handler: PublicHandler): PublicHandler {\n    return async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {\n      const requestId = event.requestContext.requestId;\n      const route = `${event.httpMethod} ${event.resource}`;\n      \n      try {\n        this.logger.info(`[${requestId}] ${route} - Public request started`);\n\n        // Handle CORS preflight\n        if (event.httpMethod === 'OPTIONS') {\n          return ResponseBuilder.cors();\n        }\n\n        // Execute the handler\n        const startTime = Date.now();\n        const result = await handler(event);\n        const duration = Date.now() - startTime;\n\n        this.logger.info(`[${requestId}] ${route} - Public request completed`, {\n          statusCode: result.statusCode,\n          duration: `${duration}ms`\n        });\n\n        return result;\n\n      } catch (error) {\n        this.logger.error(`[${requestId}] ${route} - Public request failed`, error);\n        return this.handleError(error);\n      }\n    };\n  }\n\n  /**\n   * Extract userId from API Gateway authorizer context\n   * Handles both TOKEN and REQUEST authorizer formats\n   */\n  private extractUserId(event: APIGatewayProxyEvent): string | null {\n    const authorizer = event.requestContext.authorizer;\n    \n    if (!authorizer) {\n      return null;\n    }\n\n    // Try different possible locations for userId\n    return (\n      authorizer.userId ||\n      authorizer.principalId ||\n      authorizer.claims?.userId ||\n      authorizer.claims?.sub ||\n      null\n    );\n  }\n\n  /**\n   * Validate request - override in specific handlers\n   */\n  protected async validateRequest(event: APIGatewayProxyEvent): Promise<ApiError | null> {\n    return null; // No validation by default\n  }\n\n  /**\n   * Centralized error handling\n   */\n  private handleError(error: any): APIGatewayProxyResult {\n    if (error instanceof ApiError) {\n      return ResponseBuilder.error(error.message, error.code, error.details);\n    }\n\n    if (error.name === 'ValidationError') {\n      return ResponseBuilder.badRequest(error.message);\n    }\n\n    if (error.name === 'UnauthorizedError') {\n      return ResponseBuilder.unauthorized(error.message);\n    }\n\n    if (error.name === 'ForbiddenError') {\n      return ResponseBuilder.forbidden(error.message);\n    }\n\n    if (error.name === 'NotFoundError') {\n      return ResponseBuilder.notFound(error.message);\n    }\n\n    // Default to internal server error\n    return ResponseBuilder.internalError('An unexpected error occurred');\n  }\n\n  /**\n   * Helper: Parse JSON body safely\n   */\n  protected parseJsonBody<T>(event: APIGatewayProxyEvent): T | null {\n    if (!event.body) {\n      return null;\n    }\n\n    try {\n      return JSON.parse(event.body) as T;\n    } catch (error) {\n      throw new ApiError(ErrorCode.VALIDATION_ERROR, 'Invalid JSON in request body');\n    }\n  }\n\n  /**\n   * Helper: Get query parameter with default\n   */\n  protected getQueryParam(event: APIGatewayProxyEvent, key: string, defaultValue?: string): string | undefined {\n    return event.queryStringParameters?.[key] || defaultValue;\n  }\n\n  /**\n   * Helper: Get path parameter\n   */\n  protected getPathParam(event: APIGatewayProxyEvent, key: string): string | undefined {\n    return event.pathParameters?.[key];\n  }\n\n  /**\n   * Helper: Get header value\n   */\n  protected getHeader(event: APIGatewayProxyEvent, key: string): string | undefined {\n    return event.headers[key] || event.headers[key.toLowerCase()];\n  }\n\n  /**\n   * Helper: Create success response with data\n   */\n  protected success<T>(data: T, message?: string): APIGatewayProxyResult {\n    return ResponseBuilder.success(data, 200, message);\n  }\n\n  /**\n   * Helper: Create created response\n   */\n  protected created<T>(data: T, message?: string): APIGatewayProxyResult {\n    return ResponseBuilder.success(data, 201, message);\n  }\n\n  /**\n   * Helper: Create no content response\n   */\n  protected noContent(): APIGatewayProxyResult {\n    return ResponseBuilder.success(null, 204);\n  }\n\n  /**\n   * Helper: Create bad request response\n   */\n  protected badRequest(message: string, details?: any): APIGatewayProxyResult {\n    return ResponseBuilder.badRequest(message, details);\n  }\n\n  /**\n   * Helper: Create not found response\n   */\n  protected notFound(message: string): APIGatewayProxyResult {\n    return ResponseBuilder.notFound(message);\n  }\n\n  /**\n   * Helper: Create internal error response\n   */\n  protected internalError(message: string): APIGatewayProxyResult {\n    return ResponseBuilder.internalError(message);\n  }\n}", "import { DynamoDBClient, DescribeTableCommand } from '@aws-sdk/client-dynamodb';\nimport { DynamoDBDocumentClient, ScanCommand } from '@aws-sdk/lib-dynamodb';\nimport { S3Client, HeadBucketCommand, ListObjectsV2Command } from '@aws-sdk/client-s3';\nimport { Logger } from '../shared/logger';\nimport { \n  SystemHealthCheck, \n  DependencyHealth, \n  DatabaseHealthStatus,\n  TableHealthStatus,\n  S3HealthStatus,\n  S3BucketHealthStatus,\n  ExternalServiceHealthStatus,\n  EnvironmentInfo,\n  HealthAlert,\n  DataQualityStatus,\n  DataQualityCheck,\n  HealthPerformanceMetrics,\n  MemoryMetrics,\n  ExecutionMetrics,\n  ThroughputMetrics,\n  ErrorMetrics,\n  HealthPerformanceTrends,\n  HealthCheckConfig,\n  AlertThreshold\n} from '../types';\nimport { v4 as uuidv4 } from 'uuid';\n\n/**\n * Health Service - Comprehensive system health monitoring and checks\n * Provides detailed monitoring of all system dependencies and performance metrics\n */\nexport class HealthService {\n  private client: DynamoDBDocumentClient;\n  private s3Client: S3Client;\n  private logger: Logger;\n  private config: HealthCheckConfig;\n  private performanceHistory: Map<string, number[]> = new Map();\n  private lastHealthCheck: SystemHealthCheck | null = null;\n\n  constructor(config?: Partial<HealthCheckConfig>) {\n    this.logger = new Logger('HealthService');\n    \n    // Initialize AWS clients\n    const dynamoClient = new DynamoDBClient({\n      region: process.env.AWS_REGION || 'us-east-1'\n    });\n    this.client = DynamoDBDocumentClient.from(dynamoClient);\n    \n    this.s3Client = new S3Client({\n      region: process.env.AWS_REGION || 'us-east-1'\n    });\n\n    // Default configuration\n    this.config = {\n      enabled: true,\n      interval: 300, // 5 minutes\n      timeout: 30,\n      retries: 3,\n      dependencies: {\n        dynamodb: {\n          enabled: true,\n          tables: [\n            process.env.USERS_TABLE || 'StudyApp-Users',\n            process.env.SESSIONS_TABLE || 'StudyApp-Sessions',\n            process.env.GOALS_TABLE || 'StudyApp-Goals',\n            process.env.ANALYTICS_TABLE || 'StudyApp-Analytics'\n          ],\n          performanceChecks: true\n        },\n        s3: {\n          enabled: true,\n          buckets: [\n            process.env.DATA_BUCKET || 'study-app-data',\n            process.env.S3_STUDY_DATA_BUCKET || 'study-app-data'\n          ],\n          performanceChecks: true\n        },\n        external: {\n          enabled: false,\n          services: []\n        }\n      },\n      dataQuality: {\n        enabled: true,\n        checks: [\n          {\n            name: 'User Count Check',\n            table: process.env.USERS_TABLE || 'StudyApp-Users',\n            checkType: 'count',\n            query: 'scan',\n            threshold: 0,\n            critical: false\n          },\n          {\n            name: 'Active Sessions Check',\n            table: process.env.SESSIONS_TABLE || 'StudyApp-Sessions',\n            checkType: 'count',\n            query: 'scan',\n            threshold: 0,\n            critical: false\n          }\n        ]\n      },\n      alerts: {\n        enabled: true,\n        thresholds: [\n          {\n            metric: 'response_time',\n            warningThreshold: 1000,\n            errorThreshold: 2000,\n            criticalThreshold: 5000,\n            comparison: 'greater_than',\n            enabled: true\n          },\n          {\n            metric: 'error_rate',\n            warningThreshold: 1,\n            errorThreshold: 5,\n            criticalThreshold: 10,\n            comparison: 'greater_than',\n            enabled: true\n          },\n          {\n            metric: 'memory_usage',\n            warningThreshold: 70,\n            errorThreshold: 85,\n            criticalThreshold: 95,\n            comparison: 'greater_than',\n            enabled: true\n          }\n        ]\n      },\n      ...config\n    };\n\n    this.logger.info('HealthService initialized', {\n      config: this.config\n    });\n  }\n\n  /**\n   * Perform comprehensive health check of all system components\n   */\n  async performHealthCheck(): Promise<SystemHealthCheck> {\n    const startTime = Date.now();\n    const timestamp = new Date().toISOString();\n    \n    this.logger.info('Starting comprehensive health check');\n\n    try {\n      // Perform all health checks in parallel for better performance\n      const [\n        environment,\n        dependencyHealth,\n        performanceMetrics,\n        dataQuality\n      ] = await Promise.all([\n        this.getEnvironmentInfo(),\n        this.checkDependencyHealth(),\n        this.collectPerformanceMetrics(),\n        this.performDataQualityChecks()\n      ]);\n\n      // Generate alerts based on current status\n      const alerts = await this.generateAlerts(dependencyHealth, performanceMetrics, dataQuality);\n\n      // Generate recommendations based on current state\n      const recommendations = this.generateRecommendations(dependencyHealth, performanceMetrics, dataQuality, alerts);\n\n      // Determine overall system status\n      const overallStatus = this.determineOverallStatus(dependencyHealth, performanceMetrics, dataQuality, alerts);\n\n      const healthCheck: SystemHealthCheck = {\n        status: overallStatus,\n        timestamp,\n        environment,\n        dependencies: dependencyHealth,\n        performance: performanceMetrics,\n        dataQuality,\n        alerts,\n        recommendations\n      };\n\n      // Cache the result\n      this.lastHealthCheck = healthCheck;\n\n      const duration = Date.now() - startTime;\n      this.logger.info('Health check completed', {\n        status: overallStatus,\n        duration,\n        alertsCount: alerts.length,\n        recommendationsCount: recommendations.length\n      });\n\n      return healthCheck;\n\n    } catch (error) {\n      this.logger.error('Health check failed', { error });\n      \n      // Return degraded status with minimal info\n      return {\n        status: 'unhealthy',\n        timestamp,\n        environment: await this.getEnvironmentInfo(),\n        dependencies: {\n          dynamodb: { status: 'unhealthy', tables: [], connectivity: { canConnect: false, responseTime: 0, lastChecked: timestamp }, performance: { readLatency: 0, writeLatency: 0, throughputUtilization: 0, errorRate: 100 }, capacity: { consumedReadCapacity: 0, consumedWriteCapacity: 0, provisionedReadCapacity: 0, provisionedWriteCapacity: 0, utilizationPercentage: 0 } },\n          s3: { status: 'unhealthy', buckets: [], connectivity: { canConnect: false, responseTime: 0, lastChecked: timestamp }, performance: { uploadLatency: 0, downloadLatency: 0, errorRate: 100 } },\n          external: [],\n          overall: 'unhealthy'\n        },\n        performance: this.getDefaultPerformanceMetrics(),\n        dataQuality: { overall: 'poor', checks: [], lastAssessment: timestamp, trends: { dataConsistency: 'degrading', dataCompleteness: 'degrading', dataAccuracy: 'degrading', dataDuplication: 'degrading' } },\n        alerts: [{\n          alertId: uuidv4(),\n          severity: 'critical',\n          category: 'availability',\n          title: 'Health Check System Failure',\n          description: 'The health check system itself has failed',\n          source: 'HealthService',\n          currentValue: 'failed',\n          impact: 'Cannot assess system health',\n          recommendations: ['Check HealthService logs', 'Verify AWS service permissions'],\n          createdAt: timestamp,\n          acknowledged: false,\n          tags: ['system', 'critical']\n        }],\n        recommendations: ['Investigate HealthService failure', 'Check AWS credentials and permissions', 'Review system logs']\n      };\n    }\n  }\n\n  /**\n   * Get environment information\n   */\n  private async getEnvironmentInfo(): Promise<EnvironmentInfo> {\n    const startTime = process.hrtime.bigint();\n    \n    return {\n      stage: process.env.STAGE || 'unknown',\n      version: '2.0.0',\n      region: process.env.AWS_REGION || 'unknown',\n      functionName: process.env.AWS_LAMBDA_FUNCTION_NAME || 'unknown',\n      memorySize: process.env.AWS_LAMBDA_FUNCTION_MEMORY_SIZE || 'unknown',\n      logLevel: process.env.LOG_LEVEL || 'INFO',\n      uptime: Number(process.hrtime.bigint() - startTime) / 1000000, // Convert to milliseconds\n      coldStart: process.env.AWS_LAMBDA_INITIALIZATION_TYPE === 'on-demand'\n    };\n  }\n\n  /**\n   * Check health of all system dependencies\n   */\n  private async checkDependencyHealth(): Promise<DependencyHealth> {\n    const [dynamodbHealth, s3Health, externalHealth] = await Promise.all([\n      this.checkDynamoDBHealth(),\n      this.checkS3Health(),\n      this.checkExternalServiceHealth()\n    ]);\n\n    // Determine overall dependency health\n    const statuses = [dynamodbHealth.status, s3Health.status];\n    externalHealth.forEach(ext => statuses.push(ext.status));\n\n    let overall: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';\n    if (statuses.includes('unhealthy')) {\n      overall = 'unhealthy';\n    } else if (statuses.includes('degraded')) {\n      overall = 'degraded';\n    }\n\n    return {\n      dynamodb: dynamodbHealth,\n      s3: s3Health,\n      external: externalHealth,\n      overall\n    };\n  }\n\n  /**\n   * Check DynamoDB health and performance\n   */\n  private async checkDynamoDBHealth(): Promise<DatabaseHealthStatus> {\n    if (!this.config.dependencies.dynamodb.enabled) {\n      return {\n        status: 'healthy',\n        tables: [],\n        connectivity: { canConnect: true, responseTime: 0, lastChecked: new Date().toISOString() },\n        performance: { readLatency: 0, writeLatency: 0, throughputUtilization: 0, errorRate: 0 },\n        capacity: { consumedReadCapacity: 0, consumedWriteCapacity: 0, provisionedReadCapacity: 0, provisionedWriteCapacity: 0, utilizationPercentage: 0 }\n      };\n    }\n\n    const startTime = Date.now();\n    const tables: TableHealthStatus[] = [];\n    let overallStatus: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';\n    \n    try {\n      // Test basic connectivity with a simple operation\n      const connectivityTest = await this.client.send(new ScanCommand({\n        TableName: this.config.dependencies.dynamodb.tables[0],\n        Limit: 1,\n        Select: 'COUNT'\n      }));\n      \n      const connectivity = {\n        canConnect: true,\n        responseTime: Date.now() - startTime,\n        lastChecked: new Date().toISOString()\n      };\n\n      // Check each table individually\n      for (const tableName of this.config.dependencies.dynamodb.tables) {\n        try {\n          const tableHealth = await this.checkTableHealth(tableName);\n          tables.push(tableHealth);\n          \n          if (tableHealth.status === 'unhealthy') {\n            overallStatus = 'unhealthy';\n          } else if (tableHealth.status === 'degraded' && overallStatus === 'healthy') {\n            overallStatus = 'degraded';\n          }\n        } catch (error) {\n          this.logger.warn('Failed to check table health', { tableName, error });\n          tables.push({\n            tableName,\n            status: 'unhealthy',\n            readCapacityUtilization: 0,\n            writeCapacityUtilization: 0,\n            errors: [`Health check failed: ${error instanceof Error ? error.message : 'Unknown error'}`]\n          });\n          overallStatus = 'unhealthy';\n        }\n      }\n\n      // Calculate performance metrics (simplified)\n      const totalResponseTime = connectivity.responseTime;\n      const performance = {\n        readLatency: totalResponseTime * 0.6, // Estimate\n        writeLatency: totalResponseTime * 0.8, // Estimate\n        throughputUtilization: this.calculateAverageThroughputUtilization(tables),\n        errorRate: this.calculateErrorRate(tables)\n      };\n\n      // Calculate capacity metrics\n      const capacity = {\n        consumedReadCapacity: 0, // Would need CloudWatch metrics\n        consumedWriteCapacity: 0, // Would need CloudWatch metrics\n        provisionedReadCapacity: 0, // Would need table descriptions\n        provisionedWriteCapacity: 0, // Would need table descriptions\n        utilizationPercentage: 0 // Would calculate from above\n      };\n\n      return {\n        status: overallStatus,\n        tables,\n        connectivity,\n        performance,\n        capacity\n      };\n\n    } catch (error) {\n      this.logger.error('DynamoDB health check failed', { error });\n      \n      return {\n        status: 'unhealthy',\n        tables: [],\n        connectivity: {\n          canConnect: false,\n          responseTime: Date.now() - startTime,\n          lastChecked: new Date().toISOString()\n        },\n        performance: {\n          readLatency: 0,\n          writeLatency: 0,\n          throughputUtilization: 0,\n          errorRate: 100\n        },\n        capacity: {\n          consumedReadCapacity: 0,\n          consumedWriteCapacity: 0,\n          provisionedReadCapacity: 0,\n          provisionedWriteCapacity: 0,\n          utilizationPercentage: 0\n        }\n      };\n    }\n  }\n\n  /**\n   * Check individual table health\n   */\n  private async checkTableHealth(tableName: string): Promise<TableHealthStatus> {\n    try {\n      const startTime = Date.now();\n      \n      // Get basic table info with a count scan\n      const scanResult = await this.client.send(new ScanCommand({\n        TableName: tableName,\n        Select: 'COUNT',\n        Limit: 1000\n      }));\n\n      const responseTime = Date.now() - startTime;\n      \n      // Determine status based on response time\n      let status: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';\n      if (responseTime > 2000) {\n        status = 'unhealthy';\n      } else if (responseTime > 1000) {\n        status = 'degraded';\n      }\n\n      return {\n        tableName,\n        status,\n        itemCount: scanResult.Count || 0,\n        readCapacityUtilization: this.estimateCapacityUtilization(responseTime, 'read'),\n        writeCapacityUtilization: 0, // Would need write operations to measure\n        errors: []\n      };\n\n    } catch (error) {\n      this.logger.warn('Table health check failed', { tableName, error });\n      \n      return {\n        tableName,\n        status: 'unhealthy',\n        readCapacityUtilization: 0,\n        writeCapacityUtilization: 0,\n        errors: [`Health check failed: ${error instanceof Error ? error.message : 'Unknown error'}`]\n      };\n    }\n  }\n\n  /**\n   * Check S3 health and performance\n   */\n  private async checkS3Health(): Promise<S3HealthStatus> {\n    if (!this.config.dependencies.s3.enabled) {\n      return {\n        status: 'healthy',\n        buckets: [],\n        connectivity: { canConnect: true, responseTime: 0, lastChecked: new Date().toISOString() },\n        performance: { uploadLatency: 0, downloadLatency: 0, errorRate: 0 }\n      };\n    }\n\n    const startTime = Date.now();\n    const buckets: S3BucketHealthStatus[] = [];\n    let overallStatus: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';\n\n    try {\n      // Check each bucket\n      for (const bucketName of this.config.dependencies.s3.buckets) {\n        try {\n          const bucketStartTime = Date.now();\n          \n          // Test bucket accessibility\n          await this.s3Client.send(new HeadBucketCommand({ Bucket: bucketName }));\n          \n          // Get basic bucket info\n          const listResult = await this.s3Client.send(new ListObjectsV2Command({\n            Bucket: bucketName,\n            MaxKeys: 10\n          }));\n\n          const responseTime = Date.now() - bucketStartTime;\n          \n          let status: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';\n          if (responseTime > 2000) {\n            status = 'unhealthy';\n            overallStatus = 'unhealthy';\n          } else if (responseTime > 1000) {\n            status = 'degraded';\n            if (overallStatus === 'healthy') overallStatus = 'degraded';\n          }\n\n          buckets.push({\n            bucketName,\n            status,\n            accessible: true,\n            objectCount: listResult.KeyCount || 0,\n            errors: []\n          });\n\n        } catch (error) {\n          this.logger.warn('S3 bucket health check failed', { bucketName, error });\n          \n          buckets.push({\n            bucketName,\n            status: 'unhealthy',\n            accessible: false,\n            errors: [`Health check failed: ${error instanceof Error ? error.message : 'Unknown error'}`]\n          });\n          overallStatus = 'unhealthy';\n        }\n      }\n\n      const connectivity = {\n        canConnect: true,\n        responseTime: Date.now() - startTime,\n        lastChecked: new Date().toISOString()\n      };\n\n      const performance = {\n        uploadLatency: 0, // Would need actual upload tests\n        downloadLatency: Date.now() - startTime,\n        errorRate: buckets.filter(b => !b.accessible).length / buckets.length * 100\n      };\n\n      return {\n        status: overallStatus,\n        buckets,\n        connectivity,\n        performance\n      };\n\n    } catch (error) {\n      this.logger.error('S3 health check failed', { error });\n      \n      return {\n        status: 'unhealthy',\n        buckets: [],\n        connectivity: {\n          canConnect: false,\n          responseTime: Date.now() - startTime,\n          lastChecked: new Date().toISOString()\n        },\n        performance: {\n          uploadLatency: 0,\n          downloadLatency: 0,\n          errorRate: 100\n        }\n      };\n    }\n  }\n\n  /**\n   * Check external service health\n   */\n  private async checkExternalServiceHealth(): Promise<ExternalServiceHealthStatus[]> {\n    if (!this.config.dependencies.external.enabled || this.config.dependencies.external.services.length === 0) {\n      return [];\n    }\n\n    const results: ExternalServiceHealthStatus[] = [];\n\n    for (const service of this.config.dependencies.external.services) {\n      try {\n        const startTime = Date.now();\n        \n        const response = await fetch(service.url, {\n          method: service.method,\n          headers: service.headers,\n          signal: AbortSignal.timeout(service.timeout * 1000)\n        });\n\n        const responseTime = Date.now() - startTime;\n        \n        let status: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';\n        if (response.status !== service.expectedStatusCode) {\n          status = 'unhealthy';\n        } else if (responseTime > 2000) {\n          status = 'degraded';\n        }\n\n        results.push({\n          serviceName: service.name,\n          url: service.url,\n          status,\n          responseTime,\n          statusCode: response.status,\n          lastChecked: new Date().toISOString(),\n          uptime: status === 'healthy' ? 100 : 0, // Simplified\n          errors: status === 'unhealthy' ? [`Unexpected status code: ${response.status}`] : []\n        });\n\n      } catch (error) {\n        results.push({\n          serviceName: service.name,\n          url: service.url,\n          status: 'unhealthy',\n          responseTime: 0,\n          lastChecked: new Date().toISOString(),\n          uptime: 0,\n          errors: [`Health check failed: ${error instanceof Error ? error.message : 'Unknown error'}`]\n        });\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Collect performance metrics\n   */\n  private async collectPerformanceMetrics(): Promise<HealthPerformanceMetrics> {\n    const memoryUsage = process.memoryUsage();\n    const memoryLimit = parseInt(process.env.AWS_LAMBDA_FUNCTION_MEMORY_SIZE || '512');\n    \n    const memory: MemoryMetrics = {\n      current: Math.round(memoryUsage.rss / 1024 / 1024),\n      peak: Math.round(memoryUsage.heapUsed / 1024 / 1024),\n      limit: memoryLimit,\n      utilizationPercentage: Math.round((memoryUsage.rss / 1024 / 1024) / memoryLimit * 100),\n      gcFrequency: 0 // Would need to track GC events\n    };\n\n    const execution: ExecutionMetrics = {\n      coldStartFrequency: process.env.AWS_LAMBDA_INITIALIZATION_TYPE === 'on-demand' ? 100 : 0,\n      averageExecutionTime: this.getAverageResponseTime(),\n      p95ExecutionTime: this.getPercentileResponseTime(95),\n      p99ExecutionTime: this.getPercentileResponseTime(99),\n      timeouts: 0 // Would need to track from logs\n    };\n\n    const throughput: ThroughputMetrics = {\n      requestsPerSecond: this.getCurrentRPS(),\n      requestsPerMinute: this.getCurrentRPM(),\n      requestsPerHour: this.getCurrentRPH(),\n      peakThroughput: this.getPeakThroughput(),\n      averageResponseTime: this.getAverageResponseTime()\n    };\n\n    const errors: ErrorMetrics = {\n      errorRate: this.getCurrentErrorRate(),\n      errorCount: this.getCurrentErrorCount(),\n      errorsByType: this.getErrorsByType(),\n      criticalErrors: 0,\n      warnings: 0\n    };\n\n    const trends: HealthPerformanceTrends = {\n      responseTimeTrend: this.analyzeResponseTimeTrend(),\n      errorRateTrend: this.analyzeErrorRateTrend(),\n      throughputTrend: this.analyzeThroughputTrend(),\n      memoryUsageTrend: this.analyzeMemoryUsageTrend()\n    };\n\n    return {\n      memory,\n      execution,\n      throughput,\n      errors,\n      trends\n    };\n  }\n\n  /**\n   * Perform data quality checks\n   */\n  private async performDataQualityChecks(): Promise<DataQualityStatus> {\n    if (!this.config.dataQuality.enabled) {\n      return {\n        overall: 'good',\n        checks: [],\n        lastAssessment: new Date().toISOString(),\n        trends: {\n          dataConsistency: 'stable',\n          dataCompleteness: 'stable',\n          dataAccuracy: 'stable',\n          dataDuplication: 'stable'\n        }\n      };\n    }\n\n    const checks: DataQualityCheck[] = [];\n    let passedChecks = 0;\n\n    for (const checkConfig of this.config.dataQuality.checks) {\n      try {\n        const check = await this.performDataQualityCheck(checkConfig);\n        checks.push(check);\n        if (check.status === 'passed') passedChecks++;\n      } catch (error) {\n        this.logger.warn('Data quality check failed', { checkName: checkConfig.name, error });\n        checks.push({\n          checkName: checkConfig.name,\n          table: checkConfig.table,\n          status: 'failed',\n          result: {\n            expected: checkConfig.expectedValue || 'unknown',\n            actual: 'error'\n          },\n          lastChecked: new Date().toISOString(),\n          impact: checkConfig.critical ? 'critical' : 'medium',\n          description: `Check failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n        });\n      }\n    }\n\n    const passRate = checks.length > 0 ? passedChecks / checks.length : 1;\n    let overall: 'excellent' | 'good' | 'fair' | 'poor' = 'excellent';\n    if (passRate < 0.5) overall = 'poor';\n    else if (passRate < 0.7) overall = 'fair';\n    else if (passRate < 0.9) overall = 'good';\n\n    return {\n      overall,\n      checks,\n      lastAssessment: new Date().toISOString(),\n      trends: {\n        dataConsistency: 'stable',\n        dataCompleteness: 'stable',\n        dataAccuracy: 'stable',\n        dataDuplication: 'stable'\n      }\n    };\n  }\n\n  /**\n   * Perform individual data quality check\n   */\n  private async performDataQualityCheck(config: any): Promise<DataQualityCheck> {\n    const startTime = Date.now();\n    \n    // Perform basic count check for now\n    const result = await this.client.send(new ScanCommand({\n      TableName: config.table,\n      Select: 'COUNT'\n    }));\n\n    const actualCount = result.Count || 0;\n    const expectedCount = config.threshold || 0;\n    \n    let status: 'passed' | 'warning' | 'failed' = 'passed';\n    if (actualCount < expectedCount) {\n      status = config.critical ? 'failed' : 'warning';\n    }\n\n    return {\n      checkName: config.name,\n      table: config.table,\n      status,\n      result: {\n        expected: expectedCount,\n        actual: actualCount,\n        threshold: config.threshold\n      },\n      lastChecked: new Date().toISOString(),\n      impact: config.critical ? 'critical' : 'medium',\n      description: `Table ${config.table} has ${actualCount} records${expectedCount > 0 ? ` (expected >= ${expectedCount})` : ''}`\n    };\n  }\n\n  /**\n   * Generate alerts based on current system state\n   */\n  private async generateAlerts(\n    dependencies: DependencyHealth,\n    performance: HealthPerformanceMetrics,\n    dataQuality: DataQualityStatus\n  ): Promise<HealthAlert[]> {\n    const alerts: HealthAlert[] = [];\n\n    // Check performance thresholds\n    for (const threshold of this.config.alerts.thresholds) {\n      if (!threshold.enabled) continue;\n\n      let currentValue: number = 0;\n      let metricName = '';\n\n      switch (threshold.metric) {\n        case 'response_time':\n          currentValue = performance.throughput.averageResponseTime;\n          metricName = 'Average Response Time';\n          break;\n        case 'error_rate':\n          currentValue = performance.errors.errorRate;\n          metricName = 'Error Rate';\n          break;\n        case 'memory_usage':\n          currentValue = performance.memory.utilizationPercentage;\n          metricName = 'Memory Usage';\n          break;\n      }\n\n      const severity = this.determineSeverity(currentValue, threshold);\n      if (severity !== 'info') {\n        alerts.push({\n          alertId: uuidv4(),\n          severity,\n          category: 'performance',\n          title: `${metricName} Threshold Exceeded`,\n          description: `${metricName} is ${currentValue}${threshold.metric === 'memory_usage' || threshold.metric === 'error_rate' ? '%' : 'ms'}, which exceeds the ${severity} threshold`,\n          source: 'HealthService',\n          threshold: {\n            metric: threshold.metric,\n            value: this.getThresholdValue(threshold, severity),\n            comparison: threshold.comparison\n          },\n          currentValue,\n          impact: this.getAlertImpact(threshold.metric, severity),\n          recommendations: this.getAlertRecommendations(threshold.metric, severity),\n          createdAt: new Date().toISOString(),\n          acknowledged: false,\n          tags: ['performance', threshold.metric]\n        });\n      }\n    }\n\n    // Check dependency health\n    if (dependencies.overall !== 'healthy') {\n      alerts.push({\n        alertId: uuidv4(),\n        severity: dependencies.overall === 'degraded' ? 'warning' : 'error',\n        category: 'availability',\n        title: 'Dependency Health Issues',\n        description: `One or more system dependencies are ${dependencies.overall}`,\n        source: 'HealthService',\n        currentValue: dependencies.overall,\n        impact: 'System functionality may be impacted',\n        recommendations: ['Check individual dependency status', 'Review connection configurations'],\n        createdAt: new Date().toISOString(),\n        acknowledged: false,\n        tags: ['dependencies', 'availability']\n      });\n    }\n\n    // Check data quality\n    if (dataQuality.overall === 'poor' || dataQuality.overall === 'fair') {\n      alerts.push({\n        alertId: uuidv4(),\n        severity: dataQuality.overall === 'poor' ? 'error' : 'warning',\n        category: 'data_quality',\n        title: 'Data Quality Issues Detected',\n        description: `Overall data quality is ${dataQuality.overall}`,\n        source: 'HealthService',\n        currentValue: dataQuality.overall,\n        impact: 'Data integrity and application functionality may be compromised',\n        recommendations: ['Review failed data quality checks', 'Investigate data consistency issues'],\n        createdAt: new Date().toISOString(),\n        acknowledged: false,\n        tags: ['data_quality']\n      });\n    }\n\n    return alerts;\n  }\n\n  /**\n   * Generate system recommendations\n   */\n  private generateRecommendations(\n    dependencies: DependencyHealth,\n    performance: HealthPerformanceMetrics,\n    dataQuality: DataQualityStatus,\n    alerts: HealthAlert[]\n  ): string[] {\n    const recommendations: string[] = [];\n\n    // Performance recommendations\n    if (performance.memory.utilizationPercentage > 80) {\n      recommendations.push('Consider increasing Lambda memory allocation to improve performance');\n    }\n\n    if (performance.throughput.averageResponseTime > 1000) {\n      recommendations.push('Optimize database queries and implement caching strategies');\n    }\n\n    if (performance.errors.errorRate > 1) {\n      recommendations.push('Investigate and resolve recurring errors to improve reliability');\n    }\n\n    // Dependency recommendations\n    if (dependencies.dynamodb.status !== 'healthy') {\n      recommendations.push('Review DynamoDB table configurations and capacity settings');\n    }\n\n    if (dependencies.s3.status !== 'healthy') {\n      recommendations.push('Check S3 bucket permissions and connectivity');\n    }\n\n    // Data quality recommendations\n    if (dataQuality.overall !== 'excellent') {\n      recommendations.push('Implement automated data validation and cleanup processes');\n    }\n\n    // Alert-based recommendations\n    if (alerts.length > 5) {\n      recommendations.push('Review system health monitoring thresholds and alert configurations');\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * Determine overall system status\n   */\n  private determineOverallStatus(\n    dependencies: DependencyHealth,\n    performance: HealthPerformanceMetrics,\n    dataQuality: DataQualityStatus,\n    alerts: HealthAlert[]\n  ): 'healthy' | 'degraded' | 'unhealthy' {\n    // Critical failures\n    if (dependencies.overall === 'unhealthy') return 'unhealthy';\n    if (alerts.some(a => a.severity === 'critical')) return 'unhealthy';\n    if (performance.errors.errorRate > 10) return 'unhealthy';\n\n    // Degraded conditions\n    if (dependencies.overall === 'degraded') return 'degraded';\n    if (alerts.some(a => a.severity === 'error')) return 'degraded';\n    if (performance.memory.utilizationPercentage > 90) return 'degraded';\n    if (performance.throughput.averageResponseTime > 2000) return 'degraded';\n    if (dataQuality.overall === 'poor') return 'degraded';\n\n    return 'healthy';\n  }\n\n  // Helper methods for metrics calculation\n  private calculateAverageThroughputUtilization(tables: TableHealthStatus[]): number {\n    if (tables.length === 0) return 0;\n    const total = tables.reduce((sum, table) => sum + table.readCapacityUtilization + table.writeCapacityUtilization, 0);\n    return total / (tables.length * 2);\n  }\n\n  private calculateErrorRate(tables: TableHealthStatus[]): number {\n    const totalTables = tables.length;\n    const errorTables = tables.filter(table => table.errors.length > 0).length;\n    return totalTables > 0 ? (errorTables / totalTables) * 100 : 0;\n  }\n\n  private estimateCapacityUtilization(responseTime: number, operationType: 'read' | 'write'): number {\n    // Simple estimation based on response time\n    if (responseTime > 2000) return 90;\n    if (responseTime > 1000) return 70;\n    if (responseTime > 500) return 50;\n    return 30;\n  }\n\n  private getDefaultPerformanceMetrics(): HealthPerformanceMetrics {\n    return {\n      memory: { current: 0, peak: 0, limit: 512, utilizationPercentage: 0, gcFrequency: 0 },\n      execution: { coldStartFrequency: 0, averageExecutionTime: 0, p95ExecutionTime: 0, p99ExecutionTime: 0, timeouts: 0 },\n      throughput: { requestsPerSecond: 0, requestsPerMinute: 0, requestsPerHour: 0, peakThroughput: 0, averageResponseTime: 0 },\n      errors: { errorRate: 0, errorCount: 0, errorsByType: {}, criticalErrors: 0, warnings: 0 },\n      trends: { responseTimeTrend: 'stable', errorRateTrend: 'stable', throughputTrend: 'stable', memoryUsageTrend: 'stable' }\n    };\n  }\n\n  // Simplified metric calculation methods (would be enhanced with real data)\n  private getAverageResponseTime(): number { return 500; }\n  private getPercentileResponseTime(percentile: number): number { return 500 * (percentile / 50); }\n  private getCurrentRPS(): number { return 10; }\n  private getCurrentRPM(): number { return 600; }\n  private getCurrentRPH(): number { return 36000; }\n  private getPeakThroughput(): number { return 50; }\n  private getCurrentErrorRate(): number { return 0.5; }\n  private getCurrentErrorCount(): number { return 2; }\n  private getErrorsByType(): { [errorType: string]: number } { return { 'ValidationError': 1, 'TimeoutError': 1 }; }\n  \n  private analyzeResponseTimeTrend(): 'improving' | 'stable' | 'degrading' { return 'stable'; }\n  private analyzeErrorRateTrend(): 'improving' | 'stable' | 'degrading' { return 'stable'; }\n  private analyzeThroughputTrend(): 'increasing' | 'stable' | 'decreasing' { return 'stable'; }\n  private analyzeMemoryUsageTrend(): 'improving' | 'stable' | 'degrading' { return 'stable'; }\n\n  private determineSeverity(value: number, threshold: AlertThreshold): 'info' | 'warning' | 'error' | 'critical' {\n    if (threshold.comparison === 'greater_than') {\n      if (value >= threshold.criticalThreshold) return 'critical';\n      if (value >= threshold.errorThreshold) return 'error';\n      if (value >= threshold.warningThreshold) return 'warning';\n    }\n    return 'info';\n  }\n\n  private getThresholdValue(threshold: AlertThreshold, severity: 'warning' | 'error' | 'critical'): number {\n    switch (severity) {\n      case 'warning': return threshold.warningThreshold;\n      case 'error': return threshold.errorThreshold;\n      case 'critical': return threshold.criticalThreshold;\n    }\n  }\n\n  private getAlertImpact(metric: string, severity: string): string {\n    const impacts = {\n      response_time: 'Slow response times affect user experience and system performance',\n      error_rate: 'High error rates indicate system instability and affect reliability',\n      memory_usage: 'High memory usage can lead to performance degradation and function failures'\n    };\n    return impacts[metric as keyof typeof impacts] || 'System performance may be impacted';\n  }\n\n  private getAlertRecommendations(metric: string, severity: string): string[] {\n    const recommendations: { [key: string]: string[] } = {\n      response_time: ['Optimize database queries', 'Implement caching', 'Review Lambda configuration'],\n      error_rate: ['Check error logs', 'Review code for error handling', 'Monitor external dependencies'],\n      memory_usage: ['Increase Lambda memory allocation', 'Optimize memory usage in code', 'Review data structures']\n    };\n    return recommendations[metric] || ['Review system configuration and performance'];\n  }\n\n  /**\n   * Get the last health check result\n   */\n  getLastHealthCheck(): SystemHealthCheck | null {\n    return this.lastHealthCheck;\n  }\n\n  /**\n   * Update health check configuration\n   */\n  updateConfig(config: Partial<HealthCheckConfig>): void {\n    this.config = { ...this.config, ...config };\n    this.logger.info('Health check configuration updated', { config: this.config });\n  }\n}", "import validate from './validate.js';\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  //\n  // Note to future-self: No, you can't remove the `toLowerCase()` call.\n  // REF: https://github.com/uuidjs/uuid/pull/677#issuecomment-1757351351\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset);\n  // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n  return uuid;\n}\nexport default stringify;", "import crypto from 'node:crypto';\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\nlet poolPtr = rnds8Pool.length;\nexport default function rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    crypto.randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}", "import crypto from 'node:crypto';\nexport default {\n  randomUUID: crypto.randomUUID\n};", "import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    offset = offset || 0;\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n    return buf;\n  }\n  return unsafeStringify(rnds);\n}\nexport default v4;", "import { DynamoDBClient } from '@aws-sdk/client-dynamodb';\nimport { DynamoDBDocumentClient, PutCommand, QueryCommand, UpdateCommand } from '@aws-sdk/lib-dynamodb';\nimport { Logger } from '../shared/logger';\nimport { \n  HealthPerformanceMetrics,\n  HealthHistoryEntry,\n  HealthReport,\n  HealthAlert,\n  SystemRecommendation,\n  GenerateHealthReportRequest,\n  GenerateHealthReportResponse,\n  GetHealthHistoryRequest,\n  GetHealthHistoryResponse,\n  SystemHealthCheck\n} from '../types';\nimport { v4 as uuidv4 } from 'uuid';\n\n/**\n * Monitoring Service - Handles performance monitoring, metrics collection, and health reporting\n * Provides comprehensive system monitoring capabilities with historical data tracking\n */\nexport class MonitoringService {\n  private client: DynamoDBDocumentClient;\n  private logger: Logger;\n  private readonly metricsTable: string;\n  private readonly alertsTable: string;\n  private performanceBuffer: Map<string, any[]> = new Map();\n  private metricsCache: Map<string, HealthPerformanceMetrics> = new Map();\n\n  constructor() {\n    this.logger = new Logger('MonitoringService');\n    \n    // Initialize DynamoDB client\n    const dynamoClient = new DynamoDBClient({\n      region: process.env.AWS_REGION || 'us-east-1'\n    });\n    this.client = DynamoDBDocumentClient.from(dynamoClient);\n    \n    this.metricsTable = process.env.HEALTH_METRICS_TABLE || 'StudyApp-HealthMetrics';\n    this.alertsTable = process.env.HEALTH_ALERTS_TABLE || 'StudyApp-HealthAlerts';\n\n    this.logger.info('MonitoringService initialized', {\n      metricsTable: this.metricsTable,\n      alertsTable: this.alertsTable\n    });\n\n    // Start background metrics collection\n    this.startMetricsCollection();\n  }\n\n  /**\n   * Record performance metrics for historical tracking\n   */\n  async recordMetrics(metrics: HealthPerformanceMetrics): Promise<void> {\n    try {\n      const timestamp = new Date().toISOString();\n      const ttl = Math.floor(Date.now() / 1000) + (30 * 24 * 60 * 60); // 30 days TTL\n\n      await this.client.send(new PutCommand({\n        TableName: this.metricsTable,\n        Item: {\n          PK: 'METRICS',\n          SK: `${timestamp}`,\n          timestamp,\n          metrics,\n          ttl\n        }\n      }));\n\n      // Update cache\n      this.metricsCache.set('latest', metrics);\n      \n      this.logger.debug('Performance metrics recorded', { timestamp });\n\n    } catch (error) {\n      this.logger.error('Failed to record metrics', { error });\n    }\n  }\n\n  /**\n   * Record health history entry\n   */\n  async recordHealthHistory(healthCheck: SystemHealthCheck): Promise<void> {\n    try {\n      const timestamp = new Date().toISOString();\n      const ttl = Math.floor(Date.now() / 1000) + (90 * 24 * 60 * 60); // 90 days TTL\n\n      const historyEntry: HealthHistoryEntry = {\n        timestamp,\n        overallStatus: healthCheck.status,\n        componentStatuses: {\n          dynamodb: healthCheck.dependencies.dynamodb.status,\n          s3: healthCheck.dependencies.s3.status,\n          overall: healthCheck.dependencies.overall\n        },\n        metrics: {\n          responseTime: healthCheck.performance.throughput.averageResponseTime,\n          errorRate: healthCheck.performance.errors.errorRate,\n          throughput: healthCheck.performance.throughput.requestsPerSecond,\n          memoryUsage: healthCheck.performance.memory.utilizationPercentage\n        },\n        alerts: healthCheck.alerts.length,\n        incidents: healthCheck.alerts.filter(a => a.severity === 'critical' || a.severity === 'error').length\n      };\n\n      await this.client.send(new PutCommand({\n        TableName: this.metricsTable,\n        Item: {\n          PK: 'HEALTH_HISTORY',\n          SK: timestamp,\n          ...historyEntry,\n          ttl\n        }\n      }));\n\n      this.logger.debug('Health history recorded', { timestamp, status: healthCheck.status });\n\n    } catch (error) {\n      this.logger.error('Failed to record health history', { error });\n    }\n  }\n\n  /**\n   * Store health alert\n   */\n  async storeAlert(alert: HealthAlert): Promise<void> {\n    try {\n      const ttl = Math.floor(Date.now() / 1000) + (60 * 24 * 60 * 60); // 60 days TTL\n\n      await this.client.send(new PutCommand({\n        TableName: this.alertsTable,\n        Item: {\n          PK: 'ALERT',\n          SK: `${alert.createdAt}#${alert.alertId}`,\n          ...alert,\n          ttl\n        }\n      }));\n\n      this.logger.info('Alert stored', { \n        alertId: alert.alertId, \n        severity: alert.severity, \n        category: alert.category \n      });\n\n    } catch (error) {\n      this.logger.error('Failed to store alert', { alertId: alert.alertId, error });\n    }\n  }\n\n  /**\n   * Acknowledge an alert\n   */\n  async acknowledgeAlert(alertId: string, acknowledgedBy: string): Promise<void> {\n    try {\n      // First, find the alert\n      const queryResult = await this.client.send(new QueryCommand({\n        TableName: this.alertsTable,\n        KeyConditionExpression: 'PK = :pk',\n        FilterExpression: 'alertId = :alertId',\n        ExpressionAttributeValues: {\n          ':pk': 'ALERT',\n          ':alertId': alertId\n        }\n      }));\n\n      if (queryResult.Items && queryResult.Items.length > 0) {\n        const alert = queryResult.Items[0];\n        \n        if (alert) {\n          await this.client.send(new UpdateCommand({\n          TableName: this.alertsTable,\n          Key: {\n            PK: alert.PK,\n            SK: alert.SK\n          },\n          UpdateExpression: 'SET acknowledged = :ack, acknowledgedBy = :by, resolvedAt = :resolved',\n          ExpressionAttributeValues: {\n            ':ack': true,\n            ':by': acknowledgedBy,\n            ':resolved': new Date().toISOString()\n          }\n          }));\n\n          this.logger.info('Alert acknowledged', { alertId, acknowledgedBy });\n        }\n      }\n\n    } catch (error) {\n      this.logger.error('Failed to acknowledge alert', { alertId, error });\n    }\n  }\n\n  /**\n   * Get health history for specified time range\n   */\n  async getHealthHistory(request: GetHealthHistoryRequest): Promise<GetHealthHistoryResponse> {\n    try {\n      const endTime = new Date().toISOString();\n      const startTime = this.calculateStartTime(request.timeRange);\n\n      const queryResult = await this.client.send(new QueryCommand({\n        TableName: this.metricsTable,\n        KeyConditionExpression: 'PK = :pk AND SK BETWEEN :start AND :end',\n        ExpressionAttributeValues: {\n          ':pk': 'HEALTH_HISTORY',\n          ':start': startTime,\n          ':end': endTime\n        },\n        ScanIndexForward: true,\n        Limit: 1000\n      }));\n\n      const entries: HealthHistoryEntry[] = (queryResult.Items || []).map(item => ({\n        timestamp: item.timestamp,\n        overallStatus: item.overallStatus,\n        componentStatuses: item.componentStatuses,\n        metrics: item.metrics,\n        alerts: item.alerts,\n        incidents: item.incidents\n      }));\n\n      // Apply resolution filtering if specified\n      const filteredEntries = this.applyResolutionFilter(entries, request.resolution);\n\n      // Calculate summary statistics\n      const summary = this.calculateHistorySummary(entries);\n\n      return {\n        entries: filteredEntries,\n        summary\n      };\n\n    } catch (error) {\n      this.logger.error('Failed to get health history', { error });\n      return {\n        entries: [],\n        summary: {\n          totalDataPoints: 0,\n          averageHealth: 0,\n          incidents: 0,\n          majorOutages: 0\n        }\n      };\n    }\n  }\n\n  /**\n   * Generate comprehensive health report\n   */\n  async generateHealthReport(request: GenerateHealthReportRequest): Promise<GenerateHealthReportResponse> {\n    try {\n      this.logger.info('Generating health report', { \n        timeRange: request.timeRange,\n        includeRecommendations: request.includeRecommendations \n      });\n\n      // Get health history for the specified time range\n      const historyRequest: GetHealthHistoryRequest = {\n        timeRange: this.calculateTimeRangeFromDates(request.timeRange.start, request.timeRange.end),\n        resolution: 'hour'\n      };\n      \n      const historyResponse = await this.getHealthHistory(historyRequest);\n\n      // Get alerts for the time range\n      const alerts = await this.getAlertsForTimeRange(request.timeRange.start, request.timeRange.end);\n\n      // Generate report summary\n      const summary = this.generateReportSummary(historyResponse.entries, alerts);\n\n      // Analyze trends\n      const trends = this.analyzeTrends(historyResponse.entries);\n\n      // Get top issues\n      const topIssues = this.getTopIssues(alerts);\n\n      // Generate recommendations if requested\n      const recommendations = request.includeRecommendations \n        ? await this.generateRecommendations(historyResponse.entries, alerts)\n        : [];\n\n      const report: HealthReport = {\n        reportId: uuidv4(),\n        generatedAt: new Date().toISOString(),\n        timeRange: {\n          start: request.timeRange.start,\n          end: request.timeRange.end,\n          duration: this.calculateDuration(request.timeRange.start, request.timeRange.end)\n        },\n        summary,\n        trends,\n        topIssues,\n        recommendations,\n        history: historyResponse.entries\n      };\n\n      // Store report for future reference\n      await this.storeReport(report);\n\n      this.logger.info('Health report generated', { \n        reportId: report.reportId, \n        dataPoints: historyResponse.entries.length,\n        alertsAnalyzed: alerts.length \n      });\n\n      return { report };\n\n    } catch (error) {\n      this.logger.error('Failed to generate health report', { error });\n      throw error;\n    }\n  }\n\n  /**\n   * Get current system performance trends\n   */\n  async getPerformanceTrends(timeRange: 'hour' | 'day' | 'week' | 'month'): Promise<any> {\n    try {\n      const historyRequest: GetHealthHistoryRequest = {\n        timeRange,\n        resolution: timeRange === 'hour' ? 'minute' : timeRange === 'day' ? 'hour' : 'day'\n      };\n      \n      const historyResponse = await this.getHealthHistory(historyRequest);\n      return this.calculateDetailedTrends(historyResponse.entries);\n\n    } catch (error) {\n      this.logger.error('Failed to get performance trends', { error });\n      return null;\n    }\n  }\n\n  /**\n   * Get system uptime statistics\n   */\n  async getUptimeStats(): Promise<{ current: number; last24h: number; last7d: number; last30d: number }> {\n    try {\n      const now = new Date();\n      const last24h = new Date(now.getTime() - 24 * 60 * 60 * 1000).toISOString();\n      const last7d = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000).toISOString();\n      const last30d = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000).toISOString();\n\n      const [uptime24h, uptime7d, uptime30d] = await Promise.all([\n        this.calculateUptimeForPeriod(last24h, now.toISOString()),\n        this.calculateUptimeForPeriod(last7d, now.toISOString()),\n        this.calculateUptimeForPeriod(last30d, now.toISOString())\n      ]);\n\n      return {\n        current: uptime24h, // Current is same as last 24h\n        last24h: uptime24h,\n        last7d: uptime7d,\n        last30d: uptime30d\n      };\n\n    } catch (error) {\n      this.logger.error('Failed to get uptime stats', { error });\n      return { current: 0, last24h: 0, last7d: 0, last30d: 0 };\n    }\n  }\n\n  /**\n   * Start background metrics collection\n   */\n  private startMetricsCollection(): void {\n    // This would typically be handled by CloudWatch or external monitoring\n    // For now, we'll implement basic collection\n    setInterval(() => {\n      this.collectSystemMetrics();\n    }, 60000); // Every minute\n  }\n\n  /**\n   * Collect current system metrics\n   */\n  private async collectSystemMetrics(): Promise<void> {\n    try {\n      const memoryUsage = process.memoryUsage();\n      const memoryLimit = parseInt(process.env.AWS_LAMBDA_FUNCTION_MEMORY_SIZE || '512');\n      \n      const metrics: HealthPerformanceMetrics = {\n        memory: {\n          current: Math.round(memoryUsage.rss / 1024 / 1024),\n          peak: Math.round(memoryUsage.heapUsed / 1024 / 1024),\n          limit: memoryLimit,\n          utilizationPercentage: Math.round((memoryUsage.rss / 1024 / 1024) / memoryLimit * 100),\n          gcFrequency: 0\n        },\n        execution: {\n          coldStartFrequency: 0,\n          averageExecutionTime: 0,\n          p95ExecutionTime: 0,\n          p99ExecutionTime: 0,\n          timeouts: 0\n        },\n        throughput: {\n          requestsPerSecond: 0,\n          requestsPerMinute: 0,\n          requestsPerHour: 0,\n          peakThroughput: 0,\n          averageResponseTime: 0\n        },\n        errors: {\n          errorRate: 0,\n          errorCount: 0,\n          errorsByType: {},\n          criticalErrors: 0,\n          warnings: 0\n        },\n        trends: {\n          responseTimeTrend: 'stable',\n          errorRateTrend: 'stable',\n          throughputTrend: 'stable',\n          memoryUsageTrend: 'stable'\n        }\n      };\n\n      // Store metrics but don't wait for it\n      this.recordMetrics(metrics).catch(error => {\n        this.logger.warn('Background metrics recording failed', { error });\n      });\n\n    } catch (error) {\n      this.logger.warn('Background metrics collection failed', { error });\n    }\n  }\n\n  // Helper methods\n  private calculateStartTime(timeRange: 'hour' | 'day' | 'week' | 'month'): string {\n    const now = new Date();\n    let hours = 1;\n    \n    switch (timeRange) {\n      case 'hour': hours = 1; break;\n      case 'day': hours = 24; break;\n      case 'week': hours = 24 * 7; break;\n      case 'month': hours = 24 * 30; break;\n    }\n    \n    return new Date(now.getTime() - hours * 60 * 60 * 1000).toISOString();\n  }\n\n  private calculateTimeRangeFromDates(start: string, end: string): 'hour' | 'day' | 'week' | 'month' {\n    const diffMs = new Date(end).getTime() - new Date(start).getTime();\n    const diffHours = diffMs / (1000 * 60 * 60);\n    \n    if (diffHours <= 1) return 'hour';\n    if (diffHours <= 24) return 'day';\n    if (diffHours <= 168) return 'week';\n    return 'month';\n  }\n\n  private calculateDuration(start: string, end: string): string {\n    const diffMs = new Date(end).getTime() - new Date(start).getTime();\n    const diffHours = Math.round(diffMs / (1000 * 60 * 60));\n    \n    if (diffHours < 24) return `${diffHours}h`;\n    const diffDays = Math.round(diffHours / 24);\n    return `${diffDays}d`;\n  }\n\n  private applyResolutionFilter(entries: HealthHistoryEntry[], resolution?: 'minute' | 'hour' | 'day'): HealthHistoryEntry[] {\n    if (!resolution || entries.length <= 100) return entries;\n    \n    // Simple sampling for now - in production, you'd implement proper aggregation\n    const sampleRate = resolution === 'minute' ? 1 : resolution === 'hour' ? 60 : 1440;\n    return entries.filter((_, index) => index % sampleRate === 0);\n  }\n\n  private calculateHistorySummary(entries: HealthHistoryEntry[]): any {\n    const totalDataPoints = entries.length;\n    const healthyCount = entries.filter(e => e.overallStatus === 'healthy').length;\n    const averageHealth = totalDataPoints > 0 ? (healthyCount / totalDataPoints) * 100 : 0;\n    const incidents = entries.reduce((sum, e) => sum + e.incidents, 0);\n    const majorOutages = entries.filter(e => e.overallStatus === 'unhealthy').length;\n\n    return {\n      totalDataPoints,\n      averageHealth,\n      incidents,\n      majorOutages\n    };\n  }\n\n  private async getAlertsForTimeRange(start: string, end: string): Promise<HealthAlert[]> {\n    try {\n      const queryResult = await this.client.send(new QueryCommand({\n        TableName: this.alertsTable,\n        KeyConditionExpression: 'PK = :pk AND SK BETWEEN :start AND :end',\n        ExpressionAttributeValues: {\n          ':pk': 'ALERT',\n          ':start': start,\n          ':end': end\n        }\n      }));\n\n      return (queryResult.Items || []) as HealthAlert[];\n    } catch (error) {\n      this.logger.error('Failed to get alerts for time range', { error });\n      return [];\n    }\n  }\n\n  private generateReportSummary(entries: HealthHistoryEntry[], alerts: HealthAlert[]): any {\n    const totalEntries = entries.length;\n    const healthyEntries = entries.filter(e => e.overallStatus === 'healthy').length;\n    const uptimePercentage = totalEntries > 0 ? (healthyEntries / totalEntries) * 100 : 100;\n    \n    const totalIncidents = alerts.length;\n    const resolvedIncidents = alerts.filter(a => a.resolvedAt).length;\n    \n    const responseTimes = entries.map(e => e.metrics.responseTime).filter(rt => rt > 0);\n    const averageResponseTime = responseTimes.length > 0 \n      ? responseTimes.reduce((sum, rt) => sum + rt, 0) / responseTimes.length \n      : 0;\n    \n    const errorRates = entries.map(e => e.metrics.errorRate).filter(er => er > 0);\n    const errorRate = errorRates.length > 0 \n      ? errorRates.reduce((sum, er) => sum + er, 0) / errorRates.length \n      : 0;\n\n    const overallHealth = uptimePercentage >= 99.9 ? 'excellent' \n      : uptimePercentage >= 99.5 ? 'good'\n      : uptimePercentage >= 95 ? 'fair' \n      : 'poor';\n\n    return {\n      overallHealth,\n      uptimePercentage,\n      totalIncidents,\n      resolvedIncidents,\n      averageResponseTime,\n      errorRate\n    };\n  }\n\n  private analyzeTrends(entries: HealthHistoryEntry[]): any {\n    if (entries.length < 2) {\n      return {\n        availabilityTrend: 'stable',\n        performanceTrend: 'stable',\n        errorTrend: 'stable',\n        dataQualityTrend: 'stable'\n      };\n    }\n\n    const midpoint = Math.floor(entries.length / 2);\n    const firstHalf = entries.slice(0, midpoint);\n    const secondHalf = entries.slice(midpoint);\n\n    const firstAvailability = firstHalf.filter(e => e.overallStatus === 'healthy').length / firstHalf.length;\n    const secondAvailability = secondHalf.filter(e => e.overallStatus === 'healthy').length / secondHalf.length;\n    \n    const firstPerformance = firstHalf.reduce((sum, e) => sum + e.metrics.responseTime, 0) / firstHalf.length;\n    const secondPerformance = secondHalf.reduce((sum, e) => sum + e.metrics.responseTime, 0) / secondHalf.length;\n    \n    const firstErrorRate = firstHalf.reduce((sum, e) => sum + e.metrics.errorRate, 0) / firstHalf.length;\n    const secondErrorRate = secondHalf.reduce((sum, e) => sum + e.metrics.errorRate, 0) / secondHalf.length;\n\n    return {\n      availabilityTrend: secondAvailability > firstAvailability ? 'improving' : \n                        secondAvailability < firstAvailability ? 'degrading' : 'stable',\n      performanceTrend: secondPerformance < firstPerformance ? 'improving' :\n                       secondPerformance > firstPerformance ? 'degrading' : 'stable',\n      errorTrend: secondErrorRate < firstErrorRate ? 'improving' :\n                 secondErrorRate > firstErrorRate ? 'degrading' : 'stable',\n      dataQualityTrend: 'stable' // Would need data quality metrics\n    };\n  }\n\n  private getTopIssues(alerts: HealthAlert[]): HealthAlert[] {\n    return alerts\n      .filter(a => a.severity === 'critical' || a.severity === 'error')\n      .sort((a, b) => {\n        const severityOrder = { critical: 0, error: 1, warning: 2, info: 3 };\n        return severityOrder[a.severity] - severityOrder[b.severity];\n      })\n      .slice(0, 10);\n  }\n\n  private async generateRecommendations(entries: HealthHistoryEntry[], alerts: HealthAlert[]): Promise<SystemRecommendation[]> {\n    const recommendations: SystemRecommendation[] = [];\n\n    // Analyze patterns and generate recommendations\n    const avgResponseTime = entries.reduce((sum, e) => sum + e.metrics.responseTime, 0) / entries.length;\n    const avgErrorRate = entries.reduce((sum, e) => sum + e.metrics.errorRate, 0) / entries.length;\n    const avgMemoryUsage = entries.reduce((sum, e) => sum + e.metrics.memoryUsage, 0) / entries.length;\n\n    if (avgResponseTime > 1000) {\n      recommendations.push({\n        id: uuidv4(),\n        priority: 'high',\n        category: 'performance',\n        title: 'Optimize Response Time',\n        description: 'Average response time is above optimal threshold',\n        reasoning: `Current average response time of ${Math.round(avgResponseTime)}ms exceeds the 1000ms threshold`,\n        actionItems: [\n          'Implement database query optimization',\n          'Add caching layer for frequently accessed data',\n          'Review Lambda memory allocation',\n          'Optimize code execution paths'\n        ],\n        estimatedImpact: {\n          performance: 30,\n          cost: 0,\n          reliability: 10\n        },\n        effort: 'medium',\n        timeline: '2-4 weeks'\n      });\n    }\n\n    if (avgErrorRate > 1) {\n      recommendations.push({\n        id: uuidv4(),\n        priority: 'high',\n        category: 'reliability',\n        title: 'Reduce Error Rate',\n        description: 'Error rate is higher than acceptable levels',\n        reasoning: `Current error rate of ${avgErrorRate.toFixed(2)}% exceeds the 1% threshold`,\n        actionItems: [\n          'Review and improve error handling',\n          'Implement retry mechanisms',\n          'Add input validation',\n          'Monitor third-party dependencies'\n        ],\n        estimatedImpact: {\n          performance: 10,\n          cost: 0,\n          reliability: 40\n        },\n        effort: 'medium',\n        timeline: '1-2 weeks'\n      });\n    }\n\n    if (avgMemoryUsage > 80) {\n      recommendations.push({\n        id: uuidv4(),\n        priority: 'medium',\n        category: 'performance',\n        title: 'Optimize Memory Usage',\n        description: 'Memory utilization is approaching limits',\n        reasoning: `Current average memory usage of ${Math.round(avgMemoryUsage)}% is above the 80% threshold`,\n        actionItems: [\n          'Increase Lambda memory allocation',\n          'Optimize data structures and algorithms',\n          'Implement memory cleanup routines',\n          'Profile memory usage patterns'\n        ],\n        estimatedImpact: {\n          performance: 20,\n          cost: -100, // Negative indicates cost increase\n          reliability: 15\n        },\n        effort: 'low',\n        timeline: '1 week'\n      });\n    }\n\n    return recommendations;\n  }\n\n  private calculateDetailedTrends(entries: HealthHistoryEntry[]): any {\n    // Implementation for detailed trend analysis\n    return {\n      responseTime: entries.map(e => ({ timestamp: e.timestamp, value: e.metrics.responseTime })),\n      errorRate: entries.map(e => ({ timestamp: e.timestamp, value: e.metrics.errorRate })),\n      throughput: entries.map(e => ({ timestamp: e.timestamp, value: e.metrics.throughput })),\n      memoryUsage: entries.map(e => ({ timestamp: e.timestamp, value: e.metrics.memoryUsage }))\n    };\n  }\n\n  private async calculateUptimeForPeriod(start: string, end: string): Promise<number> {\n    try {\n      const queryResult = await this.client.send(new QueryCommand({\n        TableName: this.metricsTable,\n        KeyConditionExpression: 'PK = :pk AND SK BETWEEN :start AND :end',\n        ExpressionAttributeValues: {\n          ':pk': 'HEALTH_HISTORY',\n          ':start': start,\n          ':end': end\n        }\n      }));\n\n      const entries = queryResult.Items || [];\n      if (entries.length === 0) return 100; // Default to 100% if no data\n\n      const healthyEntries = entries.filter(item => item.overallStatus === 'healthy').length;\n      return (healthyEntries / entries.length) * 100;\n\n    } catch (error) {\n      this.logger.error('Failed to calculate uptime', { error });\n      return 100; // Default to 100% on error\n    }\n  }\n\n  private async storeReport(report: HealthReport): Promise<void> {\n    try {\n      const ttl = Math.floor(Date.now() / 1000) + (365 * 24 * 60 * 60); // 1 year TTL\n\n      await this.client.send(new PutCommand({\n        TableName: this.metricsTable,\n        Item: {\n          PK: 'REPORT',\n          SK: `${report.generatedAt}#${report.reportId}`,\n          ...report,\n          ttl\n        }\n      }));\n\n    } catch (error) {\n      this.logger.warn('Failed to store report', { reportId: report.reportId, error });\n    }\n  }\n}"],
  "mappings": "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",
  "names": ["health_handler_exports", "__export", "handler", "__toCommonJS", "ApiError", "code", "message", "details", "ResponseBuilder", "data", "statusCode", "message", "response", "code", "details", "items", "totalCount", "page", "pageSize", "totalPages", "hasNextPage", "hasPrevPage", "Logger", "context", "message", "data", "error", "errorData", "operation", "duration", "level", "logEntry", "levels", "currentLevelIndex", "BaseHandler", "handlerName", "Logger", "handler", "event", "requestId", "route", "ResponseBuilder", "userId", "validationError", "startTime", "result", "duration", "error", "authorizer", "ApiError", "key", "defaultValue", "data", "message", "details", "import_client_dynamodb", "import_lib_dynamodb", "import_client_s3", "byteToHex", "i", "unsafeStringify", "arr", "offset", "import_node_crypto", "rnds8Pool", "poolPtr", "rng", "crypto", "import_node_crypto", "native_default", "crypto", "v4", "options", "buf", "offset", "native_default", "rnds", "rng", "i", "unsafeStringify", "v4_default", "HealthService", "config", "Logger", "dynamoClient", "startTime", "timestamp", "environment", "dependencyHealth", "performanceMetrics", "dataQuality", "alerts", "recommendations", "overallStatus", "healthCheck", "duration", "error", "v4_default", "dynamodbHealth", "s3Health", "externalHealth", "statuses", "ext", "overall", "tables", "connectivityTest", "connectivity", "tableName", "tableHealth", "totalResponseTime", "performance", "scanResult", "responseTime", "status", "buckets", "bucketName", "bucketStartTime", "listResult", "b", "results", "service", "response", "memoryUsage", "memoryLimit", "memory", "execution", "throughput", "errors", "trends", "checks", "passedChecks", "checkConfig", "check", "passRate", "actualCount", "expectedCount", "dependencies", "threshold", "currentValue", "metricName", "severity", "sum", "table", "totalTables", "errorTables", "operationType", "percentile", "value", "metric", "import_client_dynamodb", "import_lib_dynamodb", "MonitoringService", "Logger", "dynamoClient", "metrics", "timestamp", "ttl", "error", "healthCheck", "historyEntry", "alert", "alertId", "acknowledgedBy", "queryResult", "request", "endTime", "startTime", "entries", "item", "filteredEntries", "summary", "historyRequest", "historyResponse", "alerts", "trends", "topIssues", "recommendations", "report", "v4_default", "timeRange", "now", "last24h", "last7d", "last30d", "uptime24h", "uptime7d", "uptime30d", "memoryUsage", "memoryLimit", "hours", "start", "end", "diffHours", "diffMs", "resolution", "sampleRate", "_", "index", "totalDataPoints", "healthyCount", "e", "averageHealth", "incidents", "sum", "majorOutages", "totalEntries", "healthyEntries", "uptimePercentage", "totalIncidents", "resolvedIncidents", "a", "responseTimes", "rt", "averageResponseTime", "errorRates", "er", "errorRate", "midpoint", "firstHalf", "secondHalf", "firstAvailability", "secondAvailability", "firstPerformance", "secondPerformance", "firstErrorRate", "secondErrorRate", "b", "severityOrder", "avgResponseTime", "avgErrorRate", "avgMemoryUsage", "HealthHandler", "BaseHandler", "HealthService", "MonitoringService", "event", "healthCheck", "basicHealth", "error", "includeHistory", "uptime", "history", "historyRequest", "response", "timeRange", "includeHistorical", "currentMetrics", "historical", "databaseMetrics", "check", "storageMetrics", "alert", "servicesOverview", "sum", "table", "bucket", "ext", "count", "severity", "category", "limit", "alerts", "allAlerts", "summary", "a", "resolution", "components", "request", "body", "alertId", "acknowledgedBy", "healthHandler", "handler", "path", "method"]
}
